<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://leijue222.github.io/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://leijue222.github.io/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Yuze&amp;apos;s Blog</title>
    <link>https://leijue222.github.io/</link>
    <description>丁煜赜的博客</description>
    <language>zh-CN</language>
    <pubDate>Tue, 11 Apr 2023 03:07:14 GMT</pubDate>
    <lastBuildDate>Tue, 11 Apr 2023 03:07:14 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>基于 MIT 协议，© 2023-至今 Yuze</copyright>
    <category>前端</category>
    <category>小程序</category>
    <category>Node.js</category>
    <category>Vue</category>
    <category>JavaScript</category>
    <category>Git</category>
    <category>Linux</category>
    <category>基础</category>
    <category>Markdown</category>
    <category>CSS</category>
    <category>HTML</category>
    <category>Emmet</category>
    <category>jQuery</category>
    <item>
      <title>教程目录</title>
      <link>https://leijue222.github.io/tutorial/</link>
      <guid>https://leijue222.github.io/tutorial/</guid>
      <source url="https://leijue222.github.io/rss.xml">教程目录</source>
      <description>此处是一些教程收藏，部分为直接搬运，部位为自助整理。</description>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>此处是一些教程收藏，部分为直接搬运，部位为自助整理。</p>
<!-- more -->
<h2> 目录</h2>
<h3> 前端开发</h3>
<ul>
<li>
<p><a href="/tutorial/front-end/website/" target="blank">网站相关</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/" target="blank">小程序</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/vue/" target="blank">Vue</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/react/" target="blank">React</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/angular/" target="blank">Angular</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/node-js/" target="blank">Node.js</a></p>
</li>
</ul>
<h3> 运维工具</h3>
<ul>
<li>
<p><a href="/tutorial/ops/linux/" target="blank">Linux</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/" target="blank">Git</a></p>
</li>
<li>
<p><a href="/tutorial/ops/markdown/" target="blank">Markdown</a></p>
</li>
</ul>
<h3> 代码学习网站</h3>
<h3> 优质网站</h3>
<ul>
<li>
<p><a href="https://wangdoc.com/" target="_blank" rel="noopener noreferrer">网道</a></p>
</li>
<li>
<p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener noreferrer">廖雪峰的网站</a></p>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener noreferrer">MDN</a></p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>MDN 的中文文档翻译很差，大多都是机翻，十分建议直接阅读英文文档。</p>
</div>
</li>
</ul>
<h3> 杂牌网站</h3>
<ul>
<li>
<p><a href="https://www.runoob.com/" target="_blank" rel="noopener noreferrer">菜鸟教程</a> </p>
</li>
<li>
<p><a href="https://www.w3cschool.cn" target="_blank" rel="noopener noreferrer">w3cschool</a> </p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener noreferrer">w3school</a> </p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>目录</title>
      <link>https://leijue222.github.io/tutorial/front-end/READMD.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/READMD.html</guid>
      <source url="https://leijue222.github.io/rss.xml">目录</source>
      <description>目录 前端开发 网站相关 (website/README.md); 小程序 (mini-app/README.md); Vue (vue/README.md); React (react/README.md); Angular (angular/README.md); Node.js (node-js/README.md);</description>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<!-- more -->
<h2> 目录</h2>
<h3> 前端开发</h3>
<ul>
<li>
<p><a href="/tutorial/front-end/website/" target="blank">网站相关</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/" target="blank">小程序</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/vue/" target="blank">Vue</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/react/" target="blank">React</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/angular/" target="blank">Angular</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/node-js/" target="blank">Node.js</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>目录</title>
      <link>https://leijue222.github.io/tutorial/ops/READMD.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/READMD.html</guid>
      <source url="https://leijue222.github.io/rss.xml">目录</source>
      <description>目录 运维工具 Linux (linux/README.md); Git (git/README.md); Markdown (markdown/README.md);</description>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<!-- more -->
<h2> 目录</h2>
<h3> 运维工具</h3>
<ul>
<li>
<p><a href="/tutorial/ops/linux/" target="blank">Linux</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/" target="blank">Git</a></p>
</li>
<li>
<p><a href="/tutorial/ops/markdown/" target="blank">Markdown</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Angular</title>
      <link>https://leijue222.github.io/tutorial/front-end/angular/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/angular/</guid>
      <source url="https://leijue222.github.io/rss.xml">Angular</source>
      <description>Angular 是 Google 官方在 2016 年 9 月出品的一款框架。 框架强制 Typescript，更倾向于大型项目。</description>
      <category>前端</category>
      <pubDate>Wed, 06 May 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>Angular 是 Google 官方在 2016 年 9 月出品的一款框架。</p>
<p>框架强制 Typescript，更倾向于大型项目。</p>
<!-- more -->
<div class="hint-container info">
<p class="hint-container-title">Angular 的优点</p>
<ol>
<li>零配置 CLI，享受到 webpack 每次升级的好处，但是不用关心任何 webpack config</li>
<li>官方提供所有的必须组件(http、router、animation、ssr、e2e 等等)，在 2000+ 内部应用测试之后才会发布，基本零 bug，并且保证在未来很多年内一直保证兼容升级</li>
<li>提供官方的应用市场和 low code 生成工具，一行命令就可以生成 Dashboard 和各种页面</li>
<li>框架 100% 由 TypeScript 开发，并且生态内的所有三方库都是(只能用) TypeScript 开发</li>
<li>内置 RxJS，并且从 View 的操作到 Http 全部都是 Reactive 的，可以随意组合</li>
<li>每次升级只要运行一行命令就会帮您修复所有的可能的不兼容问题</li>
<li>通过 Template 隔绝底层的 Compiler 升级成本，Compiler 迭代了三代，性能不断提升，bundle size 不断减少，但是用户代码一行不用改</li>
</ol>
</div>
<p>Angular 写起来其实是有诸多限制的，但是对企业的大型项目来说，这些限制与规范会带来多人协同开发和后期维护上的简便。</p>
<p>如果您在前端框架上追求的更多是: 升级稳定、标准统一、长期维护成本低、协作方便，不需要频繁重构，Angular 的使用感受应该还是相当不错的，这也是为什么目前大量企业用户会选择 Angular 的原因。</p>
<h2> 相关链接</h2>
<ul>
<li><a href="https://angular.io/docs" target="_blank" rel="noopener noreferrer">官方文档</a></li>
<li><a href="https://angular.cn/docs" target="_blank" rel="noopener noreferrer">中文文档</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>小程序</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/</guid>
      <source url="https://leijue222.github.io/rss.xml">小程序</source>
      <description>提示 在开发小程序之前。应当掌握 HTML、CSS、JavaScript 基础 以及 ES6。</description>
      <category>小程序</category>
      <pubDate>Mon, 25 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>在开发小程序之前。应当掌握 <a href="/tutorial/front-end/website/html/" target="blank">HTML</a>、<a href="/tutorial/front-end/website/css/" target="blank">CSS</a>、<a href="/tutorial/front-end/language/js/guide/" target="blank">JavaScript 基础</a> 以及 <a href="/tutorial/front-end/language/js/es6/" target="blank">ES6</a>。</p>
</div>
<!-- more -->
<h2> 小程序基础简介</h2>
<p>在微信小程序中主要有四种文件结构: <code>wxml</code>、<code>wxss</code>、<code>js</code> 和 <code>json</code>。其中 <code>wxml</code> 对应带有 vue.js 特征的 html5，<code>wxss</code> 对应 css3，<code>js</code> 对应 ES6 标准的的 javaScript。</p>
<p>对于 QQ 小程序，其文件结构为 <code>QML</code>、<code>qss</code>、<code>js</code> 和 <code>json</code>。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>QQ 小程序本质还是换汤不换药的，且 QQ 开发者工具兼容 <code>wxml</code> 与 <code>wss</code>)</p>
</div>
<p>小程序开发与网页开发极其相似。所以必须有适当的网页开发基础。零基础的人可能很难直接上手小程序开发。</p>
<h2> 教程目录</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/file-structure.html" target="blank">文件结构</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/env.html" target="blank">运行环境</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/config/" target="blank">小程序配置</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/config/app-config.html" target="blank">全局配置</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/config/page-config.html" target="blank">页面配置</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/config/sitemap-config.html" target="blank">sitemap 配置</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/" target="blank">小程序框架</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/intro.html" target="blank">框架介绍</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/scene.html" target="blank">场景值</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/env.html" target="blank">运行环境</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/mechanism.html" target="blank">运行机制</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/update.html" target="blank">更新机制</a> </p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/" target="blank">逻辑层</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/lifetime.html" target="blank">生命周期</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/route.html" target="blank">路由</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/register.html" target="blank">注册</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/app.html" target="blank">App()</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/page.html" target="blank">Page()</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/run.html" target="blank">运行</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/module.html" target="blank">模块化</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/api/" target="blank">API</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/" target="blank">视图层</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxml.html" target="blank">WXML</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxss.html" target="blank">WXSS</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxs.html" target="blank">WXS</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/event.html" target="blank">事件</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/component.html" target="blank">基础组件</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/animation.html" target="blank">动画</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxs.html" target="blank">WXS</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxs-event.html" target="blank">WXS 事件</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/model.html" target="blank">建议双向绑定</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/selector.html" target="blank">获取界面上的节点信息</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/selector.html" target="blank">相应显示区域变化</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/rendering-cache.html" target="blank">初始渲染缓存</a> </p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/" target="blank">小程序能力</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/network.html" target="blank">网络请求</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/storage.html" target="blank">存储</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/file-system.html" target="blank">文件系统</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/debug.html" target="blank">调试</a></p>
</li>
</ul>
</li>
</ul>
<h2> 开发者工具</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/tools/interface.html" target="blank">工具界面简介</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/tools/debug.html" target="blank">调试</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/tools/npm.html" target="blank">npm</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/tools/audit.html" target="blank">体验评分</a></p>
</li>
</ul>
<h2> 官方教程</h2>
<ul>
<li><a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a" target="_blank" rel="noopener noreferrer">点击前往</a></li>
</ul>
<h2> 案例</h2>
<ul>
<li><a href="https://github.com/Hope-Studio/wxminiappdemo" target="_blank" rel="noopener noreferrer">GitHub repository</a></li>
</ul>
<h2> Mr.Hope 框架说明</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/framework/" target="blank">小程序框架使用说明</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/framework/tag-list.html" target="blank">tag 值参数表</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/framework/page.html" target="blank">setPage 库使用说明</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/framework/simple-debug.html" target="blank">界面简单开发学习指南</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/qr-code.html" target="blank">分享相关</a></p>
</li>
</ul>
<h2> 学习视频</h2>
<ul>
<li>
<p><a href="https://www.bilibili.com/video/av22790583/" target="_blank" rel="noopener noreferrer">零基础开发小程序</a>(比较新的视频，强调总体思想)</p>
</li>
<li>
<p><a href="https://www.bilibili.com/video/av11938917" target="_blank" rel="noopener noreferrer">小程序-从入门到入土</a>(比较老的视频，针对每个组件或者 API 进行了针对的讲解与示范，但部分内容已经与最新官方文档不符)</p>
</li>
</ul>
<h2> 示例代码</h2>
<ul>
<li>
<p><a href="https://github.com/wechat-miniprogram/miniprogram-demo" target="_blank" rel="noopener noreferrer">小程序实例源码</a></p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg" alt="小程序示例二维码" loading="lazy"></p>
</li>
</ul>
<h2> 官方文档</h2>
<ul>
<li><a href="https://q.qq.com/wiki/" target="_blank" rel="noopener noreferrer">QQ 小程序</a></li>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/" target="_blank" rel="noopener noreferrer">微信小程序</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/question" target="_blank" rel="noopener noreferrer">微信小程序社区</a>
<ul>
<li><a href="https://developers.weixin.qq.com/community/develop/list/2?id=" target="_blank" rel="noopener noreferrer">官方公告</a></li>
</ul>
</li>
</ul>
<h3> QQ 开发者工具</h3>
<p>现在很多功能还处于缺失状态，bug 到没之前那么多了。</p>
<ul>
<li>
<p><a href="https://q.qq.com/wiki/" target="_blank" rel="noopener noreferrer">查看详情</a></p>
</li>
<li>
<p><a href="https://q.qq.com/wiki/tools/devtool/" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
</ul>
<h2> 微信开发者工具</h2>
<p>微信开发者工具用来开发与调试微信小程序和微信相关网页的官方工具。小程序使用该开发工具进行开发。</p>
<ul>
<li>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/tools/" target="blank">开发者工具教程</a></p>
</li>
<li>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html" target="_blank" rel="noopener noreferrer">官方使用指南</a></p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/demo.ef5c5bef.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>小程序分享</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/qr-code.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/qr-code.html</guid>
      <source url="https://leijue222.github.io/rss.xml">小程序分享</source>
      <description>二维码生成 目前小程序二维码生成选用的是无限制生成二维码 (https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html)。 我们使用 Postman 软件进行二维码的获取。 调用凭据获取 获取任何二维码都需...</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 二维码生成</h2>
<p>目前小程序二维码生成选用的是<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="noopener noreferrer">无限制生成二维码</a>。</p>
<p>我们使用 Postman 软件进行二维码的获取。</p>
<h3> 调用凭据获取</h3>
<p>获取任何二维码都需要先获取 <code>access_token</code>，这是小程序全局唯一后台接口调用凭据。<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html" target="_blank" rel="noopener noreferrer">文档地址</a></p>
<p>请求方式为:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>更多详情可以见文档。<code>AppSecret</code> 由于权限很大不在此文档中直接放置。</p>
<h3> 无限制二维码生成</h3>
<ul>
<li><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/qr-code/wxacode.getUnlimited.html" target="_blank" rel="noopener noreferrer">文档地址</a></li>
</ul>
<p>在获取 <code>access_token</code> 之后就可以获取小程序二维码了。</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请注意，在 Postman 软件中，首先要注意使用 <code>post</code> 方法。Body 使用 <code>raw</code>，格式选择 <code>Text</code>，需要将 <code>pretty</code> 化的 JSON 输入即可正常获取二维码。获取完二维码之后，需要在 <code>response</code> 中点击返回图片右上角的 <code>save as</code>，保存为 <code>jpg</code> 格式的文件即可保存二维码。</p>
<h2> 小程序链接</h2>
<ul>
<li><a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Service_Center_messages.html" target="_blank" rel="noopener noreferrer">文档地址</a></li>
</ul>
<p>具体格式如下:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Node.js</title>
      <link>https://leijue222.github.io/tutorial/front-end/node-js/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/node-js/</guid>
      <source url="https://leijue222.github.io/rss.xml">Node.js</source>
      <description>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</description>
      <category>Node.js</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>
<!-- more -->
<h2> 教程目录</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/node-js/intro.html" target="blank">Node.js 介绍</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/node-js/install.html" target="blank">Node.js 与 npm 安装</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/node-js/environment.html" target="blank">Node.js 环境</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/node-js/program.html" target="blank">编程</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/node-js/cjs.html" target="blank">Node.js CJS 模块</a></p>
</li>
</ul>
<p>以上，就是 Node.js 的简易介绍，系统学习可以查看下方的详细教程。</p>
<h2> 初学者教程</h2>
<ul>
<li>
<p><a href="https://www.nodebeginner.org/index-zh-cn.html" target="_blank" rel="noopener noreferrer">Node.js 入门</a></p>
</li>
<li>
<p><a href="https://www.w3cschool.cn/nodejs/" target="_blank" rel="noopener noreferrer">W3CSchool</a></p>
</li>
</ul>
<h2> 官方文档</h2>
<ul>
<li><a href="https://nodejs.org/dist/latest-v14.x/docs/api/" target="_blank" rel="noopener noreferrer">地址</a></li>
</ul>
<h2> Yarn</h2>
<p>快速、可靠、安全的依赖管理工具。</p>
<ul>
<li>
<p>Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。同时利用并行下载以最大化资源利用率，因此安装速度更快。</p>
</li>
<li>
<p>在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。</p>
</li>
<li>
<p>使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs/install#windows-stable" target="_blank" rel="noopener noreferrer">下载地址</a></p>
</li>
<li>
<p><a href="https://www.yarnpkg.com/zh-Hans/docs" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
</ul>
<h3> 命令</h3>
<ul>
<li>
<p><code>yarn install</code>: 执行安装</p>
</li>
<li>
<p><code>yarn upgrade</code>: 执行升级</p>
</li>
<li>
<p><code>yarn add &lt;package&gt;</code>: 添加一个包</p>
</li>
<li>
<p><code>yarn config set cache-folder &lt;path&gt;</code>: 更改缓存文件夹</p>
</li>
<li>
<p><code>yarn config set registry &lt;registry&gt;</code>: 更改源</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>在国内，建议换成淘宝源 <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener noreferrer">https://registry.npm.taobao.org</a></p>
<p>即执行</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>模块</title>
      <link>https://leijue222.github.io/tutorial/front-end/node-js/cjs.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/node-js/cjs.html</guid>
      <source url="https://leijue222.github.io/rss.xml">模块</source>
      <description>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。 为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 .js 文件就称之为一个模块(module)。 使用模块有什么好处? 最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。 使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</description>
      <category>Node.js</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。</p>
<p>为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Node.js 环境中，一个 <code>.js</code> 文件就称之为一个模块(module)。</p>
<p>使用模块有什么好处?</p>
<p>最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Node.js 内置的模块和来自第三方的模块。</p>
<p>使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。</p>
<!-- more -->
<p>在上一节，我们编写了一个 hello.js 文件，这个 hello.js 文件就是一个模块，模块的名字就是文件名(去掉.js 后缀)，所以 hello.js 文件就是名为 hello 的模块。</p>
<p>我们把 hello.js 改造一下，创建一个函数，这样我们就可以在其他地方调用这个函数:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数 <code>greet()</code> 是我们在 hello 模块中定义的，您可能注意到最后一行是一个奇怪的赋值语句，它的意思是，把函数 <code>greet</code> 作为模块的输出暴露出去，这样其他模块就可以使用 <code>greet</code> 函数了。</p>
<p>问题是其他模块怎么使用 hello 模块的这个 <code>greet</code> 函数呢? 我们再编写一个 <code>main.js</code> 文件，调用 <code>hello</code> 模块的 <code>greet</code> 函数:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意到引入 <code>hello</code> 模块用 Node.js 提供的 <code>require</code> 函数:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>引入的模块作为变量保存在 <code>greet</code> 变量中，那 greet 变量到底是什么东西? 其实变量 <code>greet</code> 就是在 <code>hello.js</code> 中我们用 <code>module.exports = greet;</code> 输出的 <code>greet</code> 函数。所以，<code>main.js</code> 就成功地引用了 <code>hello.js</code> 模块中定义的 <code>greet()</code> 函数，接下来就可以直接使用它了。</p>
<p>在使用 <code>require()</code> 引入模块的时候，请注意模块的相对路径。因为 main.js 和 hello.js 位于同一个目录，所以我们用了当前目录.:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果只写模块名:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>则 Node.js 会依次在内置模块、全局模块和当前模块下查找 hello.js，您很可能会得到一个错误:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>遇到这个错误，您要检查:</p>
<ul>
<li>模块名是否写对了；</li>
<li>模块文件是否存在；</li>
<li>相对路径是否写对了。</li>
</ul>
<h2> CommonJS 规范</h2>
<p>这种模块加载机制被称为 <code>CommonJS</code> 规范。在这个规范下，每个 <code>.js</code> 文件都是一个模块，它们内部各自使用的变量名和函数名都互不冲突，例如，<code>hello.js</code> 和 <code>main.js</code> 都申明了全局变量 <code>const s = 'xxx'</code>，但互不影响。</p>
<p>一个模块想要对外暴露变量(函数也是变量)，可以用 <code>module.exports = variable;</code>，一个模块要引用其他模块暴露的变量，用 <code>const ref = require('module_name');</code> 就拿到了引用模块的变量。</p>
<h2> 总结</h2>
<p>要在模块中对外输出变量，用:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>输出的变量可以是任意对象、函数、数组等等。</p>
<p>要引入其他模块输出的对象，用:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>引入的对象具体是什么，取决于引入模块输出的对象。</p>
<h2> 深入了解模块原理</h2>
<p>如果您想详细地了解<strong>CommonJS</strong>的模块实现原理，请继续往下阅读。如果不想了解，请结束阅读。</p>
<p>当我们编写 JavaScript 代码时，我们可以申明全局变量:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在浏览器中，大量使用全局变量可不好。如果您在 <code>a.js</code> 中使用了全局变量 s，那么，在 <code>b.js</code> 中也使用全局变量 s，将造成冲突，<code>b.js</code> 中对 s 赋值会改变 <code>a.js</code> 的运行逻辑。</p>
<p>也就是说，JavaScript 语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。</p>
<p>那 Node.js 是如何实现这一点的?</p>
<p>其实要实现“模块”这个功能，并不需要语法层面的支持。Node.js 也并不会增加任何 JavaScript 语法。实现“模块”功能的奥妙就在于 JavaScript 是一种函数式编程语言，它支持闭包。如果我们把一段 JavaScript 代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。</p>
<p>请注意我们编写的 <code>hello.js</code> 代码是这样的:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Node.js 加载了 hello.js 后，它可以把代码包装一下，变成这样执行:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样一来，原来的全局变量 <code>s</code> 现在变成了匿名函数内部的局部变量。如果 Node.js 继续加载其他模块，这些模块中定义的“全局”变量 <code>s</code> 也互不干扰。</p>
<p>所以，Node.js 利用 JavaScript 的函数式编程的特性，轻而易举地实现了模块的隔离。</p>
<p>但是，模块的输出 <code>module.exports</code> 怎么实现?</p>
<p>这个也很容易实现，Node.js 可以先准备一个对象 <code>module</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见，变量 module 是 Node.js 在加载 js 文件前准备的一个变量，并将其传入加载函数，我们在 <code>hello.js</code> 中可以直接使用变量 <code>module</code> 原因就在于它实际上是函数的一个参数:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过把参数 <code>module</code> 传递给 <code>load()</code> 函数，<code>hello.js</code> 就顺利地把一个变量传递给了 Node.js 执行环境，Node.js 会把 module 变量保存到某个地方。</p>
<p>由于 Node.js 保存了所有导入的 module，当我们用 <code>require()</code> 获取 module 时，Node.js 找到对应的 module，把这个 module 的 <code>exports</code> 变量返回，这样，另一个模块就顺利拿到了模块的输出:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>以上是 Node.js 实现 JavaScript 模块的一个简单的原理介绍。</p>
<h2> module.exports vs exports</h2>
<p>很多时候，您会看到，在 Node.js 环境中，有两种方法可以在一个模块中输出变量:</p>
<p>方法一: 对 module.exports 赋值:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法二: 直接使用 exports:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是您不可以直接对 exports 赋值:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果您对上面的写法感到十分困惑，不要着急，我们来分析 Node.js 的加载机制:</p>
<p>首先，Node.js 会把整个待加载的 hello.js 文件放入一个包装函数 load 中执行。在执行这个 load()函数前，Node.js 准备好了 module 变量:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>load()</code> 函数最终返回 <code>module.exports</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，默认情况下，Node.js 准备的 <code>exports</code> 变量和 <code>module.exports</code> 变量实际上是同一个变量，并且初始化为空对象 <code>{}</code>，于是，我们可以写:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以写:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>换句话说，Node.js 默认给您准备了一个空对象 <code>{}</code>，这样您可以直接往里面加东西。</p>
<p>但是，如果我们要输出的是一个函数或数组，那么，只能给 <code>module.exports</code> 赋值:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给 <code>exports</code> 赋值是无效的，因为赋值后，<code>module.exports</code> 仍然是空对象 <code>{}</code>。</p>
<h2> 结论</h2>
<p>如果要输出一个键值对象 <code>{}</code>，可以利用 <code>exports</code> 这个已存在的空对象 <code>{}</code>，并继续在上面添加新的键值；</p>
<p>如果要输出一个函数或数组，必须直接对 <code>module.exports</code> 对象赋值。</p>
<p>所以我们可以得出结论: 直接对 <code>module.export</code>s 赋值，可以应对任何情况:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终，我们强烈建议使用 <code>module.exports = xxx</code> 的方式来输出模块变量，这样，您只需要记忆一种方法。</p>
]]></content:encoded>
    </item>
    <item>
      <title>搭建 Node 开发环境</title>
      <link>https://leijue222.github.io/tutorial/front-end/node-js/environment.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/node-js/environment.html</guid>
      <source url="https://leijue222.github.io/rss.xml">搭建 Node 开发环境</source>
      <description>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Hope 隆重向大家推荐 Node.js 集成开发环境: Visual Studio Code。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</description>
      <category>Node.js</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于 Node.js 需要编码、运行、调试，我们需要一个 IDE 集成开发环境，这样就可以大大提升开发效率。综合考察后，Mr.Hope 隆重向大家推荐 Node.js 集成开发环境: <strong>Visual Studio Code</strong>。它启动速度快，执行简单，调试方便这三点上。当然，免费使用是一个加分项。</p>
<!-- more -->
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>有关 VS Code 使用教程请<a href="/tutorial/software/vscode/" target="blank">访问这里</a></p>
</div>
<h2> 运行和调试 JavaScript</h2>
<p>在 VS Code 中，我们可以非常方便地运行 JavaScript 文件。</p>
<p>VS Code 以文件夹作为工程目录 (Workspace Dir)，所有的 JavaScript 文件都存放在该目录下。此外，VS Code 在工程目录下还需要一个 <code>.vscode</code> 的配置目录，里面存放里 VS Code 需要的配置文件。</p>
<p>假设我们在 <code>C:\Work\</code> 目录下创建了一个 hello 目录作为工程目录，并编写了一个 <code>hello.js</code> 文件，则该工程目录的结构如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以用 VS Code 快速创建 <code>launch.json</code>，然后修改如下:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了配置文件，即可使用 VS Code 调试 JavaScript。</p>
<h2> 视频演示</h2>
<ul>
<li><a href="https://www.bilibili.com/video/av5827351/" target="_blank" rel="noopener noreferrer">视频演示</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>安装 Node.js</title>
      <link>https://leijue222.github.io/tutorial/front-end/node-js/install.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/node-js/install.html</guid>
      <source url="https://leijue222.github.io/rss.xml">安装 Node.js</source>
      <description>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。</description>
      <category>Node.js</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于 Node.js 平台是在后端运行 JavaScript 代码，所以，必须首先在本机安装 Node.js 环境。</p>
<!-- more -->
<h2> 安装 Node.js</h2>
<p>目前 Node.js 的 LTS 版本是 18.15.0。首先，从 Node.js 官网下载对应平台的安装程序。点击<strong>长期维护版</strong>的下载按钮。</p>
<ul>
<li><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener noreferrer">Node.js 官网</a></li>
</ul>
<h3> 安装过程</h3>
<ul>
<li>
<p>在 Windows 上安装时务必选择全部组件，包括勾选 <code>Add to Path</code>。</p>
<p>在安装过程中，无需勾选 "Automatically install the necessary tools"。选中此项会在电脑中安装 VS 等日常开发使用不到的软件。</p>
<p>安装完成后，在 Windows 环境下，请打开命令提示符，然后输入 <code>node -v</code> ，如果安装正常，您应该看到 <code>v18.15.0</code> 这样的输出:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>继续在命令提示符输入 node，此刻您将进入 Node.js 的交互环境。在交互环境下，您可以输入任意 JavaScript 语句，例如 <code>100 + 200</code>，回车后将得到输出结果。</p>
<p>要退出 Node.js 环境，连按两次 <code>Ctrl + C</code> 。</p>
</li>
<li>
<p>在 Mac 或 Linux 环境下，请打开终端，然后输入 <code>node -v</code>，您应该看到如下输出:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h2> npm</h2>
<p>npm 是 Node.js 的包管理工具(package manager)。</p>
<p>我们在 Node.js 上开发时，会用到很多别人写的 JavaScript 代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生: 大家都把自己开发的模块打包后放到 npm 官网上，如果要使用，直接通过 npm 安装就可以直接用，不用管代码存在哪，应该从哪下载。</p>
<p>更重要的是，如果我们要使用模块 A，而模块 A 又依赖于模块 B，模块 B 又依赖于模块 X 和模块 Y，npm 可以根据依赖关系，把所有依赖的包都下载下来并管理起来。否则，靠我们自己手动管理，肯定既麻烦又容易出错。</p>
<p>讲了这么多，npm 究竟在哪?</p>
<p>其实 npm 已经在 Node.js 安装的时候顺带装好了。我们在命令提示符或者终端输入 <code>npm -v</code>，应该看到类似的输出:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>如果版本号太小，说明 npm 版本较低，请使用此命令升级到最新版本: <code>npm i -g npm</code>。</p>
</blockquote>
<p>如果直接输入 <code>npm</code>，您会看到类似下面的输出:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的一大堆文字告诉您，npm 需要附带命令。现在我们不用关心这些命令，后面会一一讲到。目前，您只需要确保 npm 正确安装了，能运行就行。</p>
<h2> 国内镜像站</h2>
<p>大家都知道天朝是有墙的，有的时候，访问国外的 Node.js 服务器可能会十分缓慢以至于您想把它砸了。</p>
<p>所以贴心的马云爸爸提供了淘宝镜像源。你可以将 npm 的源配置为国内镜像源，以在每次安装依赖的时候从国内镜像站拉取镜像。这可以极大的提升安装速度。</p>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p>如果官方源的速度还可以的话请尽可能使用官方源。</p>
<p>国内源毕竟是镜像站点，同步官方源的包会出现延迟，所以有时候你可能会遇到 <code>version xxx not found</code> 之类的错误，这是因为所需要的版本还没来得及被镜像站点同步所导致。</p>
<p>你可以通过访问 <code>npmmirror.com/sync/&lt;包名&gt;</code> 来手动同步一个包。</p>
</div>
<p>设置及国内源的命令如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container danger">
<p class="hint-container-title">警告</p>
<p><code>https://registry.npm.taobao.org/</code> 是老的淘宝源地址，现已停止维护，请不要使用!!!</p>
</div>
<h2> 启用 Corepack</h2>
<p>Node.js 自带的包管理工具 npm 并不是那么的强大，其安装速度也很慢，所以社区开发了一些其他的包管理工具如 <code>yarn</code> 和 <code>pnpm</code>，它们有自己的优势。</p>
<p>Mr.Hope 推荐使用 pnpm 进行包管理，因为它使用硬链接索引包文件，安装速度更快而且节省磁盘空间。</p>
<p>从 v16 开始，Node.js 引入了 Corepack 工具，并在 package.json 支持了 <code>packageManager</code> 选项以支持第三方管理工具。</p>
<p>你需要通过下方命令启用 Corepack:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样每个项目会自动应用根目录 package.json 中的 <code>packageManager</code> 选项。比如设置 <code>"packageManager": "pnpm@7.30.3"</code> 的时候，会自动下载并使用 <code>pnpm@7.30.3</code>。</p>
<div class="hint-container info">
<p class="hint-container-title">设置全局的 packageManager</p>
<p>你可以使用 <code>corepack prepare packageManager@semver</code> 来全局准备一个 packageManager 版本，并使用 <code>--activate</code> 选新娘 全局激活。</p>
<p>比如以下命令下载 <code>pnpm@7.30.3</code> 并将其作为默认的全局包管理器:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></div>
<h2> 小结</h2>
<p>请在本机安装 Node.js 环境，并确保 Node.js 和 npm 能正常运行。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js</title>
      <link>https://leijue222.github.io/tutorial/front-end/node-js/intro.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/node-js/intro.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Node.js</source>
      <description>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。 Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。</description>
      <category>Node.js</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>从本章开始，我们就正式开启 JavaScript 的后端开发之旅。</p>
<p>Node.js 是目前非常火热的技术，但是它的诞生经历却很奇特。</p>
<!-- more -->
<p>众所周知，在 Netscape 设计出 JavaScript 后的短短几个月，JavaScript 事实上已经是前端开发的唯一标准。</p>
<p>后来，微软通过 IE 击败了 Netscape 后一统桌面，结果几年时间，浏览器毫无进步。(2001 年推出的古老的 IE 6 到今天仍然有人在使用! )</p>
<p>没有竞争就没有发展。微软认为 IE6 浏览器已经非常完善，几乎没有可改进之处，然后解散了 IE6 开发团队! 而 Google 却认为支持现代 Web 应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行 JavaScript 的引擎性能还可提升 10 倍。</p>
<p>先是 Mozilla 借助已壮烈牺牲的 Netscape 遗产在 2002 年推出了 Firefox 浏览器，紧接着 Apple 于 2003 年在开源的 KHTML 浏览器的基础上推出了 WebKit 内核的 Safari 浏览器，不过仅限于 Mac 平台。</p>
<p>随后，Google 也开始创建自家的浏览器。他们也看中了 WebKit 内核，于是基于 WebKit 内核推出了 Chrome 浏览器。</p>
<p>Chrome 浏览器是跨 Windows 和 Mac 平台的，并且，Google 认为要运行现代 Web 应用，浏览器必须有一个性能非常强劲的 JavaScript 引擎，于是 Google 自己开发了一个高性能 JavaScript 引擎，名字叫 V8，以 BSD 许可证开源。</p>
<p>现代浏览器大战让微软的 IE 浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队! 回过头再追赶却发现，支持 HTML5 的 WebKit 已经成为手机端的标准了，IE 浏览器从此与主流移动端设备绝缘。</p>
<h2> 浏览器大战和 Node.js 的关系</h2>
<p>话说有个叫 Ryan Dahl 的歪果仁，他的工作是用 C/C++写高性能 Web 服务。对于高性能，异步 IO、事件驱动是基本原则，但是用 C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发 Web 服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步 IO 和异步 IO，但是开发人员一旦用了同步 IO，他们就再也懒得写异步 IO 了，所以，最终，Ryan 瞄向了 JavaScript。</p>
<p>因为 JavaScript 是单线程执行，根本不能进行同步 IO 操作，所以，JavaScript 的这一“缺陷”导致了它只能使用异步 IO。</p>
<p>选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为 V8 就是开源的 JavaScript 引擎。让 Google 投资去优化 V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。</p>
<p>于是在 2009 年，Ryan 正式推出了基于 JavaScript 语言和 V8 引擎的开源 Web 服务器项目，命名为 Node.js。虽然名字很土，但是，Node.js 第一次把 JavaScript 带入到后端服务器开发，加上世界上已经有无数的 JavaScript 开发人员，所以 Node.js 一下子就火了起来。</p>
<h2> 在 Node.js 上运行的 JavaScript 相比其他后端开发语言的优势</h2>
<p>最大的优势是借助 JavaScript 天生的事件驱动机制加 V8 高性能引擎，使编写高性能 Web 服务轻而易举。</p>
<p>其次，JavaScript 语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉 JavaScript 就是个“玩具语言”。但是，在 Node.js 环境下，通过模块化的 JavaScript 代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的 ECMAScript 6 标准，可以完全满足工程上的需求。</p>
<blockquote>
<p>我还听说过 io.js，这又是什么鬼?</p>
</blockquote>
<p>因为 Node.js 是开源项目，虽然由社区推动，但幕后一直由 Joyent 公司资助。由于一群开发者对 Joyent 公司的策略不满，于 2014 年从 Node.js 项目 fork 出了 io.js 项目，决定单独发展，但两者实际上是兼容的。</p>
<p>然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent 公司表示要和解，于是，io.js 项目又决定回归 Node.js。</p>
<p>具体做法是将来 io.js 将首先添加新的特性，如果大家测试用得爽，就把新特性加入 Node.js。Io.js 是“尝鲜版”，而 Node.js 是线上稳定版，相当于 Fedora Linux 和 RHEL 的关系。</p>
<p>本章教程的所有代码都在 Node.js 上调试通过。如果您要尝试 io.js 也是可以的，不过两者如果遇到一些区别请自行查看 io.js 的文档。</p>
<h2> Node.js 相关链接</h2>
<ul>
<li>
<p><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener noreferrer">Node.js 官网</a></p>
</li>
<li>
<p><a href="https://nodejs.org/zh-cn/docs/" target="_blank" rel="noopener noreferrer">Node.js 最新文档</a></p>
</li>
<li>
<p><a href="https://nodejs.org/dist/latest-v16.x/docs/api/" target="_blank" rel="noopener noreferrer">Node.js 最新 API 文档</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>第一个 Node 程序</title>
      <link>https://leijue222.github.io/tutorial/front-end/node-js/program.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/node-js/program.html</guid>
      <source url="https://leijue222.github.io/rss.xml">第一个 Node 程序</source>
      <description>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。 从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。</description>
      <category>Node.js</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>在前面的所有章节中，我们编写的 JavaScript 代码都是在浏览器中运行的，因此，我们可以直接在浏览器中敲代码，然后直接运行。</p>
<p>从本章开始，我们编写的 JavaScript 代码将不能在浏览器环境中执行了，而是在 Node.js 环境中执行，因此，JavaScript 代码将直接在您的计算机上以命令行的方式运行，所以，我们要先选择一个文本编辑器来编写 JavaScript 代码，并且把它保存到本地硬盘的某个目录，才能够执行。</p>
<!-- more -->
<p>那么问题来了: 文本编辑器到底哪家强?</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<ul>
<li>具体详情请见 <a href="/tutorial/front-end/windows/notepad.html" target="blank">记事本遗留问题</a></li>
</ul>
</div>
<p>如果您的电脑上已经安装了<strong>Sublime Text</strong>，或者<strong>Notepad++</strong>，也可以用来编写 JavaScript 代码，注意用 UTF-8 格式保存。</p>
<p>最方便的，当然是 Mr.Hope 强力安利的 VS Code 了。</p>
<p>输入以下代码:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第一行总是写上 <code>'use strict';</code> 是因为我们总是以严格模式运行 JavaScript 代码，避免各种潜在陷阱。</p>
<p>然后，选择一个目录，例如 <code>C:\Workspace</code>，把文件保存为 <code>hello.js</code>，就可以打开命令行窗口，把当前目录切换到 hello.js 所在目录，然后输入以下命令运行这个程序了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以保存为别的名字，比如 <code>first.js</code>，但是必须要以 <code>.js</code> 结尾。此外，文件名只能是英文字母、数字和下划线的组合。</p>
<p>如果当前目录下没有 <code>hello.js</code> 这个文件，运行 <code>node hello.js</code> 就会报错:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>报错的意思就是，没有找到 <code>hello.js</code> 这个文件，因为文件不存在。这个时候，就要检查一下当前目录下是否有这个文件了。</p>
<h2> 命令行模式和 Node.js 交互模式</h2>
<p>请注意区分命令行模式和 Node.js 交互模式。</p>
<p>看到类似 <code>C:\&gt;</code> 是在 Windows 提供的命令行模式:</p>
<p></p>
<p>在命令行模式下，可以执行 Node.js 进入 Node.js 交互式环境，也可以执行 Node.js <code>hello.js</code> 运行一个 <code>.js</code> 文件。</p>
<p>看到<code>&gt;</code> 是在 Node.js 交互式环境下:</p>
<p></p>
<p>在 Node.js 交互式环境下，我们可以输入 JavaScript 代码并立刻执行。</p>
<p>此外，在命令行模式运行.js 文件和在 Node.js 交互式环境下直接运行 JavaScript 代码有所不同。Node.js 交互式环境会把每一行 JavaScript 代码的结果自动打印出来，但是，直接运行 JavaScript 文件却不会。</p>
<p>例如，在 Node.js 交互式环境下，输入:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>直接可以看到结果 600。</p>
<p>但是，写一个 <code>calc.js</code> 的文件，内容如下:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后在命令行模式下执行:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>发现什么输出都没有。</p>
<p>这是正常的。想要输出结果，必须自己用 <code>console.log()</code> 打印出来。把 <code>calc.js</code> 改造一下:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再执行，就可以看到结果:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 使用严格模式</h2>
<p>如果在 JavaScript 文件开头写上 <code>'use strict';</code>，那么 Node.js 在执行该 JavaScript 时将使用严格模式。但是，在服务器环境下，如果有很多 JavaScript 文件，每个文件都写上 <code>'use strict';</code> 很麻烦。我们可以给 Node.js 传递一个参数，让 Node.js 直接为所有 js 文件开启严格模式:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>后续代码，如无特殊说明，我们都会直接给 Node.js 传递 <code>--use_strict</code> 参数来开启严格模式。</p>
<h2> 小结</h2>
<p>用文本编辑器写 JavaScript 程序，然后保存为后缀为 <code>.js</code> 的文件，就可以用 Node.js 直接运行这个程序了。</p>
<p>Node.js 的交互模式和直接运行 <code>.js</code> 文件有什么区别呢?</p>
<p>直接输入 Node.js 进入交互模式，相当于启动了 Node.js 解释器，但是等待您一行一行地输入源代码，每输入一行就执行一行。</p>
<p>直接运行 <code>node hello.js</code> 文件相当于启动了 Node.js 解释器，然后一次性把 <code>hello.js</code> 文件的源代码给执行了，您是没有机会以交互的方式输入源代码的。</p>
<p>在编写 JavaScript 代码的时候，完全可以一边在文本编辑器里写代码，一边开一个 Node.js 交互式命令窗口，在写代码的过程中，把部分代码粘到命令行去验证，事半功倍! 前提是得有个 27 寸的超大显示器!</p>
]]></content:encoded>
    </item>
    <item>
      <title>React</title>
      <link>https://leijue222.github.io/tutorial/front-end/react/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/react/</guid>
      <source url="https://leijue222.github.io/rss.xml">React</source>
      <description>创建 React 项目 使用 create-react-app 工具。 创建普通模板: 创建 TS 模板: React 文档 官方文档 (https://reactjs.org/docs/getting-started.html); 中文文档 (https://react.docschina.org/docs/getting-started.html);</description>
      <category>前端</category>
      <pubDate>Fri, 08 May 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 创建 React 项目</h2>
<p>使用 <code>create-react-app</code> 工具。</p>
<p>创建普通模板:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建 TS 模板:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> React 文档</h2>
<ul>
<li><a href="https://reactjs.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">官方文档</a></li>
<li><a href="https://react.docschina.org/docs/getting-started.html" target="_blank" rel="noopener noreferrer">中文文档</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Vue.js</title>
      <link>https://leijue222.github.io/tutorial/front-end/vue/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/vue/</guid>
      <source url="https://leijue222.github.io/rss.xml">Vue.js</source>
      <description>简介 Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。 渐进式框架 Vue 是一个框架，也是一个生态。其功能覆盖了大部分前端...</description>
      <category>Vue</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>Vue (发音为 /vjuː/，类似 view) 是一款用于构建用户界面的 JavaScript 框架。它基于标准 HTML、CSS 和 JavaScript 构建，并提供了一套声明式的、组件化的编程模型，帮助你高效地开发用户界面。无论是简单还是复杂的界面，Vue 都可以胜任。</p>
<h2> 渐进式框架</h2>
<p>Vue 是一个框架，也是一个生态。其功能覆盖了大部分前端开发常见的需求。但 Web 世界是十分多样化的，不同的开发者在 Web 上构建的东西可能在形式和规模上会有很大的不同。考虑到这一点，Vue 的设计非常注重灵活性和“可以被逐步集成”这个特点。根据你的需求场景，你可以用不同的方式使用 Vue：</p>
<ul>
<li>无需构建步骤，渐进式增强静态的 HTML</li>
<li>在任何页面中作为 Web Components 嵌入</li>
<li>单页应用 (SPA)</li>
<li>全栈 / 服务端渲染 (SSR)</li>
<li>Jamstack / 静态站点生成 (SSG)</li>
<li>开发桌面端、移动端、WebGL，甚至是命令行终端中的界面</li>
</ul>
<h2> 官方文档</h2>
<ul>
<li>
<p><a href="https://cn.vuejs.org/guide/introduction.html" target="_blank" rel="noopener noreferrer">Vue.js 介绍</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/api/" target="_blank" rel="noopener noreferrer">Vue.js API</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://router.vuejs.org/zh/guide/#html" target="_blank" rel="noopener noreferrer">Vue Router 介绍</a></p>
</li>
<li>
<p><a href="https://router.vuejs.org/zh/api/" target="_blank" rel="noopener noreferrer">Vue Router API</a></p>
</li>
</ul>
<hr>
<ul>
<li>
<p><a href="https://v2.vuepress.vuejs.org/zh/" target="_blank" rel="noopener noreferrer">VuePress</a></p>
</li>
<li>
<p><a href="https://theme-hope.vuejs.press/zh/" target="_blank" rel="noopener noreferrer">VuePress Theme Hope</a></p>
</li>
</ul>
<h2> Vue.js 教程目录</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/vue/core/install.html" target="blank">开发环境安装</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/vue/core/get-started.html" target="blank">起步上手</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/vue/core/app.html" target="blank">创建 Vue 应用</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/vue/core/template.html" target="blank">模板语法</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/vue/core/sfc.html" target="blank">Vue 单文件组件说明</a></p>
</li>
</ul>
<h2> Vue 生态</h2>
<h3> Vue Router</h3>
<ul>
<li><a href="/tutorial/front-end/vue/router/" target="blank">Vue Router 概述</a></li>
</ul>
<!-- TODO: Add pinia and vite -->
<h3> 其他 Vue 生态</h3>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/basic/vuepress/" target="_blank" rel="noopener noreferrer">VuePress</a>: 静态站点生成器；</li>
<li><a href="https://vue.ant.design/docs/vue/introduce-cn/" target="_blank" rel="noopener noreferrer">Ant Design Vue</a>: 阿里的一套 UI 组件库；</li>
<li><a href="https://bootstrap-vue.js.org/" target="_blank" rel="noopener noreferrer">BootstrapVue</a></li>
</ul>
<h2> 其他文档</h2>
<ul>
<li><a href="/tutorial/front-end/vue/compare.html" target="blank">Vue 与小程序的异同</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 与小程序的异同</title>
      <link>https://leijue222.github.io/tutorial/front-end/vue/compare.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/vue/compare.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Vue 与小程序的异同</source>
      <description>优缺点比较 优点 缺点 ------ --------------------------------------------------------------------------------------------------------------------------------------------------------------...</description>
      <category>Vue</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<!-- more -->
<h2> 优缺点比较</h2>
<table>
<thead>
<tr>
<th></th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>小程序</td>
<td>小程序底层由微信框架驱动，每个界面是单独的 JS 文件，页面切换以及全局生命周期丰富完善。小程序具有相当完备的 API。</td>
<td>小程序是由 JSCore 驱动逻辑层，视图层采用 Webview，故没有 DOM 节点的概念，只有渲染出的虚拟节点，所以无法动态删除或添加节点，无法使用一切 DOM 相关 API。小程序组件生命周期不够强大。小程序的 Webview 渲染存在一定的性能问题。小程序视图层与逻辑层通过 Jsbridge 连接，数据传输及渲染有延时。</td>
</tr>
<tr>
<td>vue</td>
<td>Vue 的实质是动态监测并托管 DOM 节点。由于 Vue 是网页开发，拥有 DOM 树，可以使用 DOM 相关 API。Vue 组件拥有更全面的生命周期，同时可以动态渲染组件。Vue 的组件传递数据方式默认为单向绑定</td>
<td>由于 Vue 的组件本质是监测 DOM 树，故其组件只能有一个根节点。同时 Vue 的界面路由依赖于 History API，其界面切换周期与逻辑不够强大。</td>
</tr>
</tbody>
</table>
<h2> 代码区别</h2>
<p>小程序与 Vue 在代码写法上极其相似，但稍有不同。</p>
<h3> 数据绑定</h3>
<h4> 小程序数据绑定</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div v-pre="">
<p>小程序在所有内容上都使用 Muscle 语法 (<code>{{Javascript表达式}}</code>) 的写法。</p>
</div>
<h4> Vue 数据绑定</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>Vue 在标签名属性用 <code>v-bind:prop="Javascript表达式"</code> 的写法、其简写为 <code>:prop=""</code>，在标签内容处使用 Muscle 语法。</p>
</div>
<h3> 条件渲染</h3>
<h4> 小程序条件渲染</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>更多详情请见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/conditional.html" target="_blank" rel="noopener noreferrer">小程序条件渲染文档</a></p>
</div>
<h4> Vue 条件渲染</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>更多相关请见 <a href="https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">Vue 条件渲染文档</a></p>
</div>
<h3> 循环渲染</h3>
<h4> 小程序循环渲染</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际渲染结果为:</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>更多详情请见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/list.html" target="_blank" rel="noopener noreferrer">小程序循环渲染文档</a></p>
</div>
<h4> Vue 循环渲染</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>更多相关请见 <a href="https://cn.vuejs.org/v2/guide/#%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener noreferrer">Vue 循环渲染文档</a></p>
</div>
<h2> 生命周期</h2>
<h3> 页面生命周期</h3>
<h4> 小程序生命周期</h4>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" alt="小程序页面生命周期" loading="lazy"></p>
<h4> Vue 页面生命周期</h4>
<p><a href="https://router.vuejs.org/guide/advanced/navigation-guards.html" target="_blank" rel="noopener noreferrer">Vue 页面生命周期</a></p>
<h3> 组件生命周期</h3>
<h4> 小程序组件生命周期</h4>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/lifetimes.html" target="_blank" rel="noopener noreferrer">小程序组件生命周期</a></p>
<h4> Vue 组件生命周期</h4>
<p><a href="https://cn.vuejs.org/guide/essentials/lifecycle.html" target="_blank" rel="noopener noreferrer">Vue 组件生命周期</a></p>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/page-lifecycle.2e646c86.png" type="image/png"/>
    </item>
    <item>
      <title>网页入门</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/</guid>
      <source url="https://leijue222.github.io/rss.xml">网页入门</source>
      <description>网页需要三件套: HTML、CSS 和 JavaScript。 HTML 定义了网页的内容 CSS 描述了网页的样式 JavaScript 编写网页的行为</description>
      <category>前端</category>
      <pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>网页需要三件套: <strong>HTML</strong>、<strong>CSS</strong> 和 <strong>JavaScript</strong>。</p>
<ol>
<li>HTML 定义了网页的内容</li>
<li>CSS 描述了网页的样式</li>
<li>JavaScript 编写网页的行为</li>
</ol>
<!-- more -->
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>一个大型的网站，很少是直接使用原生代码写的。</p>
<p>最新的网站大多数都是用知名框架 (<a href="#angular"><strong>Angular</strong></a>、<a href="#react"><strong>React</strong></a>、<a href="#vue"><strong>Vue</strong></a>) 搭建，并引入 npm 上的 UI 库编写而成。</p>
<p>稍微老的网站会使用其他框架作为辅助，比如 <a href="#bootstrap4"><strong>Bootstrap</strong></a>、<a href="#jquery"><strong>jQuery</strong></a> 等。</p>
</div>
<div class="hint-container info">
<p class="hint-container-title">网页标准指定</p>
<p>互联网网页标准由 W3C 组织制定，它的全称是万维网联盟组织。</p>
</div>
<h2> HTML</h2>
<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，描述了网页的骨架(具体结构)。</p>
<ul>
<li><a href="/tutorial/front-end/website/html/" target="blank">HTML 教程</a></li>
</ul>
<h2> CSS</h2>
<p>CSS 指层叠样式表 (Cascading Style Sheets)，声明了网页的样式(具体布局)。</p>
<ul>
<li><a href="/tutorial/front-end/website/css/" target="blank">CSS 教程</a></li>
</ul>
<h2> Emmet</h2>
<p>Emmet 是一种快速输入 HTML 和 CSS 的语法。</p>
<ul>
<li><a href="/tutorial/front-end/website/emmet/" target="blank">Emmet 用法介绍</a></li>
</ul>
<h2> JavaScript</h2>
<p>JavaScript 是一种编程语言，声明了网页的交互逻辑。</p>
<p>JavaScript 是一种轻量级的编程语言，为可插入 HTML 页面的编程代码。所有现代的 HTML 页面都使用 JavaScript。</p>
<ul>
<li><a href="/tutorial/front-end/website/js.html" target="blank">JS 教程</a></li>
</ul>
<h3> TypeScript</h3>
<p>TypeScript 是 JavaScript 的一个超集，使得 JS 变成了一种强定义语言。TypeScript 由于其诸多优良特性，目前在前端的份额越来越大。</p>
<ul>
<li><a href="/tutorial/front-end/language/typescript/" target="blank">TypeScript 教程</a></li>
</ul>
<h2> Node.js</h2>
<p>在深入了解并进行前端开发后，就避不开 Node。</p>
<p>Node.js 是一款全球使用广泛的框架，可以用在前端与后端上，拥有大量的模块。Node.js 主要以其丰富并及其容易导入的 Node.js package，以及其方便管理 npm (Node.js Package Manager)闻名。</p>
<ul>
<li><a href="/tutorial/front-end/node-js/" target="blank">Node.js 教程</a></li>
</ul>
<h2> 现代前端框架</h2>
<h3> Vue</h3>
<p>Vue 是一套轻量化的前端渐进式框架框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。</p>
<ul>
<li>
<p><a href="/tutorial/front-end/vue/" target="blank">Vue 学习教程</a></p>
</li>
<li>
<p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener noreferrer">Vue 官方文档</a></p>
</li>
</ul>
<h3> React</h3>
<ul>
<li><a href="/tutorial/front-end/react/" target="blank">React 教程</a></li>
</ul>
<h3> Angular</h3>
<ul>
<li><a href="/tutorial/front-end/angular/" target="blank">Angular 教程</a></li>
</ul>
<h2> 历史前端框架</h2>
<h3> jQuery</h3>
<p>jQuery 是一个 JavaScript 库，极大地简化了 JavaScript 编程，很容易学习。</p>
<p>jQuery 的优势在于它能够在互联网发展早期兼容各式各样的浏览器，并轻松的选定与操作 DOM。</p>
<p>由于 MVVM 的兴起，目前 jQuery 已逐步被前端三大框架所取代。</p>
<ul>
<li>
<p><a href="/tutorial/front-end/website/jQuery/" target="blank">jQuery 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/jquery/index.asp" target="_blank" rel="noopener noreferrer">W3School</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/jquery/jquery-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3> Bootstrap4</h3>
<p>Bootstrap 是全球最受欢迎的前端组件库，用于开发响应式布局、移动设备优先的 WEB 项目。</p>
<p>Bootstrap 是一套用于 HTML、CSS 和 JS 开发的开源工具集。利用提供的 Sass 变量和大量 mixin、响应式栅格系统、可扩展的预制组件、基于 jQuery 的强大的插件系统，能够快速为您的想法开发出原型或者构建整个 app 。</p>
<ul>
<li>
<p><a href="https://getbootstrap.com/docs/4.1/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 官方文档</a></p>
</li>
<li>
<p><a href="https://v4.bootcss.com/docs/4.0/getting-started/introduction/" target="_blank" rel="noopener noreferrer">bootstrap 4.0 中文文档</a></p>
</li>
</ul>
<h2> 定义列表</h2>
<ul>
<li><a href="/tutorial/front-end/website/definition/uri.html" target="blank">URI 统一资源标识符</a></li>
<li><a href="/tutorial/front-end/website/definition/url.html" target="blank">URL 统一资源定位符</a></li>
<li><a href="/tutorial/front-end/website/definition/seo.html" target="blank">SEO 搜索引擎优化</a></li>
<li><a href="/tutorial/front-end/website/definition/mime.html" target="blank">MIME Type 媒体类型</a></li>
<li><a href="/tutorial/front-end/website/definition/https.html" target="blank">HTTPS 介绍</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>JavaScript 教程</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/js.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/js.html</guid>
      <source url="https://leijue222.github.io/rss.xml">JavaScript 教程</source>
      <description>初学者教程 快速上手 (../language/js/guide/README.md); JavaScript 手册 JavaScript 学习教程 (../language/js/README.md); 在线教程 MDN 教程 (https://developer.mozilla.org/zh-CN/docs/Web/JavaScript); W3S...</description>
      <category>JavaScript</category>
      <pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 初学者教程</h2>
<ul>
<li><a href="/tutorial/front-end/language/js/guide/" target="blank">快速上手</a></li>
</ul>
<h3> JavaScript 手册</h3>
<ul>
<li><a href="/tutorial/front-end/language/js/" target="blank">JavaScript 学习教程</a></li>
</ul>
<h3> 在线教程</h3>
<ul>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">MDN 教程</a></p>
</li>
<li>
<p><a href="http://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></p>
</li>
<li>
<p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></p>
</li>
</ul>
<h3> ES6</h3>
<p>ES6 是 JavaScript 的 2015 标注，现已基本被广泛使用和支持；</p>
<ul>
<li><a href="/tutorial/front-end/language/js/es6/" target="blank">ES6 教程</a></li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>此教程由阮一峰老师书写(<strong>真·大佬</strong>)，建议深刻理解 JavaScript 原理(大概一年左右)之后再看。</p>
</div>
<blockquote>
<p>开始下一章学习前，您需要跳转到 <a href="/tutorial/front-end/language/js/guide/" target="blank">JS 快速入门章节</a> 了解 JavaScript，或 <a href="/tutorial/front-end/language/js/" target="blank">深入学习 JavaScript</a> 后，方能进入 jQuery 学习。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>Git</title>
      <link>https://leijue222.github.io/tutorial/ops/git/</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/</guid>
      <source url="https://leijue222.github.io/rss.xml">Git</source>
      <description>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。 交互式学习 如果您觉得本文太枯燥，这里有一个 交互式的分支演示与学习网站。您可以在这里领略 Git 的魅力。 但 Mr.Hope 仍建议您操作完再系统的学习并阅读以下内容。</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。在开发中分布式文件管理系统，可以便于多人协作开发。</p>
<div class="hint-container info">
<p class="hint-container-title">交互式学习</p>
<p>如果您觉得本文太枯燥，这里有一个 <a href="http://learngitbranching.js.org/" target="_blank" rel="noopener noreferrer">交互式的分支演示与学习网站</a>。您可以在这里领略 Git 的魅力。</p>
<p>但 Mr.Hope 仍建议您操作完再系统的学习并阅读以下内容。</p>
</div>
<!-- more -->
<h2> Git 安装</h2>
<ul>
<li><a href="/tutorial/ops/git/install.html" target="blank">安装教程</a></li>
</ul>
<h2> Git 教程</h2>
<ul>
<li>
<p><a href="/tutorial/ops/git/intro.html" target="blank">Git 介绍</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/create-repo.html" target="blank">创建版本库</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/status.html" target="blank">纵向查看</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/recall.html" target="blank">撤销操作</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/reset.html" target="blank">版本回退</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/working-directory.html" target="blank">工作区和暂存区</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/change.html" target="blank">修改管理</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/remote.html" target="blank">远程仓库</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/branch.html" target="blank">分支管理</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/tag.html" target="blank">标签管理</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/ignore.html" target="blank">忽略特殊文件</a></p>
</li>
</ul>
<h2> 深入 Git</h2>
<ul>
<li>
<p><a href="/tutorial/ops/git/working.html" target="blank">Git 原理</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/custom.html" target="blank">自定义 Git</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/gitLFS.html" target="blank">大文件管理存储</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/server.html" target="blank">搭建 Git 服务器</a></p>
</li>
<li>
<p><a href="/tutorial/ops/git/merge.html" target="blank">高级合并</a></p>
</li>
</ul>
<h2> 扩展阅读</h2>
<ul>
<li>
<p><a href="https://git-scm.com/doc" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
<li>
<p><a href="https://mrhope.site/file/git/gitCheatSheet.pdf" target="_blank" rel="noopener noreferrer">Git-cheatSheet</a> (PDF)</p>
</li>
<li>
<p><a href="https://mrhope.site/file/git/progit_v2.1.45.pdf" target="_blank" rel="noopener noreferrer">Pro Git</a> (PDF)</p>
</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">TODO</p>
<ol>
<li>完善分支合并部分，加入更多命令介绍。如 <code>cherry-pick</code> <code>squash-merge</code>。</li>
<li>介绍 Git Hook</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>分支管理</title>
      <link>https://leijue222.github.io/tutorial/ops/git/branch.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/branch.html</guid>
      <source url="https://leijue222.github.io/rss.xml">分支管理</source>
      <description>概述 分支就是科幻电影里面的平行宇宙，当您正在电脑前努力学习 Git 的时候，另一个您正在另一个平行宇宙里努力学习 SVN。 如果两个平行宇宙互不干扰，那对现在的您也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，您既学会了 Git 又学会了 SVN! Learn branches 分支在实际中有什么用呢? 假设您准备开发一个新功能，但是需要两...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 概述</h2>
<p>分支就是科幻电影里面的平行宇宙，当您正在电脑前努力学习 Git 的时候，另一个您正在另一个平行宇宙里努力学习 SVN。</p>
<p>如果两个平行宇宙互不干扰，那对现在的您也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，您既学会了 Git 又学会了 SVN!</p>
<p></p>
<p>分支在实际中有什么用呢? 假设您准备开发一个新功能，但是需要两周才能完成，第一周您写了 50% 的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。您创建了一个属于您自己的分支，别人看不到，还继续在原来的分支上正常工作，而您在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如 SVN 等都有分支管理，但是用过之后您会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但 Git 的分支是与众不同的，无论创建、切换和删除分支，Git 在 1 秒钟之内就能完成! 无论您的版本库是 1 个文件还是 1 万个文件。</p>
<h2> 创建与合并分支</h2>
<p>在版本回退里，您已经知道，每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在 Git 里，这个分支叫主分支，即 <code>master</code> 分支。<code>HEAD</code> 严格来说不是指向提交，而是指向 <code>master</code>，<code>master</code> 才是指向提交的，所以，<code>HEAD</code> 指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code> 分支是一条线，Git 用 <code>master</code> 指向最新的提交，再用 <code>HEAD</code> 指向 <code>master</code>，就能确定当前分支，以及当前分支的提交点:</p>
<p></p>
<p>每次提交，<code>master</code> 分支都会向前移动一步，这样，随着您不断提交，<code>master</code> 分支的线也越来越长:</p>
<p>当我们创建新的分支，例如 dev 时，Git 新建了一个指针叫 <code>dev</code>，指向 <code>master</code> 相同的提交，再把 <code>HEAD</code> 指向 <code>dev</code>，就表示当前分支在 dev 上:</p>
<p></p>
<p>您看，Git 创建一个分支很快，因为除了增加一个 <code>dev</code> 指针，改改 <code>HEAD</code> 的指向，工作区的文件都没有任何变化!</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对 dev 分支了，比如新提交一次后，<code>dev</code> 指针往前移动一步，而 <code>master</code> 指针不变:</p>
<p></p>
<p>假如我们在 dev 上的工作完成了，就可以把 dev 合并到 master 上。Git 怎么合并呢? 最简单的方法，就是直接把 master 指向 dev 的当前提交，就完成了合并:</p>
<p></p>
<p>所以 Git 合并分支也很快! 就改改指针，工作区内容也不变!</p>
<p>合并完分支后，甚至可以删除 dev 分支。删除 dev 分支就是把 dev 指针给删掉，删掉后，我们就剩下了一条 master 分支:</p>
<p></p>
<p>下面开始实战。首先，我们创建 dev 分支，然后切换到 dev 分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git checkout</code> 命令加上 <code>-b</code> 参数表示创建并切换，相当于以下两条命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，用 <code>git branch</code> 命令查看当前分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git branch</code> 命令会列出所有分支，当前分支前面会标一个 <code>*</code> 号。</p>
<p>然后，我们就可以在 dev 分支上正常提交，比如对 <code>readme.txt</code> 做个修改，加上一行:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，dev 分支的工作完成，我们就可以切换回 master 分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>切换回 master 分支后，再查看一个 <code>readme.txt</code> 文件，刚才添加的内容不见了! 因为那个提交是在 dev 分支上，而 master 分支此刻的提交点并没有变:</p>
<p></p>
<p>现在，我们把 dev 分支的工作成果合并到 master 分支上:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git merge</code> 命令用于合并指定分支到当前分支。合并后，再查看 readme.txt 的内容，就可以看到，和 dev 分支的最新提交是完全一样的。</p>
<p>注意到上面的 <code>Fast-forward</code> 信息，Git 告诉我们，这次合并是 “快进模式”，也就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。当然，也不是每次合并都能 <code>Fast-forward</code>。合并完成后，就可以放心地删除 dev 分支了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>删除后，查看 <code>branch</code>，就只剩下 <code>master</code> 分支了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因为创建、合并和删除分支非常快，所以 Git 鼓励您使用分支完成某个任务，合并后再删掉分支，这和直接在 <code>master</code> 分支上工作效果是一样的，但过程更安全。</p>
<h3> 分支小结</h3>
<ul>
<li>
<p>查看分支: <code>git branch</code></p>
</li>
<li>
<p>创建分支: <code>git branch &lt;name&gt;</code></p>
</li>
<li>
<p>切换分支: <code>git checkout &lt;name&gt;</code></p>
</li>
<li>
<p>创建+切换分支: <code>git checkout -b &lt;name&gt;</code></p>
</li>
<li>
<p>合并某分支到当前分支: <code>git merge &lt;name&gt;</code></p>
</li>
<li>
<p>删除分支: <code>git branch -d &lt;name&gt;</code></p>
</li>
</ul>
<hr>
<h2> 冲突</h2>
<p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的 <code>feature1</code> 分支，继续我们的新分支开发:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改 readme.txt 最后一行，改为:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 <code>feature1</code> 分支上提交:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>切换到 <code>master</code> 分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Git 还会自动提示我们当前 <code>master</code> 分支比远程的 <code>master</code> 分支要超前 1 个提交。</p>
<p>在 <code>master</code> 分支上把 readme.txt 文件的最后一行改为:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支各自都分别有新的提交，变成了这样:</p>
<p></p>
<p>这种情况下，Git 无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>果然冲突了! Git 告诉我们，<code>readme.txt</code> 文件存在冲突，必须手动解决冲突后再提交。<code>git status</code> 也可以告诉我们冲突的文件:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以直接查看 readme.txt 的内容:</p>
<div class="language-diff line-numbers-mode" data-ext="diff"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Git 用 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> 标记出不同分支的内容，我们修改如下后保存:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，<code>master</code> 分支和 <code>feature1</code> 分支变成了下图所示:</p>
<p></p>
<p>用带参数的 <code>git log</code> 也可以看到分支的合并情况:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，删除 feature1 分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 冲突小结</h3>
<ul>
<li>
<p>当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。</p>
</li>
<li>
<p>用 <code>git log --graph</code> 命令可以看到分支合并图。</p>
</li>
</ul>
<h2> 分支管理策略</h2>
<p>通常，合并分支时，如果可能，Git 会用 <code>Fast forward</code> 模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用 <code>Fast forward</code> 模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。</p>
<p>实战一下 <code>--no-ff</code> 方式的 <code>git merge</code>。首先，仍然创建并切换 <code>dev</code> 分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>修改 readme.txt 文件，并提交一个新的 <code>commit</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们切换回 <code>master</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>准备合并 <code>dev</code> 分支，请注意 <code>--no-ff</code> 参数，表示禁用 <code>Fast forward</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为本次合并要创建一个新的 <code>commit</code>，所以加上 <code>-m</code> 参数，把 <code>commit</code> 描述写进去。</p>
<p>合并后，我们用 <code>git log</code> 看看分支历史:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，不使用 <code>Fast forward</code> 模式，<code>merge</code> 后就像这样:</p>
<p></p>
<h3> 分支管理惯例</h3>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理:</p>
<p>首先，<code>master</code> 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢? 干活都在 <code>dev</code> 分支上，也就是说，<code>dev</code> 分支是不稳定的，到某个时候，比如 <code>1.0</code> 版本发布时，再把 <code>dev</code> 分支合并到 <code>master</code> 上，在 <code>master</code> 分支发布 <code>1.0</code> 版本；</p>
<p>您和您的小伙伴们每个人都在 <code>dev</code> 分支上干活，每个人都有自己的分支，时不时地往 <code>dev</code> 分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样:</p>
<h3> 分支管理小结</h3>
<ul>
<li>
<p>Git 分支十分强大，在团队开发中应该充分应用。</p>
</li>
<li>
<p>合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 <code>fast forward</code> 合并就看不出来曾经做过合并。</p>
</li>
</ul>
<hr>
<h2> Bug 分支</h2>
<p>软件开发中，bug 就像家常便饭一样。有了 bug 就需要修复，在 Git 中，由于分支是如此的强大，所以，每个 bug 都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当您接到一个修复一个代号 101 的 bug 的任务时，很自然地，您想创建一个分支 <code>issue-101</code> 来修复它，但是，等等，当前正在 dev 上进行的工作还没有提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并不是您不想提交，而是工作只进行到一半，还没法提交，预计完成还需 1 天时间。但是，必须在两个小时内修复该 bug，怎么办?</p>
<p>幸好，Git 还提供了一个 <code>stash</code> 功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，用 <code>git status</code> 查看工作区，就是干净的(除非有没有被 Git 管理的文件)，因此可以放心地创建分支来修复 bug。</p>
<p>首先确定要在哪个分支上修复 bug，假定需要在 master 分支上修复，就从 master 创建临时分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在修复 bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修复完成后，切换到 <code>master</code> 分支，并完成合并，最后删除 <code>issue-101</code> 分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>太棒了，原计划两个小时的 bug 修复只花了 5 分钟! 现在，是时候接着回到 <code>dev</code> 分支干活了!</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>工作区是干净的，刚才的工作现场存到哪去了? 用 <code>git stash list</code> 命令看看:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>工作现场还在，Git 把 stash 内容存在某个地方了，但是需要恢复一下，有两个办法:</p>
<p>一是用 <code>git stash apply</code> 恢复，但是恢复后，<code>stash</code> 内容并不删除，您需要用 <code>git stash drop</code> 来删除；</p>
<p>另一种方式是用 <code>git stash pop</code>，恢复的同时把 <code>stash</code> 内容也删了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再用 <code>git stash list</code> 查看，就看不到任何 stash 内容了。您可以多次 stash，恢复的时候，先用 <code>git stash list</code> 查看，然后恢复指定的 stash，用命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 暂存小结</h3>
<ul>
<li>
<p>修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；</p>
</li>
<li>
<p>当手头工作没有完成时，先把工作现场 <code>git stash</code> 一下，然后去修复 bug，修复后，再 <code>git stash pop</code>，回到工作现场。</p>
</li>
</ul>
<hr>
<h2> Feature 分支</h2>
<p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，您肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个 <code>feature</code> 分支，在上面开发，完成后，合并，最后，删除该 <code>feature</code> 分支。</p>
<p>现在，您终于接到了一个新任务: 开发代号为 <code>Vulcan</code> 的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>5 分钟后，开发完毕:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>切回 <code>dev</code>，准备合并:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>一切顺利的话，feature 分支和 bug 分支是类似的，合并，然后删除。</p>
<p>但是!</p>
<p>就在此时，接到上级命令，因经费不足，新功能必须取消!</p>
<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>销毁失败。Git 友情提醒，feature-vulcan 分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的 <code>-D</code> 参数。。</p>
<p>现在我们强行删除:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>终于删除成功!</p>
<h3> 删除小结</h3>
<ul>
<li>
<p>开发一个新 feature，最好新建一个分支；</p>
</li>
<li>
<p>如果要丢弃一个没有被合并过的分支，可以通过 <code>git branch -D &lt;name&gt;</code> 强行删除。</p>
</li>
</ul>
<hr>
<h2> 多人协作</h2>
<p>当您从远程仓库克隆时，实际上 Git 自动把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支对应起来了，并且，远程仓库的默认名称是 <code>origin</code>。</p>
<p>要查看远程库的信息，用 <code>git remote</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>或者，用 <code>git remote -v</code> 显示更详细的信息:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面显示了可以抓取和推送的 <code>origin</code> 的地址。如果没有推送权限，就看不到 push 的地址。</p>
<h3> 推送分支</h3>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git 就会把该分支推送到远程库对应的远程分支上:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果要推送其他分支，比如 <code>dev</code>，就改成:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢?</p>
<p><code>master</code> 分支是主分支，因此要时刻与远程同步；</p>
<p><code>dev</code> 分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p><code>bug</code> 分支只用于在本地修复 bug，就没必要推到远程了，除非老板要看看您每周到底修复了几个 bug；</p>
<p><code>feature</code> 分支是否推到远程，取决于您是否和您的小伙伴合作在上面开发。</p>
<p>总之，就是在 Git 中，分支完全可以在本地自己藏着玩，是否推送，视您的心情而定!</p>
<h3> 抓取分支</h3>
<p>多人协作时，大家都会往 <code>master</code> 和 <code>dev</code> 分支上推送各自的修改。</p>
<p>现在，模拟一个您的小伙伴，可以在另一台电脑 (注意要把 SSH Key 添加到 GitHub) 或者同一台电脑的另一个目录下克隆:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当您的小伙伴从远程库 clone 时，默认情况下，您的小伙伴只能看到本地的 <code>master</code> 分支。不信可以用 <code>git branch</code> 命令看看:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，您的小伙伴要在 <code>dev</code> 分支上开发，就必须创建远程 <code>origin</code> 的 <code>dev</code> 分支到本地，于是他用这个命令创建本地 <code>dev</code> 分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，他就可以在 <code>dev</code> 上继续修改，然后，时不时地把 <code>dev</code> 分支 push 到远程:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>您的小伙伴已经向 <code>origin/dev</code> 分支推送了他的提交，想要获取他的工作，您可以执行 <code>git fetch origin dev</code>。</p>
<p>如果这时碰巧您也对同样的文件作了修改，并试图推送:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>推送失败，因为您的小伙伴的最新提交和您试图推送的提交有冲突，解决办法也很简单，Git 已经提示我们，先用 <code>git pull</code> 把最新的提交从 <code>origin/dev</code> 抓下来，然后，在本地合并，解决冲突，再推送:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git pull</code> 也失败了，原因是没有指定本地 <code>dev</code> 分支与远程 <code>origin/dev</code> 分支的链接，根据提示，设置 <code>dev</code> 和 <code>origin/dev</code> 的链接:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再 pull:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这回 <code>git pull</code> 成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再 push:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此，多人协作的工作模式通常是这样:</p>
<p>首先，可以试图用 <code>git push origin &lt;branch-name&gt;</code> 推送自己的修改；</p>
<p>如果推送失败，则因为远程分支比您的本地更新，需要先用 <code>git pull</code> 试图合并；</p>
<p>如果合并有冲突，则解决冲突，并在本地提交；</p>
<p>没有冲突或者解决掉冲突后，再用 <code>git push origin &lt;branch-name&gt;</code> 推送就能成功!</p>
<p>如果 <code>git pull</code> 提示 <code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令 <code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<h3> 多人协作小结</h3>
<ul>
<li>
<p>查看远程库信息，使用 <code>git remote -v</code>；</p>
</li>
<li>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
</li>
<li>
<p>从本地推送分支，使用 <code>git push origin branch-name</code>，如果推送失败，先用 <code>git pull</code> 抓取远程的新提交；</p>
</li>
<li>
<p>在本地创建和远程分支对应的分支，使用 <code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
</li>
<li>
<p>建立本地分支和远程分支的关联，使用 <code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
</li>
<li>
<p>从远程拉取分支，使用 <code>git fetch</code>。</p>
</li>
<li>
<p><code>git pull</code>，相当于 <code>git fetch</code> + <code>git merge</code>，如果您的修改并没有和远程的修改发生冲突，两者会自动合并到您的本地，您可以直接推送上去。如果有冲突，要先处理冲突。</p>
</li>
</ul>
<hr>
<h2> Rebase</h2>
<p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后 <code>push</code> 的童鞋不得不先 <code>pull</code>，在本地合并，然后才能 <code>push</code> 成功。</p>
<p>每次合并再 <code>push</code> 后，分支变成了这样:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总之看上去很乱，有强迫症的童鞋会问: 为什么 Git 的提交历史不能是一条干净的直线? 其实是可以做到的!</p>
<p>Git 有一种称为 <code>rebase</code> 的操作，有人把它翻译成“变基”。</p>
<p>先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。</p>
<p>在和远程分支同步后，我们对 <code>hello.py</code> 这个文件做了两次提交。用 <code>git log</code> 命令看看:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意到 Git 用 <code>(HEAD -&gt; master)</code> 和 <code>(origin/master)</code> 标识出当前分支的 <code>HEAD</code> 和远程 <code>origin</code> 的位置分别是 <code>582d922 add author</code> 和 <code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p>
<p>现在我们尝试推送本地分支:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先 pull 一下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再用 <code>git status</code> 看看状态:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加上刚才合并的提交，现在我们本地分支比远程分支超前 3 个提交。</p>
<p>用 <code>git log</code> 看看:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支 <code>push</code> 到远程，有没有问题?</p>
<p>有!</p>
<p>什么问题?</p>
<p>不好看!</p>
<p>有没有解决方法?</p>
<p>有!</p>
<p>这个时候，rebase 就派上了用场。我们输入命令 <code>git rebase</code> 试试:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出了一大堆操作，到底是啥效果? 再用 <code>git log</code> 看看:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原本分叉的提交现在变成一条直线了! 这种神奇的操作是怎么实现的? 其实原理非常简单。我们注意观察，发现 Git 把我们本地的提交“挪动”了位置，放到了 <code>f005ed4 (origin/master) set exit=1</code> 之后，这样，整个提交历史就成了一条直线。<code>rebase</code> 操作前后，最终的提交内容是一致的，但是，我们本地的 commit 修改内容已经变化了，它们的修改不再基于 <code>d1be385 init hello</code>，而是基于 <code>f005ed4 (origin/master) set exit=1</code>，但最后的提交 <code>7e61ed4</code> 内容是一致的。</p>
<p>这就是 <code>rebase</code> 操作的特点: 把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>
<p>最后，通过 <code>push</code> 操作把本地分支推送到远程:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再用 <code>git log</code> 看看效果:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>远程分支的提交历史也是一条直线。</p>
<h2> Rebase 小结</h2>
<ul>
<li>
<p><code>rebase</code> 操作可以把本地未 <code>push</code> 的分叉提交历史整理成直线；</p>
</li>
<li>
<p><code>rebase</code> 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>修改管理</title>
      <link>https://leijue222.github.io/tutorial/ops/git/change.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/change.html</guid>
      <source url="https://leijue222.github.io/rss.xml">修改管理</source>
      <description>管理修改 Git 比其他版本控制系统设计得优秀，因为 Git 跟踪并管理的是修改，而非文件。 您会问，什么是修改? 比如您新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说 Git 管理的是修改，而不是文件呢? 我们还是做实验。第一步，对 r...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 管理修改</h2>
<p>Git 比其他版本控制系统设计得优秀，因为 Git 跟踪并管理的是修改，而非文件。</p>
<p>您会问，什么是修改? 比如您新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说 Git 管理的是修改，而不是文件呢? 我们还是做实验。第一步，对 readme.txt 做一个修改，比如加一行内容:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，添加:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，再修改 readme.txt:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提交后，再看看状态:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>怎么第二次的修改没有被提交? 我们回顾一下操作过程:</p>
<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git commit</code></p>
<p>您看，我们前面讲了，Git 管理的是修改，当您用 <code>git add</code> 命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code> 只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用 <code>git diff HEAD -- readme.txt</code> 命令可以查看工作区和版本库里面最新版本的区别:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢? 您可以继续 <code>git add</code> 再 <code>git commit</code>，也可以别着急提交第一次修改，先 <code>git add</code> 第二次修改，再 <code>git commit</code>，就相当于把两次修改合并后一块提交了:</p>
<p>第一次修改 → <code>git add</code> → 第二次修改 → <code>git add</code> → <code>git commit</code></p>
<p>好，现在，把第二次修改提交了，然后开始小结。</p>
<h3> 管理小结</h3>
<p>现在，您又理解了 Git 是如何跟踪修改的，每次修改，如果不用 <code>git add</code> 到暂存区，那就不会加入到 <code>commit</code> 中。</p>
<h2> 撤消对文件的修改</h2>
<p>自然，您是不会犯错的。不过现在是凌晨两点，您正在赶一份工作报告，您在 readme.txt 中添加了一行:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在您准备提交前，一杯咖啡起了作用，您猛然发现了 <code>'stupid boss'</code> 可能会让您丢掉这个月的奖金!</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。您可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用 <code>git status</code> 查看一下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>您可以发现，Git 会告诉您，<code>git checkout -- &lt;file&gt;</code> 可以丢弃工作区的修改:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令 <code>git checkout -- readme.txt</code> 意思就是，把 readme.txt 文件在工作区的修改全部撤销，这里有两种情况:</p>
<p>一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次 <code>git commit</code> 或 <code>git add</code> 时的状态。</p>
<p>现在，看看 readme.txt 的文件内容:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code> 命令中的 <code>--</code> 很重要，没有 <code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到 <code>git checkout</code> 命令。</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>请务必记得 <code>git checkout -- &lt;file&gt;</code> 是一个危险的命令。您对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。</p>
<p>除非您确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</p>
</div>
<h2> 取消暂存的文件</h2>
<p>现在假定是凌晨 3 点，您不但写了一些胡话，还 <code>git add</code> 到暂存区了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>庆幸的是，在 <code>commit</code> 之前，您发现了这个问题。用 <code>git status</code> 查看一下，修改只是添加到了暂存区，还没有提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Git 同样告诉我们，用命令 <code>git reset HEAD &lt;file&gt;</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git reset</code> 命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用 <code>HEAD</code> 时，表示当前的指针(最新的版本)。</p>
<p>再用 <code>git status</code> 查看一下，现在暂存区是干净的，工作区有修改:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还记得如何丢弃工作区的修改吗?</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整个世界终于清静了!</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>那么如果您想要丢弃工作区和暂存区全部更改呢? 不要忘了 <code>HEAD</code> 就是当前指针，所以</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就是丢弃工作区与暂存区的全部文件啦。</p>
</div>
<p>现在，假设您不但改错了东西，还从暂存区提交到了版本库，怎么办呢? 还记得版本回退一节吗? 可以回退到上一个版本。不过，这是有条件的，就是您还没有把自己的本地版本库推送到远程。还记得 Git 是分布式版本控制系统吗? 我们后面会讲到远程版本库，一旦您把 <code>stupid boss</code> 提交推送到远程版本库，您就真的惨了……</p>
<h3> 撤销小结</h3>
<p>场景 1: 当您改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- file</code>。</p>
<p>场景 2: 当您不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;file&gt;</code>，就回到了场景 1，第二步按场景 1 操作。</p>
<p>场景 3: 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<hr>
<h2> 删除文件</h2>
<h3> 如何删除文件</h3>
<p>在 Git 中，删除也是一个修改操作，我们实战一下，先添加一个新文件 test.txt 到 Git 并且提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般情况下，您通常直接在文件管理器中把没用的文件删了，或者用 <code>rm</code> 命令删了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个时候，Git 知道您删除了文件，因此，工作区和版本库就不一致了，<code>git status</code> 命令会立刻告诉您哪些文件被删除了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在您有两个选择，一是确实要从版本库中删除该文件，那就用命令 <code>git rm</code> 删掉，并且 <code>git commit</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，文件就从版本库中被删除了。</p>
<h3> 撤销删除</h3>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>git checkout</code> 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<h3> 删除小结</h3>
<p>命令 <code>git rm</code> 用于删除一个文件。如果一个文件已经被提交到版本库，那么您永远不用担心误删，但是要小心，您只能恢复文件到最新版本，您会丢失最近一次提交后您修改的内容。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Git 仓库</title>
      <link>https://leijue222.github.io/tutorial/ops/git/create-repo.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/create-repo.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Git 仓库</source>
      <description>什么是仓库呢? 英文名repository，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>什么是仓库呢? 英文名<strong>repository</strong>，您可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除， Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<!-- more -->
<h2> 初始化仓库</h2>
<p>创建一个仓库非常简单，首先，选择一个合适的地方，创建一个空目录:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>pwd</code> 命令用于显示当前目录。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<ul>
<li>使用 Windows 系统时，为了避免遇到各种莫名其妙的问题，请确保目录名(包括父目录)不包含中文。</li>
<li>为了确保能够执行跨平台的命令，请在 Windows 上安装 PowerShell 并设置为 VS Code 的默认终端。</li>
</ul>
</div>
<p>第二步，通过 <code>git init</code> 命令把这个目录变成 Git 可以管理的仓库:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>瞬间 Git 就把仓库建好了，而且告诉您是一个空的仓库(empty Git repository)，可以发现当前目录下多了一个.git 的目录，这个目录是 Git 来跟踪管理仓库的，如果这个目录里面的文件破坏了，Git 仓库也破坏了。</p>
<p>如果您没有看到 .git 目录，那是因为这个目录默认是隐藏的，用 <code>ls -ah</code> 命令就可以看见。</p>
<p>也不一定必须在空目录下创建 Git 仓库，选择一个已经有东西的目录也是可以的。</p>
<div class="hint-container danger">
<p class="hint-container-title">警告</p>
<p>请不要用已经在使用的项目练习 Git!</p>
</div>
<h2> 把文件添加到仓库</h2>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如 TXT 文件，网页，所有的程序代码等等，Git 也不例外。版本控制系统可以告诉您每次的改动，比如在第 5 行加了一个单词“Linux”，在第 8 行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但到底改了啥，版本控制系统不知道，也没法知道。(Microsoft 的 Word 格式是二进制格式，所以很不幸) 所以要使用版本控制系统，就要以纯文本方式编写文件。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>因为文本是有编码的，比如中文有常用的 GBK 编码，日文有 Shift_JIS 编码，如果没有历史遗留问题，强烈建议使用标准的 UTF-8 编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<ul>
<li>具体详情请见 <a href="/tutorial/code/basic/encoding.html" target="blank">文件编码</a></li>
</ul>
</div>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>千万不要使用 Windows 自带的记事本编辑任何文本文件。</p>
<ul>
<li>具体详情请见 <a href="/tutorial/code/windows/notepad.html" target="blank">记事本遗留问题</a></li>
</ul>
</div>
<p>现在编写一个 readme.txt 文件，内容如下:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一定要放到 <code>learngit</code> 目录下(子目录也行)，因为这是一个 Git 仓库，放到其他地方 Git 再厉害也找不到这个文件。</p>
<p>把一个文件放到 Git 仓库只需要两步:</p>
<ol>
<li>
<p>用命令 <code>git add</code> 告诉 Git，把文件添加到仓库:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行上面的命令，没有任何显示，这就对了，Unix 的哲学是“没有消息就是好消息”，说明添加成功。</p>
</li>
<li>
<p>用命令 <code>git commit</code> 告诉 Git，把文件提交到仓库:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git commit</code> 命令，<code>-m</code> 后面输入的是本次提交的说明，这样您就能从历史记录里方便地找到改动记录。</p>
<p><code>git commit</code> 命令执行成功后会告诉您，<code>1 file changed</code>: 1 个文件被改动(我们新添加的 readme.txt 文件)；<code>2 insertions</code>: 插入了两行内容(readme.txt 有两行内容)。</p>
</li>
</ol>
<p>为什么 Git 添加文件需要 <code>add</code>，<code>commit</code> 一共两步呢? 因为 <code>commit</code> 可以一次提交很多文件，所以您可以多次 <code>add</code> 不同的文件，比如:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 小结</h2>
<ul>
<li>
<p>初始化一个 Git 仓库，使用 <code>git init</code> 命令。</p>
</li>
<li>
<p>添加文件到 Git 仓库，分两步:</p>
<ol>
<li>使用命令 <code>git add &lt;file&gt;</code>，可反复多次使用，添加多个文件；</li>
<li>使用命令 <code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>自定义 Git</title>
      <link>https://leijue222.github.io/tutorial/ops/git/custom.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/custom.html</guid>
      <source url="https://leijue222.github.io/rss.xml">自定义 Git</source>
      <description>在安装 Git 一节中，我们已经配置了 user.name 和 user.email，实际上，Git 还有很多可配置项。 比如，让 Git 显示颜色，会让命令输出看起来更醒目: 这样，Git 会适当地显示不同的颜色，比如 git status 命令，文件名就会标上颜色。 配置别名 有没有经常敲错命令? 比如 git status? status 这个单...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>在安装 Git 一节中，我们已经配置了 <code>user.name</code> 和 <code>user.email</code>，实际上，Git 还有很多可配置项。</p>
<p>比如，让 Git 显示颜色，会让命令输出看起来更醒目:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，Git 会适当地显示不同的颜色，比如 <code>git status</code> 命令，文件名就会标上颜色。</p>
<h2> 配置别名</h2>
<p>有没有经常敲错命令? 比如 <code>git status</code>? <code>status</code> 这个单词真心不好记。</p>
<p>如果敲 <code>git st</code> 就表示 <code>git status</code> 那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉 Git，以后 <code>st</code> 就表示 <code>status</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>好了，现在敲 <code>git st</code> 看看效果。</p>
<p>当然还有别的命令可以简写，很多人都用 <code>co</code> 表示 <code>checkout</code>，<code>ci</code> 表示 <code>commit</code>，<code>br</code> 表示 <code>branch</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以后提交就可以简写成:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>--global</code> 参数是全局参数，也就是这些命令在这台电脑的所有 Git 仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令 <code>git reset HEAD file</code> 可以把暂存区的修改撤销掉(unstage)，重新放回工作区。既然是一个 <code>unstage</code> 操作，就可以配置一个 <code>unstage</code> 别名:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当您敲入命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实际上 Git 执行的是:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>配置一个 <code>git last</code>，让其显示最后一次提交信息:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，用 <code>git last</code> 就能显示最近一次的提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>甚至还有人丧心病狂地把 <code>lg</code> 配置成了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>来看看 <code>git lg</code> 的效果:</p>
<p></p>
<p>为什么不早点告诉我? 别激动，咱不是为了多记几个英文单词嘛!</p>
<h2> 配置文件</h2>
<p>配置 Git 的时候，加上 <code>--global</code> 是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了? 每个仓库的 Git 配置文件都放在 <code>.git/config</code> 文件中:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>别名就在 <code>[alias]</code> 后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的 Git 配置文件放在用户主目录下的一个隐藏文件 <code>.gitconfig</code> 中:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<h3> 别名小结</h3>
<ul>
<li>给 Git 配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Git Large File Storage</title>
      <link>https://leijue222.github.io/tutorial/ops/git/gitLFS.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/gitLFS.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Git Large File Storage</source>
      <description>Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remot...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Git Large File Storage</h1>
<p>Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.</p>
<h2> Getting Started</h2>
<ol>
<li>
<p>Download and install the Git command-line extension. Once downloaded and installed, set up Git LFS and its respective hooks by running:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>You’ll need to run this in your repository directory, once per repository.</p>
</li>
<li>
<p>Select the file types you’d like Git LFS to manage (or directly edit your .gitattributes). You can configure file extensions at anytime.</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Make sure to track <code>.gitattributes</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>忽略特殊文件</title>
      <link>https://leijue222.github.io/tutorial/ops/git/ignore.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/ignore.html</guid>
      <source url="https://leijue222.github.io/rss.xml">忽略特殊文件</source>
      <description>有些时候，您必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次 git status 都会显示 Untracked files ...，有强迫症的童鞋心里肯定不爽。 好在 Git 考虑到了大家的感受，这个问题解决起来也很简单，在 Git 工作区的根目录下创建一个特殊的 .gitignore 文件，然后...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>有些时候，您必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次 <code>git status</code> 都会显示 <code>Untracked files</code> ...，有强迫症的童鞋心里肯定不爽。</p>
<p>好在 Git 考虑到了大家的感受，这个问题解决起来也很简单，在 Git 工作区的根目录下创建一个特殊的 <code>.gitignore</code> 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。</p>
<p>忽略文件的原则是:</p>
<ul>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 <code>.class</code> 文件；</li>
<li>忽略您自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ul>
<p>举个例子:</p>
<p>假设您在 Windows 下进行 Python 开发，Windows 会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有 <code>Desktop.ini</code> 文件，因此您需要忽略 Windows 自动生成的垃圾文件:</p>
<div class="language-gitignore line-numbers-mode" data-ext="gitignore"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，继续忽略 Python 编译产生的 <code>.pyc</code>、<code>.pyo</code>、<code>dist</code> 等文件或目录:</p>
<div class="language-gitignore line-numbers-mode" data-ext="gitignore"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>加上您自己定义的文件，最终得到一个完整的 <code>.gitignore</code> 文件，内容如下:</p>
<div class="language-gitignore line-numbers-mode" data-ext="gitignore"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后一步就是把 <code>.gitignore</code> 也提交到 Git，就完成了! 当然检验 <code>.gitignore</code> 的标准是 <code>git status</code> 命令是不是说 <code>working directory clean</code>。</p>
<p>使用 Windows 的童鞋注意了，如果您在资源管理器里新建一个 <code>.gitignore</code> 文件，它会非常弱智地提示您必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 <code>.gitignore</code> 了。</p>
<p>有些时候，您想添加一个文件到 Git，但发现添加不了，原因是这个文件被 <code>.gitignore</code> 忽略了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果您确实想添加该文件，可以用 <code>-f</code> 强制添加到 Git:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者您发现，可能是 <code>.gitignore</code> 写得有问题，需要找出来到底哪个规则写错了，可以用 <code>git check-ignore</code> 命令检查:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Git 会告诉我们，<code>.gitignore</code> 的第 3 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<h2> 格式规范</h2>
<ul>
<li>
<p>所有空行或者以 # 开头的行都会被 Git 忽略。</p>
</li>
<li>
<p>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</p>
</li>
<li>
<p>匹配模式可以以(<code>/</code>)开头防止递归。</p>
</li>
<li>
<p>匹配模式可以以(<code>/</code>)结尾指定目录。</p>
</li>
<li>
<p>要忽略指定模式以外的文件或目录，可以在模式前加上叹号(<code>!</code>)取反。</p>
</li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">glob 模式</p>
<p>所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号(<code>*</code>)匹配零个或多个任意字符；<code>[abc]</code> 匹配任何一个列在方括号中的字符 (这个例子要么匹配一个 <code>a</code>，要么匹配一个 <code>b</code>，要么匹配一个 <code>c</code>)； 问号(<code>?</code>)只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配(比如 <code>[0-9]</code> 表示匹配所有 <code>0</code> 到 <code>9</code> 的数字)。使用两个星号(<code>**</code>)表示匹配任意中间目录，比如 <code>a/**/z</code> 可以匹配 <code>a/z</code> 、<code>a/b/z</code> 或 <code>a/b/c/z</code> 等。</p>
</div>
<p>一个具体的例子:</p>
<div class="language-gitignore line-numbers-mode" data-ext="gitignore"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 您可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener noreferrer">https://github.com/github/gitignore</a> 找到它。</p>
</div>
<div class="hint-container tip">
<p class="hint-container-title">多个 .gitignore</p>
<p>在最简单的情况下，一个仓库可能只根目录下有一个 .gitignore 文件，它递归地应用到整个仓库中。然而，子目录下也可以有额外的 .gitignore 文件。子目录中的 .gitignore 文件中的规则只作用于它所在的目录中。(Linux 内核的源码库拥有 206 个 .gitignore 文件。)</p>
</div>
<h2> 小结</h2>
<ul>
<li>
<p>忽略某些文件时，需要编写 <code>.gitignore</code>；</p>
</li>
<li>
<p><code>.gitignore</code> 文件本身要放到版本库里，并且可以对 <code>.gitignore</code> 做版本管理!</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>安装与配置</title>
      <link>https://leijue222.github.io/tutorial/ops/git/install.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/install.html</guid>
      <source url="https://leijue222.github.io/rss.xml">安装与配置</source>
      <description>Git 下载 官网在国外，网速较慢。在安装 Git 前推荐安装好 VS Code (../vscode/README.md)。 官网下载 (https://git-scm.com/downloads/); Git 的安装 1. 同意协议并选择安装位置 (不建议更改安装位置) 安装协议 安装位置 1. 启用 LFS 支持，其他随意 (影响不大) 组件选择...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Git 下载</h2>
<p>官网在国外，网速较慢。在安装 Git 前推荐安装好 <a href="/tutorial/ops/vscode/" target="blank">VS Code</a>。</p>
<ul>
<li><a href="https://git-scm.com/downloads/" target="_blank" rel="noopener noreferrer">官网下载</a></li>
</ul>
<h2> Git 的安装</h2>
<ol>
<li>
<p>同意协议并选择安装位置 (不建议更改安装位置)</p>
<p></p>
<p></p>
</li>
<li>
<p>启用 LFS 支持，其他随意 (影响不大)</p>
<p></p>
</li>
<li>
<p>自行决定是否创建启动菜单</p>
<p></p>
</li>
<li>
<p>选择使用 VS Code 作为 git 的默认编辑器。</p>
<p></p>
</li>
<li>
<p>选择 Git 使用的默认分支名，GitHub 已经将默认分支名称改为 main。</p>
<p></p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>在 2020 年的黑人运动中，部分黑人认为 master 这个词是对它们的冒犯。</p>
</div>
</li>
<li>
<p>选择第二项，这将允许您在第三方工具中使用 Git，同时不会覆盖默认的 Windows 命令。</p>
<p></p>
</li>
<li>
<p>使用 OpenSSL Library</p>
<p></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>如果自己公司有 CA，或者在开发中需要 Git 承认某些自签 CA，则需要选择第二项。</p>
</div>
</li>
<li>
<p>务必选择最后一项 “原样检出与提交”</p>
<p></p>
</li>
<li>
<p>选择 Git 终端</p>
<p></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>如果您对 VS Code 和 PowerShell 还不熟悉，建议选择 MinTTY，以方便您接下来在学习中对 Git Bash 的临时使用。</p>
</div>
</li>
<li>
<p>选择 <code>git pull</code> 的默认行为，保持默认不要改动</p>
<p></p>
</li>
<li>
<p>选择凭据储存管理器，请选择第一个跨平台管理器</p>
<p></p>
</li>
<li>
<p>额外的选项确认，均勾选即可</p>
<p></p>
</li>
<li>
<p>一些实验性的功能，通常不太稳定或有 bug，不同 Git 版本会有差异，可根据自身情况确定</p>
<p></p>
</li>
</ol>
<h2> Git Bash</h2>
<p>安装完成后，您可以通过搜索找到“Git Bash” (Mac 上叫 Git Shell)，这是一个 Git 提供的命令窗口，您可以在这里运行 Git 命令。</p>
<p></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>如果您对 VS Code 和 PowerShell 还不熟悉，您可以在接下来的学习与操作中使用 Git Bash。</p>
<p>否则，你可以:</p>
<ul>
<li>在 Linux 上直接通过终端来使用 Git。</li>
<li>在 Windows 上安装最新的 PowerShell，并在终端中使用 Git。</li>
</ul>
</div>
<h2> Git 的初次配置</h2>
<ol>
<li>
<p>为 Git 全局配置用户名和邮箱。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>将上方的字符串换成您自己的名字和邮箱。</p>
<p>如:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>由于 Git 是一个多人协作的版本控制系统，首先您应当设置您的身份。</p>
</div>
</li>
<li>
<p>创建 SSH Key。打开 Shell (Windows 下打开 cmd)，创建 SSH Key:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到 .ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<ul>
<li>
<p>ssh-keygen 用来生成一堆密钥，作为您的身份识别信息，您可以放心的把公钥交给别人，留下自己的私钥。</p>
</li>
<li>
<p><code>.ssh</code> 目录是默认隐藏的。Win10 查看隐藏文件详见 <a href="/tutorial/code/windows/hidden-file.html" target="blank">显示隐藏的文件</a></p>
</li>
</ul>
</div>
<div class="hint-container info">
<p class="hint-container-title">RSA</p>
<p>RSA 是一种不对称加密，公钥的加密只能通过私钥解开，反之私钥的加密只能由公钥解开。也就是说当您给别人自己的公钥的时候，他们也无法冒充您。</p>
</div>
</li>
<li>
<p>打开 <a href="https://github.com" target="_blank" rel="noopener noreferrer">GitHub</a> 并选择 "Sign in" 注册自己的账号。</p>
<p></p>
<p>登陆 GitHub 后，点击右上角头像，进入设置。</p>
<p>进入 "安全设置" 下的 "SSH 公钥" 界面。</p>
<p></p>
<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中，设置一个标识此电脑的备注。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Git 介绍</title>
      <link>https://leijue222.github.io/tutorial/ops/git/intro.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/intro.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Git 介绍</source>
      <description>Git 是什么? Git 是目前世界上最先进的分布式版本控制系统(没有之一)。</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Git 是什么?</p>
<p>Git 是目前世界上最先进的分布式版本控制系统(没有之一)。</p>
<!-- more -->
<h2> 版本控制系统</h2>
<p>什么是“版本控制”? 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。您可以对任何类型的文件进行版本控制。</p>
<ul>
<li>如果您是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本(这或许是您非常渴望拥有的功能)</li>
<li>如果您是一名作家，您可能需要保存您对作品的每一次修改以便将来如果随着情节发展需要变动可以撤销它们。</li>
<li>甚至您是一名学生，您的论文也可以进行版本控制。</li>
<li>哪怕您工作了，保存各种报表的各种版本也是没有坏处的。</li>
</ul>
<p>在很多情况下，采用版本控制系统(VCS)都是个明智的选择! 有了它您就可以将选定的文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，您可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算您乱来一气把整个项目中的文件改的改删的删，您也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<h3> 本地版本控制系统</h3>
<p>许多人习惯用复制整个项目目录的方式来保存不同的版本，或许还会改名加上备份时间以示区别。这么做唯一的好处就是简单，但是特别容易犯错。有时候会混淆所在的工作目录，一不小心会写错文件或者覆盖意想外的文件。为了解决这个问题，人们很久以前就开发了许多种本地版本控制系统，大多都是采用某种简单的数据库来记录文件的历次更新差异。</p>
<p></p>
<div class="hint-container tip">
<p class="hint-container-title">RCS</p>
<p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。RCS 的工作原理是在硬盘上保存补丁集(补丁是指文件修订前后的变化)；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
</div>
<h3> 集中化的版本控制系统</h3>
<p>接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作? 于是，集中化的版本控制系统(Centralized Version Control Systems，简称 CVCS)应运而生。这类系统，诸如 CVS、Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。多年以来，这已成为版本控制系统的标准做法。</p>
<p>集中式版本控制系统版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，您要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p>这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说 现在，每个人都可以在一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p>
<p></p>
<p>CVS 作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于 CVS 自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的 SVN 修正了 CVS 的一些稳定性问题，是目前用得最多的集中式版本库控制系统。</p>
<p>事分两面，有好有坏。集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个 10M 的文件就需要 5 分钟。另外若中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问您将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<h3> 分布式版本控制系统</h3>
<p>于是分布式版本控制系统(Distributed Version Control System，简称 DVCS)面世了。</p>
<p>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，您工作的时候，就不需要联网了，因为版本库就在您自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢? 比方说您在自己电脑上改了文件 A，您的同事也在他的电脑上改了文件 A，这时，您们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能您们俩不在一个局域网内，两台电脑互相访问不了，也可能今天您的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p>
</div>
<p>在这类系统中，像 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>
<p>更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，您就可以在同一个项目中，分别和不同工作小组的人相互协作。您可以根据需要设定不同的协作流程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>高级合并</title>
      <link>https://leijue222.github.io/tutorial/ops/git/merge.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/merge.html</guid>
      <source url="https://leijue222.github.io/rss.xml">高级合并</source>
      <description>Squash merge 通过使用 --squash 选项，你可以在合并中将多个 commit 合并为一个。 也就是对于以下的例子 git merge feature 得到的结果为: 而如果 feature 分支意在实现一个完成的特性，两个 commit 只是工作进度实际上并不重要的时候，我们可以通过 git merge --squash featur...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Squash merge</h2>
<p>通过使用 <code>--squash</code> 选项，你可以在合并中将多个 commit 合并为一个。</p>
<p>也就是对于以下的例子</p>
<p><code>git merge feature</code> 得到的结果为:</p>
<p>而如果 <code>feature</code> 分支意在实现一个完成的特性，两个 commit 只是工作进度实际上并不重要的时候，我们可以通过 <code>git merge --squash feature</code> 得到:</p>
<h2> Cherry pick</h2>
<p>有些时候，我们可能需要提取其他分支的某个 commit，这个时候我们可以用 cherry pick 进行操作。</p>
<p>在这种情况下，我们可以回到 main 分支，执行 <code>git cherry-pick &lt;commit id&gt;</code> 来挑拣某个提交，当然，你可以一并在命令中提交挑拣多个 commit。</p>
<ul>
<li><code>git cherry-pick &lt;commit id 1&gt; &lt;commit id 2&gt;</code> 表示挑拣 commit id 1 和 commit id 2</li>
<li><code>git cherry-pick &lt;commit id 1&gt;...&lt;commit id 2&gt;</code> 表示挑拣 commit id 1 与 commit id 2 之间 (包括两者) 的所有提交</li>
<li><code>git cherry-pick &lt;branch&gt;</code> 表示挑拣该分支最新的提交</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Git 代理</title>
      <link>https://leijue222.github.io/tutorial/ops/git/proxy.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/proxy.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Git 代理</source>
      <description>由于目前 GitHub 已经在全国大部分范围内被主要运营商进行 DNS 封锁，所以如果需要配合 GitHub 使用 Git，需要进行代理设置。 代理设置 通常情况下，我们可以通过设置环境变量 HTTPPROXY 和 HTTPSPROXY 来进行代理设置。 在 Windows 下，我们可以通过设置环境变量 HTTPPROXY 和 HTTPSPROXY 来...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于目前 GitHub 已经在全国大部分范围内被主要运营商进行 DNS 封锁，所以如果需要配合 GitHub 使用 Git，需要进行代理设置。</p>
<h2> 代理设置</h2>
<p>通常情况下，我们可以通过设置环境变量 <code>HTTP_PROXY</code> 和 <code>HTTPS_PROXY</code> 来进行代理设置。</p>
<p>在 Windows 下，我们可以通过设置环境变量 <code>HTTP_PROXY</code> 和 <code>HTTPS_PROXY</code> 来进行代理设置。</p>
<details class="hint-container details"><summary>Windows 例子</summary>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></details>
<details class="hint-container details"><summary>Linux 例子</summary>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></details>
<p>上述做法仅对当前终端有效，如果需要永久生效，可以将上述命令添加到系统环境变量 (Windows) 或 <code>~/.bashrc</code> (Linux) 中。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p><a href="/tutorial/code/windows/env-variable.html" target="blank">Windows 添加环境变量</a></p>
</div>
<h2> SSH 配置</h2>
<p>如果你在使用 22 端口通过 SSH 使用 Git，那么你需要在用户目录下的 <code>.ssh</code> 目录新建 <code>config</code> 文件，并输入以下内容:</p>
<div class="language-conf line-numbers-mode" data-ext="conf"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>如果在 WSL 使用，获取 Windows 的 IP 地址命令为 <code>ip route | grep default | awk '{print $3}'</code>。</p>
<p>特别注意，如不进行额外配置，每次重启后主机地址都会发生变化。</p>
</div>
<p>你可以使用 <code>ssh -T git@github.com</code> 来测试你的代理配置是否有效。</p>
]]></content:encoded>
    </item>
    <item>
      <title>撤销操作</title>
      <link>https://leijue222.github.io/tutorial/ops/git/recall.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/recall.html</guid>
      <source url="https://leijue222.github.io/rss.xml">撤销操作</source>
      <description>在任何一个阶段，您都有可能想要撤消某些操作。这里，我们将会学习几个撤消您所做修改的基本工具。注 意，有些撤消操作是不可逆的。这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个 地方之一。 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 --amend 选 项的提交命令来重新提交: 这个命...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>在任何一个阶段，您都有可能想要撤消某些操作。这里，我们将会学习几个撤消您所做修改的基本工具。注
意，有些撤消操作是不可逆的。这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个
地方之一。</p>
<p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 <code>--amend</code> 选
项的提交命令来重新提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个命令会将暂存区中的文件提交。如果自上次提交以来您还未做任何修改(例如，在上次提交后马上执行了
此命令)， 那么快照会保持不变，而您所修改的只是提交信息。</p>
<p>文本编辑器启动后，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。</p>
<p>例如，您提交后发现忘记了暂存某些需要的修改，可以像下面这样操作:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终您只会有一个提交——第二次提交将代替第一次提交的结果。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>当您在修补最后的提交时，并不是通过用改进后的提交 原位替换 掉旧有提交的方式来修复
的， 理解这一点非常重要。从效果上来说，就像是旧有的提交从未存在过一样，它并不会出
现在仓库的历史中。</p>
<p>修补提交最明显的价值是可以稍微改进您最后的提交，而不会让“啊，忘了添加一个文件”或
者 “小修补，修正笔误”这种提交信息弄乱您的仓库历史。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>远程仓库</title>
      <link>https://leijue222.github.io/tutorial/ops/git/remote.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/remote.html</guid>
      <source url="https://leijue222.github.io/rss.xml">远程仓库</source>
      <description>什么是远程仓库 Git 是分布式版本控制系统，同一个 Git 仓库，可以分布到不同的机器上。怎么分布呢? 最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 实际情况往往是这样，找一台电脑充当服务器的角色，每天 24 小时开机，其他每个人都从这个“服务器”仓库克隆一份到...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是远程仓库</h2>
<p>Git 是分布式版本控制系统，同一个 Git 仓库，可以分布到不同的机器上。怎么分布呢? 最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天 24 小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行 Git 的服务器，不过现阶段，为了学 Git 先搭个服务器绝对是小题大作。好在这个世界上有个叫 GitHub 的神奇的网站，从名字就可以看出，这个网站就是提供 Git 仓库托管服务的，所以，只要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册 GitHub 账号。由于您的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以，需要一点设置:</p>
<ul>
<li>
<p>第 1 步: 创建 SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有，再看看这个目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开 Shell (Windows 下打开 Git Bash)，创建 SSH Key:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>您需要把邮件地址换成您自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到.ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。</p>
</li>
<li>
<p>第 2 步: 登陆 GitHub，点击右上角头像，进入设置。</p>
<p>进入安全设置下的 SSH 公钥界面。</p>
<p>在标题中填写公钥的备注名称，把 id_rsa.pub 文件的内容粘贴到底下的输入框中。</p>
</li>
</ul>
<p>为什么 GitHub 需要 SSH Key 呢? 因为 GitHub 需要识别出您推送的提交确实是您推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以，GitHub 只要知道了您的公钥，就可以确认只有您自己才能推送。</p>
<p>当然，GitHub 允许您添加多个 Key。假定您有若干电脑，您一会儿在公司提交，一会儿在家里提交，只要把每台电脑的 Key 都添加到 GitHub，就可以在每台电脑上往 GitHub 推送了。</p>
<p>最后友情提示，在 GitHub 上免费托管的 Git 仓库，任何人都可以看到喔(但只有您自己才能改)。所以，不要把敏感信息放进去。</p>
<p>如果您不想让别人看到 Git 库，一是让 GitHub 把公开的仓库变成私有的，这样别人就看不见了(不可读更不可写)。另一个办法是自己动手，搭一个 Git 服务器，因为是您自己的 Git 服务器，所以别人也是看不见的。</p>
<p>确保您拥有一个 GitHub 账号后，我们就即将开始远程仓库的学习。</p>
<h2> 添加远程库</h2>
<p>现在的情景是，您已经在本地创建了一个 Git 仓库后，又想在 GitHub 创建一个 Git 仓库，并且让这两个仓库进行远程同步，这样，GitHub 上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆 GitHub，然后，在右上角找到 “+” 按钮，点击 "New Repository"。</p>
<p>在项目填入 learngit，其他保持默认设置，点击“创建”按钮，就成功地创建了一个新的 Git 仓库:</p>
<p>目前，在 GitHub 上的这个 learngit 仓库还是空的，GitHub 告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到 GitHub 仓库。</p>
<p>现在，我们根据 GitHub 的提示，在本地的 learngit 仓库下运行命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>请千万注意，把上面的 Hope-Studio 替换成您自己的 GitHub 账户名，否则，您在本地关联的就是希望工作室的远程库，关联没有问题，但是推送是推不上去的，因为您的 SSH Key 公钥不在希望工作室的账户列表中。</p>
<p>添加后，远程库的名字就是 <code>origin</code>，这是 Git 默认的叫法，也可以改成别的。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把本地库的内容推送到远程，用 <code>git push</code> 命令，实际上是把当前分支 <code>master</code> 推送到远程。</p>
<p>由于远程库是空的，我们第一次推送 <code>master</code> 分支时，加上了 <code>-u</code> 参数，Git 不但会把本地的 <code>master</code> 分支内容推送的远程新的 <code>master</code> 分支，还会把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样:</p>
<p>从现在起，只要本地作了提交，就可以通过命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>把本地 <code>master</code> 分支的最新修改推送至 GitHub，现在，您就拥有了真正的分布式版本库!</p>
<h2> SSH 警告</h2>
<p>当您第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要您确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入 <code>yes</code> 回车即可。</p>
<p>Git 会输出一个警告，告诉您已经把 GitHub 的 Key 添加到本机的一个信任列表里了:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果您实在担心有人冒充 GitHub 服务器，输入 <code>yes</code> 前可以对照 GitHub 的 RSA Key 的指纹信息是否与 SSH 连接给出的一致。</p>
<h3> 关联小结</h3>
<p>要关联一个远程库，使用命令 <code>git remote add origin git@&lt;server-name&gt;:&lt;path&gt;/&lt;repo-name&gt;.git</code>；</p>
<p>关联后，使用命令 <code>git push -u origin master</code> 第一次推送 master 分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而 SVN 在没有联网的时候是拒绝干活的! 当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了!</p>
<h2> 从远程库克隆</h2>
<p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆 GitHub，创建一个新的仓库，名字叫 <code>gitskills</code>:</p>
<p>我们勾选使用 “readme 初始化项目”，这样 GitHub 会自动为我们创建一个 README.md 文件。创建完毕后，可以看到 README.md 文件。</p>
<p>现在，远程库已经准备好了，下一步是用命令 <code>git clone</code> 克隆一个本地库:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>如果您使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。</p>
</div>
<p>注意把 Git 库的地址换成您自己的，然后进入 <code>gitskills</code> 目录看看，已经有 README.md 文件了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>您也许还注意到，GitHub 给出的地址不止一个，还可以用 <a href="https://github.com/Hope-Studio/gitskills.git" target="_blank" rel="noopener noreferrer">https://github.com/Hope-Studio/gitskills.git</a> 这样的地址。实际上，Git 支持多种协议，默认的 <code>git://</code> 使用 ssh，但也可以使用 HTTPS 等其他协议。</p>
<p>使用 HTTPS 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。</p>
<h3> 克隆小结</h3>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用 <code>git clone</code> 命令克隆。</p>
<p>Git 支持多种协议，包括 https，但通过 ssh 支持的原生 git 协议速度最快。</p>
<h2> 从远程仓库中抓取</h2>
<p>从远程仓库中获得数据，可以执行:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个命令会访问远程仓库，从中拉取所有您还没有的数据。执行完成后，您将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p><code>git fetch origin</code> 会抓取克隆(或上一次抓取)后新推送的所有工作。必须注意 <code>git fetch</code> 命令只会将数据下载到您的本地仓库——它并不会自动合并或修改您当前的工作。当准备好时您必须手动将其合并入您的工作。</p>
<h2> 推送到远程仓库</h2>
<p>当您想分享您的项目时，必须将其推送到上游。这个命令很简单: <code>git push &lt;remote&gt; &lt;branch&gt;</code>。当您
想要将 master 分支推送到 origin 服务器时(再次说明，克隆时通常会自动帮您设置好那两个名字)， 那么
运行这个命令就可以将您所做的备份到服务器:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>只有当您有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当您和其他人在同一时间克隆，他们先推送到上游然后您再推送到上游，您的推送就会毫无疑问地被拒绝。您必须先抓取他们的工作并将其合并进您的工作后才能推送。</p>
<h2> 查看某个远程仓库</h2>
<p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code> 命令。如果想以一个特
定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>它同样会列出远程仓库的 URL 与跟踪分支的信息。这些信息非常有用，它告诉您正处于 master 分支，并且如果运行 <code>git pull</code>，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。它也会列出拉取到的所有远程引用。</p>
<h2> 远程仓库的重命名与移除</h2>
<p>您可以运行 <code>git remote rename</code> 来修改一个远程仓库的简写名。例如，想要将 pb 重命名为 paul，可以用 <code>git remote rename</code> 这样做:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>值得注意的是这同样也会修改您所有远程跟踪的分支名字。那些过去引用 <code>pb/master</code> 的现在会引用 <code>paul/master</code>。</p>
<p>如果因为一些原因想要移除一个远程仓库——您已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了——可以使用 <code>git remote remove</code> 或 <code>git remote rm</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一旦您使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
]]></content:encoded>
    </item>
    <item>
      <title>版本回退</title>
      <link>https://leijue222.github.io/tutorial/ops/git/reset.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/reset.html</guid>
      <source url="https://leijue222.github.io/rss.xml">版本回退</source>
      <description>修改 readme.txt 文件如下: 然后尝试提交: 像这样不断对文件进行修改，然后不断提交修改到版本库里，每当文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在 Git 中被称为 commit。如果把文件改乱了，或者误删了文件，还可以从最近的一个 commit 恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下 r...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>修改 readme.txt 文件如下:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后尝试提交:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>像这样不断对文件进行修改，然后不断提交修改到版本库里，每当文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在 Git 中被称为 <code>commit</code>。如果把文件改乱了，或者误删了文件，还可以从最近的一个 <code>commit</code> 恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下 <code>readme.txt</code> 文件一共有几个版本被提交到 Git 仓库里了:</p>
<ul>
<li>版本 1: wrote a readme file</li>
</ul>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>版本 2: add distributed</li>
</ul>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>版本 3: append GPL</li>
</ul>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 查看版本信息</h2>
<p>版本控制系统用 <code>git log</code> 命令可以告诉我们历史记录，在 Git 中，我们查看:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git log</code> 命令显示从最近到最远的提交日志，我们可以看到 3 次提交，最近的一次是 <code>append GPL</code>，上一次是 <code>add distributed</code>，最早的一次是 <code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 <code>--pretty=oneline</code> 参数:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一大串类似 <code>1094adb...</code> 的是 commit id (版本号)，和 SVN 不一样，Git 的 commit id 不是 1，2，3…… 递增的数字，而是一个 SHA1 计算出来的一个非常大的数字，用十六进制表示，为什么 commit id 需要用这么一大串数字表示呢? 因为 Git 是分布式的版本控制系统，多人在同一个版本库里工作，如果大家都用 1，2，3…… 作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。如果使用可视化工具查看 Git 历史，就可以更清楚地看到提交历史的时间线:</p>
<p></p>
<div class="hint-container tip">
<p class="hint-container-title">更多选项</p>
<p>关于 <code>git log</code> 的更多选项，请见 <a href="/file/git/progit_v2.1.45.pdf">ProGit 书籍</a> 的 P43。</p>
</div>
<h2> 回退版本</h2>
<p>好了，现在准备把 readme.txt 回退到上一个版本，也就是 <code>add distributed</code> 的那个版本，怎么做呢?</p>
<p>首先，Git 必须知道当前版本是哪个版本，在 Git 中，用 <code>HEAD</code> 表示当前版本，也就是最新的提交 <code>1094adb...</code> (注意我的提交 ID 和您的肯定不一样)，上一个版本就是 <code>HEAD^</code>，上上一个版本就是 <code>HEAD^^</code>，当然往上 100 个版本写 100 个 <code>^</code> 比较容易数不过来，所以写成 <code>HEAD~100</code>。</p>
<p>现在，要把当前版本 <code>append GPL</code> 回退到上一个版本 <code>add distributed</code>，就可以使用 <code>git reset</code> 命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>看看 readme.txt 的内容是不是版本 add distributed:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>果然被还原了。</p>
<p>还可以继续回退到上一个版本 wrote a readme file，不过且慢，然我们用 <code>git log</code> 再看看现在版本库的状态:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最新的那个版本 append GPL 已经看不到了! 肿么办?</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，您就可以顺着往上找啊找啊，找到那个 append GPL 的 commit id 是 1094adb...，于是就可以指定回到未来的某个版本:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>版本号没必要写全，前几位就可以了，Git 会自动去找。当然也不能只写前一两位，因为 Git 可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看 readme.txt 的内容:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>果然，我胡汉三又回来了。</p>
<p>Git 的版本回退速度非常快，因为 Git 在内部有个指向当前版本的 <code>HEAD</code> 指针，当您回退版本的时候，Git 仅仅是把 <code>HEAD</code> 从指向 append GPL:</p>
<p></p>
<p>改为指向 <code>add distributed</code>:</p>
<p></p>
<p>然后顺便把工作区的文件更新了。所以您让 <code>HEAD</code> 指向哪个版本号，您就把当前版本定位在哪。</p>
<h2> 找回 commit id</h2>
<p>如果回退到了某个版本找不到新版本的 <code>commit id</code>，在 Git 中，就无法用 <code>$ git reset --hard HEAD^</code> 回退。</p>
<p>所以 Git 提供了一个命令 <code>git reflog</code> 用来记录您的每一次命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>终于舒了口气，从输出可知，append GPL 的 commit id 是 1094adb，现在，您又可以乘坐时光机回到未来了。</p>
<h2> 小结</h2>
<ul>
<li>
<p><code>HEAD</code> 指向的版本就是当前版本，因此，Git 允许我们在版本的历史之间穿梭，使用命令 <code>git reset --hard commit_id</code>。</p>
</li>
<li>
<p>用 <code>git log</code> 可以查看提交历史，以便确定要回退到哪个版本。</p>
</li>
<li>
<p>用 <code>git reflog</code> 查看命令历史，以便确定要回到未来的哪个版本。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>服务器搭建</title>
      <link>https://leijue222.github.io/tutorial/ops/git/server.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/server.html</guid>
      <source url="https://leijue222.github.io/rss.xml">服务器搭建</source>
      <description>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。 GitHub 就是一个免费托管代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，不想将源代码提交给任何第三方，这种情况下，就需要搭建 Git 服务器。</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了 7x24 小时开机并交换大家的修改。</p>
<p>GitHub 就是一个免费托管代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，不想将源代码提交给任何第三方，这种情况下，就需要搭建 Git 服务器。</p>
<!-- more -->
<p>搭建 Git 服务器需要准备一台运行 Linux 的机器，强烈推荐用 Ubuntu 或 Debian，这样，通过几条简单的 <code>apt</code> 命令就可以完成安装。</p>
<ul>
<li>
<p><strong>Ubuntu</strong> 或 <strong>Debian</strong></p>
<p>假设您已经有 sudo 权限的用户账号，下面，正式开始安装。</p>
<ul>
<li>
<p>第一步，安装 git:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>第二步，创建一个 git 用户，用来运行 git 服务:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>第三步，创建证书登录:</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的 <code>id_rsa.pub</code> 文件，把所有公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个。</p>
</li>
<li>
<p>第四步，初始化 Git 仓库:</p>
<p>先选定一个目录作为 Git 仓库，假定是 <code>/srv/sample.git</code>，在 <code>/srv</code> 目录下输入命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Git 就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的 Git 仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的 Git 仓库通常都以 <code>.git</code> 结尾。然后，把 owner 改为 git:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>第五步，禁用 shell 登录:</p>
<p>出于安全考虑，第二步创建的 git 用户不允许登录 shell，这可以通过编辑 <code>/etc/passwd</code> 文件完成。找到类似下面的一行:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>改为:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，git 用户可以正常通过 ssh 使用 git，但无法登录 shell，因为我们为 git 用户指定的 git-shell 每次一登录就自动退出。</p>
</li>
<li>
<p>第六步，克隆远程仓库:</p>
<p>现在，可以通过 <code>git clone</code> 命令克隆远程仓库了，在各自的电脑上运行:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>剩下的推送就简单了。</p>
</li>
</ul>
</li>
<li>
<p><strong>Centos</strong></p>
<ol>
<li>
<p>安装 Git</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来创建一个 git 用户组和用户，用来运行 git 服务:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>创建证书登录</p>
<p>收集所有需要登录的用户的公钥，公钥位于 <code>id_rsa.pub</code> 文件中，将公钥导入到 <code>/home/git/.ssh/authorized_keys</code> 文件里，一行一个。</p>
<p>如果没有该文件创建它:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>初始化 Git 仓库</p>
<p>首先我们选定一个目录作为 Git 仓库，假定是 <code>/home/gitrepo/test.git</code>，在 <code>/home/gitrepo</code> 目录下输入命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上命令 Git 创建一个空仓库，服务器上的 Git 仓库通常都以 <code>.git</code> 结尾。然后，把仓库所属用户改为 git:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>克隆仓库</p>
</li>
</ol>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>192.168.45.4 为 Git 所在服务器 ip ，您需要将其修改为您自己的 Git 服务 ip。</p>
<p>这样我们的 Git 服务器安装就完成。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>纵向查看</title>
      <link>https://leijue222.github.io/tutorial/ops/git/status.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/status.html</guid>
      <source url="https://leijue222.github.io/rss.xml">纵向查看</source>
      <description>我们已经成功地添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容: 现在，运行 git status 命令看看结果: git status 命令可以输出仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。 简介输出 git status 命令的输出十分详细，但其...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们已经成功地添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，运行 <code>git status</code> 命令看看结果:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git status</code> 命令可以输出仓库当前的状态，上面的命令输出告诉我们，readme.txt 被修改过了，但还没有准备提交的修改。</p>
<div class="hint-container tip">
<p class="hint-container-title">简介输出</p>
<p><code>git status</code> 命令的输出十分详细，但其用语有些繁琐。Git 有一个选项可以帮您缩短状态命令的输出，这样可以以简洁的方式查看更改。如果您使用 <code>git status -s</code> 命令或 <code>git status --short</code> 命令，您将得到一种格式更为紧凑的输出。</p>
<p>输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。</p>
<p>新添加的未跟踪文件前面有 <code>??</code> 标记，新添加到暂存区中的文件前面有 <code>A</code> 标记，修改过的文件前面有 <code>M</code> 标记。</p>
<details class="hint-container details"><summary>案例</summary>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的状态报告显示: <code>README</code> 文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code> 文件已修改且已暂存。<code>Rakefile</code> 文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>
</details>
</div>
<p>Git 现在只告诉我们 readme.txt 被修改了，我们用 <code>git diff</code> 这个命令能看看具体修改了什么内容:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git diff</code> 顾名思义就是查看 difference，显示的格式正是 Unix 通用的 diff 格式，可以从上面的命令输出看到，我们在第一行添加了一个 distributed 单词。</p>
<p>知道了对 readme.txt 作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是 <code>git add</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>同样没有任何输出。在执行第二步 <code>git commit</code> 之前，我们再运行 <code>git status</code> 看看当前仓库的状态:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git status</code> 告诉我们，将要被提交的修改包括 readme.txt，下一步，就可以放心地提交了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提交后，我们再用 <code>git status</code> 命令看看仓库的当前状态:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Git 告诉我们当前没有需要提交的修改，而且，工作目录是干净(working tree clean)的。</p>
<h2> 小结</h2>
<ul>
<li>
<p>要随时掌握工作区的状态，使用 <code>git status</code> 命令。</p>
</li>
<li>
<p>如果 <code>git status</code> 告诉您有文件被修改过，用 <code>git diff</code> 可以查看修改内容。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>标签管理</title>
      <link>https://leijue222.github.io/tutorial/ops/git/tag.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/tag.html</guid>
      <source url="https://leijue222.github.io/rss.xml">标签管理</source>
      <description>为什么要有 tag 发布一个版本时，我们通常先在版本库中打一个标签 (tag)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针(跟分支很像对不对? 但是分支可以移动，标签不能移动...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 为什么要有 tag</h2>
<p>发布一个版本时，我们通常先在版本库中打一个标签 (<code>tag</code>)，这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 <code>commit</code> 的指针(跟分支很像对不对? 但是分支可以移动，标签不能移动)，所以，创建和删除标签都是瞬间完成的。</p>
<p>Git 有 <code>commit</code>，为什么还要引入 <code>tag</code>?</p>
<p>“请把上周一的那个版本打包发布，<code>commit</code> 号是 6a5819e...”</p>
<p>“一串乱七八糟的数字不好找! ”</p>
<p>如果换一个办法:</p>
<p>“请把上周一的那个版本打包发布，版本号是 <code>v1.2</code>”</p>
<p>“好的，按照 <code>tag v1.2</code> 查找 <code>commit</code> 就行! ”</p>
<p>所以，<code>tag</code> 就是一个让人容易记住的有意义的名字，它跟某个 <code>commit</code> 绑在一起。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>推荐的标签规范是以小写字母 <code>v</code> 开头，后接 <code>x.x</code> 或 <code>x.x.x</code> 等若干位版本号。</p>
</div>
<h2> 创建轻量标签</h2>
<p>在 Git 中打标签非常简单，首先，切换到需要打标签的分支上:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，敲命令 <code>git tag &lt;name&gt;</code> 就可以打一个新标签:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>可以用命令 <code>git tag</code> 查看所有标签:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>默认标签是打在最新提交的 <code>commit</code> 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办?</p>
<p>方法是找到历史提交的 <code>commit id</code>，然后打上就可以了:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比方说要对 <code>add merge</code> 这次提交打标签，它对应的 <code>commit id</code> 是 <code>f52c633</code>，敲入命令:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>再用命令 <code>git tag</code> 查看标签:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用 <code>git show &lt;tagname&gt;</code> 查看标签信息:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，<code>v0.9</code> 确实打在 <code>add merge</code> 这次提交上。</p>
<h2> 附注标签</h2>
<p>Git 还可以创建带有说明的标签，用 <code>-a</code> 指定标签名，<code>-m</code> 指定说明文字:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>用命令 <code>git show &lt;tagname&gt;</code> 可以看到说明文字:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。</p>
</div>
<h3> 添加小结</h3>
<p>命令 <code>git tag &lt;tagname&gt;</code> 用于新建一个标签，默认为 <code>HEAD</code>，也可以指定一个 <code>commit id</code>；</p>
<p>命令 <code>git tag -a &lt;tagname&gt; -m "blablabla..."</code> 可以指定标签信息；</p>
<p>命令 <code>git tag</code> 可以查看所有标签。</p>
<h2> 操作标签</h2>
<p>如果标签打错了，也可以删除:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令 <code>git push origin &lt;tagname&gt;</code>:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者，一次性推送全部尚未推送到远程的本地标签:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，从远程删除。删除命令也是 push，但是格式如下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要看看是否真的从远程库删除了标签，可以登陆 GitHub 查看。</p>
<h3> 管理标签小结</h3>
<ul>
<li>
<p>命令 <code>git push origin &lt;tagname&gt;</code> 可以推送一个本地标签；</p>
</li>
<li>
<p>命令 <code>git push origin --tags</code> 可以推送全部未推送过的本地标签；</p>
</li>
<li>
<p>命令 <code>git tag -d &lt;tagname&gt;</code> 可以删除一个本地标签；</p>
</li>
<li>
<p>命令 <code>git push origin :refs/tags/&lt;tagname&gt;</code> 可以删除一个远程标签。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>工作区和暂存区</title>
      <link>https://leijue222.github.io/tutorial/ops/git/working-directory.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/working-directory.html</guid>
      <source url="https://leijue222.github.io/rss.xml">工作区和暂存区</source>
      <description>Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Git 和其他版本控制系统如 SVN 的一个不同之处就是有暂存区的概念。</p>
<!-- more -->
<h2> 工作区(Working Directory)</h2>
<p>就是您在电脑里能看到的目录，比如 learngit 文件夹就是一个工作区:</p>
<h2> 版本库(Repository)</h2>
<p>工作区有一个隐藏目录.git，这个不算工作区，而是 Git 的版本库。</p>
<p>Git 的版本库里存了很多东西，其中最重要的就是称为 stage(或者叫 index)的暂存区，还有 Git 为我们自动创建的第一个分支 <code>master</code>，以及指向 master 的一个指针叫 <code>HEAD</code>。</p>
<p></p>
<p>前面讲了我们把文件往 Git 版本库里添加的时候，提交更改，实际上就是把暂存区的所有内容提交到当前分支。我们创建 Git 版本库时，Git 自动为我们创建了唯一一个 <code>master</code> 分支，所以，现在，<code>git commit</code> 就是往 master 分支上提交更改。</p>
<p>您可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>先对 readme.txt 做个修改，比如加上一行内容:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，在工作区新增一个 LICENSE 文本文件(内容随便写)。</p>
<p>先用 <code>git status</code> 查看一下状态:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Git 非常清楚地告诉我们，readme.txt 被修改了，而 LICENSE 还从来没有被添加过，所以它的状态是 <code>Untracked</code>。</p>
<p>现在，使用两次命令 <code>git add</code>，把 readme.txt 和 LICENSE 都添加后，用 <code>git status</code> 再查看一下:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，暂存区的状态就变成这样了:</p>
<p></p>
<p>所以，<code>git add</code> 命令实际上就是把要提交的所有修改放到暂存区(Stage)，然后，执行 <code>git commit</code> 就可以一次性把暂存区的所有修改提交到分支。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一旦提交后，如果您又没有对工作区做任何修改，那么工作区就是“干净”的:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Git 原理</title>
      <link>https://leijue222.github.io/tutorial/ops/git/working.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/git/working.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Git 原理</source>
      <description>Git 究竟是怎样的一个系统呢? 尽管 Git 用起来与其它的版本控制系统非常相似，但它在对信息的存储和认知方式上却有很大差异。 直接记录快照，而非差异比较 Git 和其它版本控制系统(包括 Subversion 和近似工具)的主要差别在于 Git 对待数据的方法。从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统(CVS、Subver...</description>
      <category>Git</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Git 究竟是怎样的一个系统呢? 尽管 Git 用起来与其它的版本控制系统非常相似，但它在对信息的存储和认知方式上却有很大差异。</p>
<h2> 直接记录快照，而非差异比较</h2>
<p>Git 和其它版本控制系统(包括 Subversion 和近似工具)的主要差别在于 Git 对待数据的方法。从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系统(CVS、Subversion、Perforce、Bazaar 等等)将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异 (它们通常称作 基于差异(delta-based) 的版本控制)。</p>
<p></p>
<p>Git 不按照以上方式对待或保存数据。反之，Git 更像是把数据看作是对小型文件系统的一系列快照。在 Git 中，每当您提交更新或保存项目状态时，它基本上就会对当时的全部文件创建一个快照并保存这个快照的索引。为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个 <strong>快照流</strong>。</p>
<p></p>
<h2> 近乎所有操作都是本地执行</h2>
<p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。如果您习惯于所有操作都有网络延时开销的集中式版本控制系统，Git 在这方面会让您感到速度之神赐给了 Git 超凡的能量。因为您在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。您能立即看到项目历史。如果您想查看当前版本与一个月前的版本之间引入的修改， Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。</p>
<h2> Git 保证完整性</h2>
<p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。若您在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列(hash，哈希)。这是一个由 40 个十六进制字符(0-9 和 a-f)组成的字符串，基于 Git 中文件的内容或目录结构计算出来。Git 中使用这种哈希值的情况很多，您将经常看到这种哈希值。实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。</p>
<h2> Git 一般只添加数据</h2>
<p>您执行的 Git 操作，几乎只往 Git 数据库中 添加 数据。您很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容。但是一旦您提交快照到 Git 中， 就难以再丢失数据，特别是如果您定期的推送数据库到其它仓库的话。</p>
<p>这使得我们使用 Git 成为一个安心愉悦的过程，因为我们深知可以尽情做各种尝试，而没有把事情弄糟的危险。</p>
<h2> 三种状态</h2>
<p>Git 有三种状态，您的文件可能处于其中之一: 已提交(committed)、已修改(modified) 和 已暂存(staged)。</p>
<ul>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>这会让我们的 Git 项目拥有三个阶段: 工作区、暂存区以及 Git 目录。</p>
<p>工作区是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供您使用或修改。
暂存区是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中。按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。
Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。
基本的 Git 工作流程如下:</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将您想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li>
</ol>
<p>如果 Git 目录中保存着特定版本的文件，就属于 已提交 状态。如果文件已修改并放入暂存区，就属于 已暂存 状态。如果自上次检出后，作了修改但还没有放到暂存区域，就是 已修改 状态。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/</guid>
      <source url="https://leijue222.github.io/rss.xml">Linux</source>
      <description>Linux 教程 Linux 介绍 (intro/README.md); Linux 介绍 (intro/intro.md); Linux 历史 (intro/history.md); Linux 编写语言 (intro/language.md); Linux 优势 (intro/advantage.md); Linux 桌面环境 (intro/des...</description>
      <category>Linux</category>
      <pubDate>Fri, 15 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Linux 教程</h2>
<ul>
<li>
<p><a href="/tutorial/ops/linux/intro/" target="blank">Linux 介绍</a></p>
<ul>
<li>
<p><a href="/tutorial/ops/linux/intro/intro.html" target="blank">Linux 介绍</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/intro/history.html" target="blank">Linux 历史</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/intro/language.html" target="blank">Linux 编写语言</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/intro/advantage.html" target="blank">Linux 优势</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/intro/desktop.html" target="blank">Linux 桌面环境</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/ops/linux/file/" target="blank">Linux 文件</a></p>
<ul>
<li>
<p><a href="/tutorial/ops/linux/file/file.html" target="blank">Linux 文件</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/file/dir.html" target="blank">Linux 目录</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/file/mount.html" target="blank">挂载</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/ops/linux/command/" target="blank">Linux 命令</a></p>
<ul>
<li>
<p><a href="/tutorial/ops/linux/command/command.html" target="blank">命令格式简介</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/command/dir.html" target="blank">目录相关</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/command/file.html" target="blank">文件相关</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/command/other.html" target="blank">其他命令</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/command/add.html" target="blank">命令的自动补全</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/command/excu.html" target="blank">命令的执行</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/command/path.html" target="blank">环境变量</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/command/ln.html" target="blank">创建链接</a></p>
</li>
</ul>
</li>
</ul>
<h2> ubuntu</h2>
<ul>
<li><a href="/tutorial/ops/linux/ubuntu/" target="blank">点击前往</a></li>
</ul>
<h2> CentOS</h2>
<ul>
<li><a href="/tutorial/ops/linux/centos.html" target="blank">点击前往</a></li>
</ul>
<h2> WSL</h2>
<ul>
<li><a href="/tutorial/ops/linux/WSL.html" target="blank">点击前往</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>WSL</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/WSL.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/WSL.html</guid>
      <source url="https://leijue222.github.io/rss.xml">WSL</source>
      <description>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</description>
      <category>Linux</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>WSL 可以直接在 Windows 系统上安装并运行 Linux。目前最新的版本是 WSL2。</p>
<!-- more -->
<h2> Ubuntu</h2>
<p>Windows 上的功能有很大缺失。已知不能用 Snap。</p>
<h2> WSL 文件位置</h2>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 重启 WSL</h2>
<p>使用</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>和</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>CentOS 教程</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/centos.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/centos.html</guid>
      <source url="https://leijue222.github.io/rss.xml">CentOS 教程</source>
      <description>管理工具 yum (Centos 7); dnf (Centos 8); yarn 测试是否安装成功:</description>
      <category>Linux</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 管理工具</h2>
<ul>
<li>yum (Centos 7)</li>
<li>dnf (Centos 8)</li>
</ul>
<h2> yarn</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试是否安装成功:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>ssh</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/ssh.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/ssh.html</guid>
      <source url="https://leijue222.github.io/rss.xml">ssh</source>
      <description>使用密码登录 1. 执行以下命令，连接 Linux 云服务器。 username 即为前提条件中获得的默认帐号。; hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。; 1. 输入已获取的密码，按 Enter，即可完成登录。 使用密钥登录 1. 执行以下命令，赋予私钥文件仅本人可读权限。 1. 执行以下命令...</description>
      <category>基础</category>
      <pubDate>Sat, 23 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 使用密码登录</h2>
<ol>
<li>
<p>执行以下命令，连接 Linux 云服务器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
</li>
<li>
<p>输入已获取的密码，按 Enter，即可完成登录。</p>
</li>
</ol>
<h2> 使用密钥登录</h2>
<ol>
<li>
<p>执行以下命令，赋予私钥文件仅本人可读权限。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>执行以下命令，进行远程登录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>username 即为前提条件中获得的默认帐号。</li>
<li>hostname or IP address 为您的 Linux 实例公网 IP 或自定义域名。</li>
</ul>
<p>例如，执行 <code>ssh -i "id_rsa" ubuntu@123.206.113.227</code> 命令，远程登录 Linux 云服务器。</p>
</li>
</ol>
<h2> 断开链接</h2>
<p><code>Ctrl + D</code> 或 输入 <code>logout</code>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown</title>
      <link>https://leijue222.github.io/tutorial/ops/markdown/</link>
      <guid>https://leijue222.github.io/tutorial/ops/markdown/</guid>
      <source url="https://leijue222.github.io/rss.xml">Markdown</source>
      <description>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 的目标是实现「易读易写」。 Markdown 的主要目的是用来作为一种网络内容的写作用语言。</description>
      <category>Markdown</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown 的目标是实现「易读易写」。</p>
<p>Markdown 的主要目的是用来作为一种网络内容的<strong>写作用语言</strong>。</p>
<!-- more -->
<h2> 目录</h2>
<ul>
<li><a href="/tutorial/ops/markdown/intro.html" target="blank">简介</a></li>
<li><a href="/tutorial/ops/markdown/block.html" target="blank">块元素</a></li>
<li><a href="/tutorial/ops/markdown/inline.html" target="blank">行内元素</a></li>
<li><a href="/tutorial/ops/markdown/extend.html" target="blank">扩展与其他内容</a></li>
</ul>
<h2> Markdown 效果演示</h2>
<ul>
<li><a href="/tutorial/ops/markdown/demo.html" target="blank">查看详情</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown 块元素</title>
      <link>https://leijue222.github.io/tutorial/ops/markdown/block.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/markdown/block.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Markdown 块元素</source>
      <description>段落和换行 一个段落由一个及以上相连接的行句组成。 一个即以上的空行则会切分出不同的段落，一般的段落不需要用空白或断行缩进。 空行 空行的定义是显示上看起来像是空行，便会被视为空行。 也就是若某一行只包含空白和 tab，则该行也会被视为空行。 「一个及以上相连接的行句组成」这句话其实暗示了 Markdown 允许段落内的强迫断行，其它的格式会把每个断行...</description>
      <category>Markdown</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 段落和换行</h2>
<p>一个段落由一个及以上相连接的行句组成。</p>
<p>一个即以上的空行则会切分出不同的段落，一般的段落不需要用空白或断行缩进。</p>
<div class="hint-container tip">
<p class="hint-container-title">空行</p>
<p>空行的定义是显示上看起来像是空行，便会被视为空行。</p>
<p>也就是若某一行只包含空白和 tab，则该行也会被视为空行。</p>
</div>
<p>「一个及以上相连接的行句组成」这句话其实暗示了 Markdown 允许段落内的强迫断行，其它的格式会把每个断行都转成 <code>&lt;br /&gt;</code> 标签。</p>
<p>如果您<strong>真的想要</strong>插入 <code>&lt;br /&gt;</code> 标签的话，在行尾加上两个以上的空白，然后按下回车:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 标题</h2>
<p>标题能显示出文章的结构。</p>
<p>Atx (<strong>推荐</strong>)形式是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如:</p>
<ul>
<li>H1: <code># Header 1</code></li>
<li>H2: <code>## Header 2</code></li>
<li>H3: <code>### Header 3</code></li>
<li>H4: <code>#### Header 4</code></li>
<li>H5: <code>##### Header 5</code></li>
<li>H6: <code>###### Header 6</code></li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">最佳实践</p>
<p>为了使内容可读性更强，Markdown 最佳实践要求标题应使用 Atx 写法，并且每个标题应被空行隔开。 (第一行的大标题不需要向上空行)</p>
</div>
<p>Setext<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1"> 格式不推荐使用。</a></p><a class="footnote-anchor" id="footnote-ref1">
</a><h2><a class="footnote-anchor" id="footnote-ref1"></a> Blockquotes</h2>
<p>Markdown 使用 email 形式的块引言。</p>
<p>如果您很熟悉如何在 email 信件中引言，您就知道如何在 Markdown 文件中建立一个块引言:在每行的最前面加上 <code>&gt;</code> 接一个空格:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>渲染结果</summary>
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
</details>
<div class="hint-container info">
<p class="hint-container-title">易写性</p>
<p>处于易写性的考虑，Markdown 允许您只在整个段落的第一行最前面加上 <code>&gt;</code> :</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<!-- markdownlint-disable MD028 -->
<blockquote>
<p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p>
</blockquote>
<blockquote>
<p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.</p>
</blockquote>
<!-- markdownlint-enable MD028 -->
</details>
<p>但是请注意，我们<strong>不推荐</strong>使用这种做法，这并不是符合 Markdown 最佳实践。</p>
<p>同时，<code>&gt;</code> 后面的空格也是可选的，我们也推荐您加上它。</p>
</div>
<details class="hint-container details"><summary>块引言可以有阶层 (例如: 引言内的引言) ，只要根据层数加上不同数量的 &gt;</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
</details>
<details class="hint-container details"><summary>引言的块内也可以使用其他的 Markdown 语法，包括标题、列表、代码块等</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<blockquote>
<ol>
<li>This is the first list item.</li>
<li>This is the second list item.</li>
</ol>
<p>Here’s some example code:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></blockquote>
</details>
<h2> 列表</h2>
<p>Markdown 支持有序列表和无序列表。</p>
<h3> 无序列表</h3>
<p>无序列表在规范中使用减号作为列表标记:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>渲染结果</summary>
<ul>
<li>Red</li>
<li>Green</li>
<li>Blue</li>
</ul>
</details>
<div class="hint-container info">
<p class="hint-container-title">其他支持的符号</p>
<p>Markdown 最初的规范也支持使用星号、加号:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们<strong>极其不建议</strong>使用以上写法，它们并不符合 Markdown 最佳实践。(加号看上去并不像一个列表，而且星号并不是可以直接按键输入的符号)</p>
</div>
<h3> 有序列表</h3>
<p>有序列表使用数字接著一个英文句点:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>渲染结果</summary>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
</details>
<p>很重要的一点是，您在列表标记上使用的数字并不会影响输出的 HTML 结果，因为上面的列表所产生的 HTML 标记为:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>这意味着您无需刻意对列表进行标号</summary>
<p>如果您使用:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>列表项也会正确的渲染:</p>
<ol>
<li>Bird</li>
<li>McHale</li>
<li>Parish</li>
</ol>
</details>
<div class="hint-container info">
<p class="hint-container-title">将标号交给 Markdown</p>
<p>人工为列表进行正确的标号与全部使用 <code>1.</code> 都符合 Markdown 最佳实践。</p>
<p>但是请不要错误的进行标号，如:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了更加便捷的添加、删除或排序有序列表项，我们<strong>推荐都设置为标号 <code>1</code></strong>。</p>
</div>
<h3> 列表格式的转义</h3>
<p>有些时候项目列表很可能会不小心被产生，比如:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，您可以在句点前面加上反斜线。</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 缩进与段落</h3>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多三个空白，项目标记后面则一定要接著至少一个空白或 tab。</p>
<p>要让列表看起来更漂亮，您可以把内容用固定的缩进整理好:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>渲染结果</summary>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
</details>
<div class="hint-container info">
<p class="hint-container-title">易写性</p>
<p>处于易写性的考虑，列表缩进不是强制的，也就是以下的内容渲染结果与上面相同。</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>渲染结果</summary>
<ul>
<li>Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.</li>
<li>Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.</li>
</ul>
</details>
<p>但是我们<strong>不推荐</strong>这种写法，这种写法会导致 Markdown 源文件可读性变差，不符合 Markdown 最佳实践。</p>
</div>
<p>如果列表项目间用空行分开， Markdown 会把项目的内容在输出时用 <code>&lt;p&gt;</code> 标签包起来，举例来说:</p>
<details class="hint-container details"><summary>普通的无序列表</summary>
<p>输入:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换结果:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>渲染:</p>
<ul>
<li>Bird</li>
<li>Magic</li>
<li>Wood</li>
</ul>
</details>
<p>但是这个:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会被转换为:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details class="hint-container details"><summary>渲染结果</summary>
<ul>
<li>
<p>Bird</p>
</li>
<li>
<p>Magic</p>
</li>
<li>
<p>Wood</p>
</li>
</ul>
</details>
<p>这会在列表项之间创建更大的空间。</p>
<div class="hint-container tip">
<p class="hint-container-title">最佳实践</p>
<p>对于一个列表项来说，只要有一项使用了空行，所有项目都会转换为段落，也就是以下格式也会渲染为段落列表。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<ul>
<li>
<p>Bird</p>
</li>
<li>
<p>Magic</p>
</li>
<li>
<p>Wood</p>
</li>
</ul>
</details>
<p>Markdown 最佳实践要求您在每一个列表间始终(或始终不)添加空行。</p>
</div>
<p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 2 - 4 个空白或是一个 tab。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<ul>
<li>
<p>This is a list item with two paragraphs.</p>
<p>This is the second paragraph in the list item. You’re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.</p>
</li>
<li>
<p>Another item in the same list.</p>
</li>
</ul>
<ol>
<li>
<p>This is a list item with two paragraphs. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit. Aliquam hendrerit
mi posuere lectus.</p>
<p>Vestibulum enim wisi, viverra nec, fringilla in, laoreet
vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
sit amet velit.</p>
</li>
<li>
<p>Suspendisse id sem consectetuer libero luctus adipiscing.</p>
</li>
</ol>
</details>
<p>如果要在列表项目内放入其他内容，也需要缩进。</p>
<p>比如放进引言，那 <code>&gt;</code> 就需要缩进:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">Markdown 最佳实践</p>
<p>为了更高的可读性，段落缩进应当等同于列表第一行，也就是无序列表缩进 2 个空格，有序列表根据缩进三或四个空格。</p>
</div>
<h2> 代码块</h2>
<p>和代码相关的写作或是标签语言原始码通常会有已经排版好的代码块，通常这些块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码块包起来。</p>
<p>Markdown 最初标准只规定了一种缩进格式的代码块<sup class="footnote-ref"><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2"></a></sup><a class="footnote-anchor" id="footnote-ref2">。</a></p><a class="footnote-anchor" id="footnote-ref2">
<p>由于缩进式的代码块格式不够鲜明，且无法在此模式下设置代码块的语言并对代码块进行高亮，围栏式的代码扩展几乎被所有 Markdown 实现所支持。</p>
<p>Markdown 最佳实践也同样推荐使用围栏式的代码块，尽管它并不在最初的标准中。</p>
<p>您可以很简单的使用 <code>```代码名称</code> 与 <code>```</code> 创建围栏式代码块。比如:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会渲染为</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在代码块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让您非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制粘贴，再加上缩进就可以了，剩下的 Markdown 都会帮您处理。</p>
<details class="hint-container details"><summary>Markdown 处理例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>转换结果</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<p>代码块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示您可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
</a><h3><a class="footnote-anchor" id="footnote-ref2"></a> 转义与嵌套</h3>
<p>如果您希望在一个代码块中放置另一个 Markdown 代码块格式，您可以增加 <code>`</code> 的数量来进行嵌套</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="highlight-lines"><div class="highlight-line">&nbsp;</div><br><br><br><div class="highlight-line">&nbsp;</div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会渲染为</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果您希望输入 <code>```</code>，您可以使用 <code>\</code> 转义:</p>
<p><code>\`\`\`</code> 会被渲染为: ```</p>
<h3> 分隔线</h3>
<p>您可以在一行中用三个或以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。您也可以在星号中间插入空白。下面每种写法都可以建立分隔线:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="highlight-lines"><div class="highlight-line">&nbsp;</div><br><div class="highlight-line">&nbsp;</div><br><div class="highlight-line">&nbsp;</div><br><div class="highlight-line">&nbsp;</div><br><div class="highlight-line">&nbsp;</div><br><div class="highlight-line">&nbsp;</div></div><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>Setext 格式</p>
<p>Setext 形式是用底线的形式，利用 <code>=</code> (最高阶标题) 和 <code>-</code> (第二阶标题) ，例如:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>请注意我们<strong>极其不推荐</strong>使用该格式! 因为它不仅麻烦，还仅支持两级目录。 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p>缩进格式的代码块</p>
<p>在 Markdown 中，可以通过简单地缩进 4 个空白或是 1 个 tab 来建立代码块。比如:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Markdown 会转换成:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的缩进 (4 个空白或是 1 个 tab) ，都会被移除，例如:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>会被转换为:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个代码块会一直持续到没有缩进的那一行 (或是文件结尾)。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown示例</title>
      <link>https://leijue222.github.io/tutorial/ops/markdown/demo.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/markdown/demo.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Markdown示例</source>
      <description>二级标题 三级标题 四级标题 五级标题 六级标题 Text 这句话里拥有加粗、倾斜和 段落 这是一个段落。 这是另一个段落。 换行 这是一句话不过我要在这里 换行 上方的代码中 这里 后面有两个空格 引用 引用也可以连用 可以添加额外的大于号制造更深的引用 列表 无序列表 无序列表项; 无序列表项; 列表中的列表项; 更多的列表项; 更多的列表项; 更...</description>
      <category>Markdown</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<!-- markdownlint-disable -->
<h1> 一级标题</h1>
<!-- markdownlint-restore -->
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 二级标题</h2>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 三级标题</h3>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 四级标题</h4>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5> 五级标题</h5>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h6> 六级标题</h6>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> Text</h2>
<p>这句话里拥有<strong>加粗</strong>、<em>倾斜</em>和<s>删除</s></p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 段落</h2>
<p>这是一个段落。</p>
<p>这是另一个段落。</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 换行</h2>
<p>这是一句话不过我要在这里<br>
换行</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>上方的代码中 <code>这里</code> 后面有两个空格</p>
</div>
<h2> 引用</h2>
<blockquote>
<p>引用也可以连用</p>
<blockquote>
<p>可以添加额外的大于号制造更深的引用</p>
</blockquote>
</blockquote>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 列表</h2>
<h3> 无序列表</h3>
<ul>
<li>
<p>无序列表项</p>
</li>
<li>
<p>无序列表项</p>
<ul>
<li>
<p>列表中的列表项</p>
<ul>
<li>更多的列表项</li>
<li>更多的列表项</li>
<li>更多的列表项</li>
</ul>
</li>
<li>
<p>列表中的长列表项，这个列表项很长。</p>
<p>而且由很多个段落构成。</p>
<p>甚至最后一个段落还包含了<a href="#%E9%93%BE%E6%8E%A5">链接</a>。</p>
</li>
</ul>
</li>
<li>
<p>无序列表项</p>
</li>
</ul>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 有序列表</h3>
<ol>
<li>有序列表第一项</li>
<li>有序列表第二项<br>
第二项的需要换行<br>
再次换行</li>
<li>有序列表第三项</li>
</ol>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>上方的代码中<code>换行</code>后面有也两个空格</p>
</div>
<h2> 分割线</h2>
<hr>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 链接</h2>
<p><a href="/" target="blank">根目录访问主页</a></p>
<p><a href="/tutorial/" target="blank">相对路径主页</a></p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>VuePress 还兼容如下跳转到主页的写法:</p>
<ul>
<li>
<p><a href="/tutorial/ops/" target="blank">相对路径访问，兼容 Markdown 编写时相互跳转</a></p>
</li>
<li>
<p><a href="/" target="blank">根目录访问主页 2</a></p>
</li>
<li>
<p><a href="/tutorial/ops/index.html" target="blank">HTML 形式</a></p>
</li>
</ul>
<p>如果希望在使用编辑器编辑 Markdown 时也能够进行相互跳转的话，则需要全部使用<strong>相对路径</strong>，并且<code>README.md</code><strong>不能省略</strong>。</p>
<p>代码:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h2> 图片</h2>
<p><img src="/logo.svg" alt="Logo" loading="lazy"></p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> Emoji</h2>
<p>经典方式:</p>
<p>😉 😢 😆 😋</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>简写:</p>
<p>😎 😃 :* 😦 😃 😦 😉</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>更多详见 <a href="/tutorial/ops/markdown/emoji/" target="blank">Emoji 列表</a></p>
</div>
<h2> 表格</h2>
<table>
<thead>
<tr>
<th style="text-align:center">居中</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:left">左对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">居中使用<code>:-:</code></td>
<td style="text-align:right">右对齐使用<code>-:</code></td>
<td style="text-align:left">左对齐使用<code>:-</code></td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:right">aaaaaaaaa</td>
<td style="text-align:left">aaaa</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:right">aaaa</td>
<td style="text-align:left">a</td>
</tr>
</tbody>
</table>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 代码</h2>
<p>行内代码效果: <code>code</code></p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>缩进代码:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际代码:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>块级代码</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>高亮格式:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://leijue222.github.io/logo.svg" type="image/svg+xml"/>
    </item>
    <item>
      <title>Markdown 扩展</title>
      <link>https://leijue222.github.io/tutorial/ops/markdown/extend.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/markdown/extend.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Markdown 扩展</source>
      <description>其他特性 自动链接 Markdown 支持比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接，链接的文字就和链接位置一样，例如: Markdown 会转为: 自动的邮件链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以...</description>
      <category>Markdown</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 其他特性</h2>
<h3> 自动链接</h3>
<p>Markdown 支持比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接，链接的文字就和链接位置一样，例如:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Markdown 会转为:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>自动的邮件链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以混淆一些不好的信箱地址收集机器人，例如:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Markdown 会转成:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在浏览器里面，这段字串会变成一个可以点击的「address@example.com」链接。</p>
<p>(这种作法虽然可以混淆不少的机器人，但并无法全部挡下来，不过这样也比什么都不做好些。无论如何，公开您的信箱终究会引来广告信件的。)</p>
<h3> 转义字符</h3>
<p>Markdown 可以利用反斜线来插入一些在语法中有其它意义的符号，例如: 如果您想要用星号加在文字旁边的方式来做出强调效果 (但不用 <code>&lt;em&gt;</code> 标签) ，您可以在星号的前面加上反斜线:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Markdown 支持在下面这些符号前面加上反斜线来帮助插入普通的符号:</p>
<ul>
<li><code>\</code> 反斜线</li>
<li><code>`</code> 反引号</li>
<li><code>*</code> 星号</li>
<li><code>_</code> 底线</li>
<li><code>{}</code> 大括号</li>
<li><code>[]</code> 方括号</li>
<li><code>()</code> 括号</li>
<li><code>#</code> 井字号</li>
<li><code>+</code> 加号</li>
<li><code>-</code> 减号</li>
<li><code>.</code> 英文句点</li>
<li><code>!</code> 惊叹号</li>
</ul>
<h2> 大部分编辑器通用快捷键</h2>
<table>
<thead>
<tr>
<th>输出后的效果</th>
<th>Markdown</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bold</strong></td>
<td><code>**text**</code></td>
<td>Ctrl/⌘ + B</td>
</tr>
<tr>
<td><em>Emphasize</em></td>
<td><code>*text*</code></td>
<td>Ctrl/⌘ + I</td>
</tr>
<tr>
<td><code>Inline Code</code></td>
<td>`code`</td>
<td>选中后 <code>`</code></td>
</tr>
</tbody>
</table>
<h2> 常见扩展</h2>
<p>有几种轻量级标记语言是 Markdown 的超集。它们包含 Gruber 的基本语法，并通过添加其他元素 (例如表，代码块，语法突出显示，URL 自动链接和脚注) 在此基础上构建。许多最受欢迎的 Markdown 应用程序使用以下轻量级标记语言之一:</p>
<ul>
<li><a href="https://commonmark.org/" target="_blank" rel="noopener noreferrer">CommonMark</a></li>
<li><a href="https://github.github.com/gfm/" target="_blank" rel="noopener noreferrer">GitHub Flavored Markdown (GFM)</a></li>
<li><a href="https://michelf.ca/projects/php-markdown/extra/" target="_blank" rel="noopener noreferrer">Markdown Extra</a></li>
<li><a href="https://fletcherpenney.net/multimarkdown/" target="_blank" rel="noopener noreferrer">MultiMarkdown</a></li>
<li><a href="https://rmarkdown.rstudio.com/" target="_blank" rel="noopener noreferrer">R Markdown</a></li>
</ul>
<h3> 表格</h3>
<p>表格是 GFM 标准支持的格式。</p>
<p>您需要创建表头，并使用 <code>---</code> 来分割表头和表身。</p>
<p>您需要使用 <code>|</code> 来分割每一个表格项目，如果您需要输入 <code>|</code> 请使用 <code>\</code> 转义它。</p>
<p>您可以在表头分割行处使用 <code>:</code> 来自定义该列的对其</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">居中</th>
<th style="text-align:right">右对齐</th>
<th style="text-align:left">左对齐</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">居中使用<code>:-:</code></td>
<td style="text-align:right">右对齐使用<code>-:</code></td>
<td style="text-align:left">左对齐使用<code>:-</code></td>
</tr>
<tr>
<td style="text-align:center">b</td>
<td style="text-align:right">表格中包含的 | 需要转义</td>
<td style="text-align:left">aaaa</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:right">aaaa</td>
<td style="text-align:left">a</td>
</tr>
</tbody>
</table>
</details>
<h3> Emoji</h3>
<p>Emoji 是 GFM 标准支持的格式，需要通过 <code>:emoji名称:</code> 来使用 emoji。</p>
<p>例子: <code>:smile:</code> 😄</p>
<p>您可以在 <a href="/tutorial/ops/markdown/emoji/" target="blank">Emoji 列表</a> 找到所有可用的 Emoji。</p>
<h3> 删除线</h3>
<p>您可以使用 <code>~~delete~~</code> 来创建类似 <s>delete</s> 的删除线</p>
<h3> 脚注</h3>
<p>在 Markdown 中使用 <code>[^锚点文字]</code> 来定义脚注。</p>
<p>在之后的任何位置使用 <code>[^锚点文字]: ...</code> 来描述脚注内容。</p>
<p>如果脚注包含多个段落，其后的段落应当保持双层缩进。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p>脚注 1 链接<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup><a class="footnote-anchor" id="footnote-ref1">.</a></p><a class="footnote-anchor" id="footnote-ref1">
</a><p><a class="footnote-anchor" id="footnote-ref1">脚注 2 链接<sup class="footnote-ref"></sup></a><a href="#footnote2">[2]</a><a class="footnote-anchor" id="footnote-ref2">.</a></p><a class="footnote-anchor" id="footnote-ref2">
</a><p><a class="footnote-anchor" id="footnote-ref2">行内的脚注<sup class="footnote-ref"></sup></a><a href="#footnote3">[3]</a><a class="footnote-anchor" id="footnote-ref3"> 定义.</a></p><a class="footnote-anchor" id="footnote-ref3">
</a><p><a class="footnote-anchor" id="footnote-ref3">重复的页脚引用<sup class="footnote-ref"></sup></a><a href="#footnote2">[2:1]</a><a class="footnote-anchor" id="footnote-ref2:1">.</a></p><a class="footnote-anchor" id="footnote-ref2:1">
</a></details><a class="footnote-anchor" id="footnote-ref2:1">
</a><h3><a class="footnote-anchor" id="footnote-ref2:1"></a> 自定义标题</h3>
<p>许多 Markdown 处理器支持标题的自定义 ID。</p>
<p>添加自定义 ID 允许您直接链接到标题并使用 CSS 对其进行修改。要添加自定义标题 ID，请在与标题相同的行上用大括号括起该自定义 ID。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>渲染结果</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details>
<h3> 定义列表</h3>
<p>一些 Markdown 处理器允许您创建术语及其对应定义的定义列表。要创建定义列表，请在第一行上键入术语。在下一行，键入一个冒号，后跟一个空格和定义。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>渲染结果</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<!-- markdownlint-disable MD033 -->
<dl>
  <dt>First Term</dt>
  <dd>This is the definition of the first term.</dd>
  <dt>Second Term</dt>
  <dd>This is one definition of the second term.</dd>
  <dd>This is another definition of the second term.</dd>
</dl>
</details>
<h3> 任务列表</h3>
<p>任务列表使您可以创建带有复选框的项目列表。</p>
<p>要创建任务列表，请创建一个列表，并以方括号 <code>[ ]</code> 开头。通过添加空格 <code>x</code> 来改变复选框的勾选情况。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<ul>
  <li><input type="checkbox" checked="" disabled="">Write the press release</li>
  <li><input type="checkbox" disabled="">Update the website</li>
  <li><input type="checkbox" disabled="">Contact the media</li>
</ul>
</details>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>脚注 <strong>可以包含特殊标记</strong></p>
<p>也可以由多个段落组成 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote2" class="footnote-item"><p>脚注文字。 <a href="#footnote-ref2" class="footnote-backref">↩︎</a> <a href="#footnote-ref2:1" class="footnote-backref">↩︎</a></p>
</li>
<li id="footnote3" class="footnote-item"><p>Text of inline footnote <a href="#footnote-ref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>Markdown 行内元素</title>
      <link>https://leijue222.github.io/tutorial/ops/markdown/inline.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/markdown/inline.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Markdown 行内元素</source>
      <description>链接 Markdown 支持两种形式的链接语法: 行内和参考。 不管是哪一种，链接的文字都是用 [方括号] 来标记。 行内链接 要建立一个行内形式的链接，只要在方块括号后输入圆括号并插入网址链接即可，如果您还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。 例子 输入: 渲染结果: 输出: This is an...</description>
      <category>Markdown</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 链接</h2>
<p>Markdown 支持两种形式的链接语法: <em>行内</em>和<em>参考</em>。</p>
<p>不管是哪一种，链接的文字都是用 <code>[方括号]</code> 来标记。</p>
<h3> 行内链接</h3>
<p>要建立一个行内形式的链接，只要在方块括号后输入圆括号并插入网址链接即可，如果您还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>渲染结果</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p>This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener noreferrer">an example</a> inline link.</p>
<p><a href="http://example.net/" target="_blank" rel="noopener noreferrer">This link</a> has no title attribute.</p>
</details>
<p>如果您是要链接到同样主机的资源，您可以使用绝对路径或相对路径:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 参考链接</h3>
<p>参考形式的链接使用另外一个方括号接在链接文字的括号后面，而在第二个方括号里面要填入标识链接的标签:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>之后在文件的任意地方，您都可以把这个标签的链接内容定义出来:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>链接定义的形式为:</p>
<ul>
<li>方括号，输入链接的标识 ID</li>
<li>冒号</li>
<li>一个以上的空白或 tab</li>
<li>链接的网址</li>
<li>选择性地添加 title 内容，可以用单引号、双引号或是括号包括</li>
</ul>
<p>下面这三种链接的定义相同:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>链接网址也可以用方括号包起来:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>您也可以把 title 属性放到下一行，也可以加一些缩进，网址太长的话，这样会比较好看:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨识标签可以有字母、数字、空白和标点符号，但是并<strong>不</strong>区分大小写，因此下面两个链接是一样的:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">最佳实践</p>
<p>由于不区分大小写的原因，Markdown 最佳实践推荐标识标签均使用小写。</p>
</div>
<h4> 简写</h4>
<p>您可以通过简写写法省略指定链接标签，这种情形下，链接标签和链接文字会视为相同，要用预设链接标签只要在链接文字后面加上一个空的方括号，如果您要让 "Google" 链接到 google.com，您可以简化成:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后定义链接内容:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>由于链接文字可能包含空白，所以这种简化的标签内也可以包含多个文字:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后定义链接:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>链接的定义可以放在文件中的任何一个地方，建议放在链接出现段落的后面或文件最后面，就像是注解一样。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>等同于</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>渲染结果</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener noreferrer">Google</a> than from
<a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener noreferrer">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener noreferrer">MSN</a>.</p>
<p><strong>同样的行内模式写法</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<div class="hint-container tip">
<p class="hint-container-title">优势</p>
<p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的链接却会增加到 176 个字符，如果是用纯 HTML 格式来写，会有 234 个字符，在 HTML 格式中，标签比文字还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让您可以把一些标记相关的资讯移到段落文字之外，您就可以增加链接而不让文章的阅读感觉被打断。</p>
</div>
<h2> 强调</h2>
<p>Markdown 使用星号 (<code>*</code>) 和底线 (<code>_</code>) 作为标记强调字词的符号。</p>
<p>被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>渲染结果</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<p>但是如果您的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p>These two _, _ and *, * will be treated as normal characters.</p>
</details>
<div class="hint-container tip">
<p class="hint-container-title">最佳实践</p>
<p>为了将两者进行区分，Markdown 最佳实践要求在所有地方尽可能使用 <code>**</code> 和 <code>_</code>。但是这里有一个例外:</p>
<p>由于使用代码或者是其他情况，人们很容易创造出带有下划线的单词 (如 <code>last_updated_time</code>)，在这种情况下，updated 就不会识别为斜体。只有在这种情况下，使用 <code>*</code> 而不是 <code>_</code>。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p>A varibale like last_updated_time won’t be <em>transformed</em> like last<em>updated</em>time.</p>
</details>
</div>
<p>强调也可以直接插在文字中间:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 转义</h3>
<details class="hint-container details"><summary>如果要在文字前后直接插入普通的星号或底线，您可以用 \</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p>*this text is surrounded by literal asterisks*</p>
<p>_this text is surrounded by literal underscores_</p>
</details>
<h2> 代码</h2>
<p>如果要标记一小段行内代码，您可以用反引号 (<code>`</code>) 把它包起来。</p>
<div class="hint-container tip">
<p class="hint-container-title">反引号</p>
<p>反引号在键盘的左上角，ESC 键的下方</p>
</div>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>渲染结果</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p>Use the <code>printf()</code> function.</p>
</details>
<h3> 转义</h3>
<p>如果要在代码内插入反引号，您可以用多个反引号来开启和结束行内代码</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>渲染结果</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p><code>There is a literal backtick (`) here.</code></p>
</details>
<p>代码码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样您就可以在区段的一开始就插入反引号。</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>渲染结果</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p>A single backtick in a code span: <code>`</code></p>
<p>A backtick-delimited string in a code span: <code>`foo`</code></p>
</details>
<p>在代码码区段内，<code>&amp;</code> 和方括号都会被转成 HTML 实体，这样会比较容易插入 HTML 原始码.</p>
<details class="hint-container details"><summary>例子</summary>
<p><strong>输入</strong>:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>渲染结果</strong>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>输出</strong>:</p>
<p>Please don’t use any <code>&lt;blink&gt;</code> tags.</p>
</details>
<h2> 图片</h2>
<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式: <em>行内</em> 和 <em>参考</em>。</p>
<ul>
<li>
<p>行内图片的语法如下:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>详细叙述如下:</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>一个方括号，里面放上图片的替代文字</li>
<li>一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上
选择性的 title 文字。</li>
</ul>
</li>
<li>
<p>参考式的图片语法如下:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>id</code> 是图片参考的名称，图片参考的定义方式则和链接参考一样:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<p>它们的优劣与链接相同。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>Markdown 无法指定图片的宽高，如果您需要的话，您可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
</div>
]]></content:encoded>
      <enclosure url="https://leijue222.github.io/path/to/img.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>Markdown 介绍</title>
      <link>https://leijue222.github.io/tutorial/ops/markdown/intro.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/markdown/intro.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Markdown 介绍</source>
      <description>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。 Markdown 的目标是实现「易读易写」。它的扩展名为 .md。</description>
      <category>Markdown</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>Markdown 的目标是实现「易读易写」。它的扩展名为 <code>.md</code>。</p>
<!-- more -->
<h2> 设计理念</h2>
<p>Markdown 最需要强调的便是它的可读性。一份使用 Markdown 格式撰写的文件应该可以直接以纯文字发布，并且看起来不会像是由许多标签或是格式指令所构成。</p>
<p>其语法在设计时受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="noopener noreferrer">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="noopener noreferrer">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="noopener noreferrer">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="noopener noreferrer">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="noopener noreferrer">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="noopener noreferrer">EtText</a>，然而最大灵感来源其实是纯文字的电子邮件格式。因此 Markdown 的语法全由标点符号所组成，并经过严谨慎选，是为了让它们看起来就像所要表达的意思。像是在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。假如您有使用过电子邮件，引言写法看起来就真的像是引用一段文字。</p>
<p>Markdown 具有一系列衍生版本，用于扩展 Markdown 的功能 (如表格、脚注、内嵌 HTML 等等) ，这些功能并不在最初的设计中，但它们能让 Markdown 转换成更多的格式，例如 LaTeX，Docbook。Markdown 增强版中比较有名的有 Markdown Extra、MultiMarkdown、 Maruku 等。这些衍生版本要么基于工具，如 Pandoc；要么基于网站，如 GitHub 和 Wikipedia，在语法上基本兼容，但在一些语法和渲染效果上有改动。</p>
<h2> 用途</h2>
<p>Markdown 的语法有个主要的目的: 用来作为一种网络内容的<strong>写作用语言</strong>。Markdown 的重点在于，它能让文件<strong>更容易阅读、编写</strong>。因此，Markdown 的格式语法只涵盖纯文字可以涵盖的范围。</p>
<p>Markdown 的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。世界上最流行的博客平台 WordPress 能很好的支持 Markdown。</p>
<p>用于编写说明文档，并且以 “README.md” 的文件名保存在软件的目录下面。</p>
<p>除此之外，我们还可以快速将 Markdown 转化为演讲 PPT、Word 产品文档、LaTex 论文甚至是用非常少量的代码完成最小可用原型。在数据科学领域，Markdown 已经广泛使用，极大地推进了动态可重复性研究的历史进程。</p>
<h2> 特点</h2>
<h3> 行内 HTML</h3>
<p>不在 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>只有块元素 ── 比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以利与内容区隔。而且这些 (元素) 的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 的解析器有智慧型判断，可以避免在块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p>
<p>举例来说，在 Markdown 文件里加上一段 HTML 表格:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>Markdown 语法在 HTML 块标签中将不会被进行处理。</p>
<p>例如，您无法在 HTML 块内使用 Markdown 形式的 <code>*强调*</code>。</p>
</div>
<h3> 特殊字符自动转换</h3>
<p>简单来说，在 Markdown 中，您无需考虑 HTML 本应考虑的特殊字符转义的问题。</p>
<p>比如对于 <code>AT&amp;T</code>，Markdown 就会将它转为 <code>AT&amp;amp;T</code>。</p>
<div class="hint-container tip">
<p class="hint-container-title">HTML 中的特殊字符</p>
<p>在 HTML 文件中，有两个字符需要特殊处理: <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果您只是想要使用这些符号，您必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p>使用 HTML 时，<code>&amp;</code> 符号其实很容易让写作网络文件的人感到困扰。</p>
<p>如果您要打 「AT&amp;T」 ，您必须要写成 <code>「AT&amp;amp;T」</code>。</p>
<p>同时您还得转换网址内的 <code>&amp;</code> 符号，如果您要链接到 <code>http://images.google.com/images?num=30&amp;q=larry+bird</code>，您必须要把网址转成 <code>http://images.google.com/images?num=30&amp;amp;q=larry+bird</code>，才能放到链接标签的 <code>href</code> 属性里。</p>
<p>不用说也知道这很容易忘记，这也可能是 HTML 标准检查所检查到的错误中，数量最多的。</p>
</div>
<p>Markdown 即允许您直接使用这些符号。也允许您使用转义符号。</p>
<p>比如您如果要在文件中插入一个著作权的符号，但是您又不想费力地输入这个不常见的特殊符号，您可以直接在 Markdown 中输入 <code>&amp;copy;</code>，Markdown 会推测出它是转移符号，并把它输出为 ©。</p>
<p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 支持 <a href="#%E8%A1%8C%E5%86%85-HTML">行内 HTML</a> ，如果您是使用 <code>&lt;</code> 符号作为 HTML 标签使用，那 Markdown 也不会对它做任何转换，但是如果您是写:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Markdown 将会把它转换为:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>需要注意的是，code 范围内，不论是行内还是块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让您可以很容易地用 Markdown 写 HTML code (和 HTML 相对而言， HTML 语法中，您要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。)</p>
</div>
<h2> 编写</h2>
<p>Markdown 就是一个扩展名为 <code>.md</code> 的文本文件。</p>
<p>理论上您可以使用任何编辑器 (如 <a href="/software/vscode/" target="blank">VS Code</a>)编辑 Markdown，也可以使用专门的 Markdown 编辑器 (如 <a href="https://typora.io" target="_blank" rel="noopener noreferrer">Typora</a>) 进行编写。</p>
]]></content:encoded>
    </item>
    <item>
      <title>小程序框架说明</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/framework/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/framework/</guid>
      <source url="https://leijue222.github.io/rss.xml">小程序框架说明</source>
      <description>开发框架优点 1. 将界面开发的复杂过程转换为编写简单的 yaml 文件。开发门槛低， 1. 拥有详细的开发文档说明，简单易懂，页面文件自述性高，没有开发基础的人也可以经过简单阅读后看懂页面文件大体描述内容。查看例子点这里 (demo.md) 1. 开发者无需着眼于界面样式或是功能的实现，只需着眼于在 yaml 文件中添加渲染界面所需参数并赋值，即可完...</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 开发框架优点</h2>
<ol>
<li>
<p>将界面开发的复杂过程转换为编写简单的 yaml 文件。开发门槛低，</p>
</li>
<li>
<p>拥有详细的开发文档说明，简单易懂，页面文件自述性高，没有开发基础的人也可以经过简单阅读后看懂页面文件大体描述内容。<a href="/tutorial/front-end/mini-app/framework/demo.html" target="blank">查看例子点这里</a></p>
</li>
<li>
<p>开发者无需着眼于界面样式或是功能的实现，只需着眼于在 yaml 文件中添加渲染界面所需参数并赋值，即可完成界面编写。开发者只需在开发过程中按照开发说明录入参数，并注意格式即可。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>YAML 文件案例</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/framework/demo.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/framework/demo.html</guid>
      <source url="https://leijue222.github.io/rss.xml">YAML 文件案例</source>
      <description>账户页面 账户页面二维码 校园卡介绍 校园卡介绍页面二维码</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 账户页面</h2>
<p></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 校园卡介绍</h2>
<p></p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Page 插件</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/framework/page.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/framework/page.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Page 插件</source>
      <description>提示 page.ts 用于小程序页面渲染。</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p><code>page.ts</code> 用于小程序页面渲染。</p>
</div>
<!-- more -->
<h2> 插件的引入</h2>
<p>首先在 <code>ts</code> 文件头部引入 <code>page</code> 与 <code>@mptool/enhance</code>。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 函数</h2>
<h3> resolvePage()</h3>
<p><code>(option: PageQuery, page?: PageData, setGlobal = true) =&gt; PageData | null</code></p>
<p><strong>简介:</strong></p>
<ul>
<li>
<p>性质: 同步函数</p>
</li>
<li>
<p>描述: 预处理 <code>page</code> 数据写入全局数据</p>
</li>
<li>
<p>用法: 在页面 <code>onNavigate</code> 时调用，</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>option</td>
<td>页面跳转参数</td>
</tr>
<tr>
<td>page</td>
<td>页面数据</td>
</tr>
<tr>
<td>setGlobal</td>
<td>是否将处理后的数据写入到全局数据中</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>返回: 处理后的 page 配置</p>
</li>
</ul>
<p><strong>案例:</strong></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> setPage()</h3>
<p><code>({ option, ctx, handle }: SetPageOption, page?: ComponentData[] | undefined, preload?: boolean) =&gt; void</code></p>
<p><strong>简介:</strong></p>
<ul>
<li>
<p>描述: 设置本地界面数据，如果传入 <code>page</code> 参数，则根据 <code>handle</code> 的值决定是否在 <code>setData</code> 前处理 <code>page</code>。</p>
<p>如果没有传入 <code>page</code>，则使用 <code>PageOption.data.page</code>。之后根据 <code>preload</code> 的值决定是否对页面链接进行预加载。</p>
</li>
<li>
<p>用法: 在页面 <code>onLoad</code> 时调用</p>
</li>
<li>
<p>性质: 同步函数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>object</td>
<td>配置对象</td>
</tr>
<tr>
<td>page</td>
<td>页面数据</td>
</tr>
<tr>
<td>preload [default:true]</td>
<td>是否预加载子页面</td>
</tr>
</tbody>
</table>
<p><code>object</code> 参数:</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>option</td>
<td>页面传参</td>
</tr>
<tr>
<td>ctx</td>
<td>页面指针</td>
</tr>
<tr>
<td>handle [default:false]</td>
<td>页面是否已经被处理</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><strong>案例:</strong></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> setOnlinePage()</h3>
<p><code>(option: PageOption, ctx: PageInstanceWithPage, preload = true) =&gt; void</code></p>
<p><strong>简介:</strong></p>
<ul>
<li>
<p>描述: 设置在线界面数据</p>
</li>
<li>
<p>用法: 在页面 <code>onLoad</code> 时调用</p>
</li>
<li>
<p>性质: 同步函数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>option</td>
<td>页面跳转参数</td>
</tr>
<tr>
<td>ctx</td>
<td>页面指针</td>
</tr>
<tr>
<td>preload [default:true]</td>
<td>是否预加载子页面</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><strong>案例:</strong></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> popNotice()</h3>
<p><code>(id: string) =&gt; void</code></p>
<p><strong>简介:</strong></p>
<ul>
<li>
<p>描述: 弹出通知</p>
</li>
<li>
<p>用法: 在页面 <code>onLoad</code> 时调用</p>
</li>
<li>
<p>性质: 同步函数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>当前界面的标识符</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><strong>案例:</strong></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> getColor()</h3>
<p><code>(grey?: boolean) =&gt; Colors</code></p>
<p><strong>简介:</strong></p>
<ul>
<li>
<p>描述: 获得页面背景相关颜色</p>
</li>
<li>
<p>用法: 在页面 <code>onShow</code> 时调用</p>
</li>
<li>
<p>性质: 同步函数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>grey [default:false]</td>
<td>页面是否为灰色背景</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p><strong>案例:</strong></p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>小程序简易开发指南</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/framework/simple-debug.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/framework/simple-debug.html</guid>
      <source url="https://leijue222.github.io/rss.xml">小程序简易开发指南</source>
      <description>这里是开发前应当了解的内容，阅读时长大约为五分钟。 json 文件中合法的值有哪些 合法的值大家编辑用到的一共有五种: number(数字)、boolean(布尔值)、string(字符串)、array(数组)和object(对象)。 json 介绍 对象 对象的一组键值对，使用冒号结构表示。 转为 JavaScript 如下。 Yaml 也允许另一种...</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>这里是开发前应当了解的内容，阅读时长大约为五分钟。</p>
<h2> json 文件中合法的值有哪些</h2>
<p>合法的值大家编辑用到的一共有五种:
<strong>number</strong>(数字)、<strong>boolean</strong>(布尔值)、<strong>string</strong>(字符串)、<strong>array</strong>(数组)和<strong>object</strong>(对象)。</p>
<h2> json 介绍</h2>
<h3> 对象</h3>
<p>对象的一组键值对，使用冒号结构表示。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>转为 JavaScript 如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>转为 JavaScript 如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 数组</h3>
<p>一组连词线开头的行，构成一个数组。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转为 JavaScript 如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转为 JavaScript 如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>数组也可以采用行内表示法。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>转为 JavaScript 如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 复合结构</h3>
<p>对象和数组可以结合使用，形成复合结构。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转为 JavaScript 如下。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 纯量</h3>
<p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<p>数值直接以字面量的形式表示。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>转为 JavaScript 如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>布尔值用 <code>true</code> 和 <code>false</code> 表示。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>转为 JavaScript 如下。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 如何打开或编辑 json</h3>
<p>推荐使用 VS Code，具体详见<a href="/tutorial/software/vscode/simple.html" target="blank">VS Code 简单介绍</a>。</p>
<h3> json 中的值</h3>
<p>合法的值大家编辑用到的一共有五种:</p>
<ul>
<li><strong>number</strong>(数字)</li>
<li><strong>boolean</strong>(布尔值)</li>
<li><strong>string</strong>(字符串)</li>
<li><strong>array</strong>(数组)</li>
<li><strong>object</strong>(对象)</li>
</ul>
<h3> 什么是<strong>number</strong></h3>
<p><strong>number</strong>是可以直接参与运算数值，整数和小数直接表示</p>
<p><strong>例</strong>:</p>
<ul>
<li><code>5201314</code></li>
<li><code>-1</code></li>
<li><code>3.141592654</code></li>
</ul>
<p><strong>总结:</strong> 想要表达具体的数量使用数字，直接表示即可。</p>
<h3> 什么是<strong>boolean</strong></h3>
<p><strong>boolean</strong>是布尔值，表示真假。只有两个: <code>true</code> 和 <code>false</code>。</p>
<h3> 什么是<strong>string</strong></h3>
<p><strong>string</strong>是字符串，用于表达一串文本。在文本内容外面套上英文双引号 <code>"</code> 即可表示<strong>string</strong>。</p>
<p><strong>例</strong>:</p>
<ul>
<li><code>"Mr.Hope is handsome"</code></li>
<li><code>"春眠不觉晓，处处闻啼鸟"</code></li>
<li><code>"A saying goes: \"Great hopes make great man.\""</code></li>
</ul>
<p><strong>请注意:</strong> <code>1</code> 是 <strong>number</strong>，可以参加运算；<code>"1"</code> 是<strong>string</strong>，字符串内容为 1；同理，<code>"true"</code> 是<strong>string</strong>，<code>true</code> 才是表示“真”的 <strong>boolean</strong>。</p>
<p><strong>其他注意事项:</strong> 如果想要在字符串中表示回车，请输入 <code>\n</code>。</p>
<h3> 什么是<strong>array</strong></h3>
<p>Array 中文名叫数组，它是用 <code>[</code> <code>]</code> 包括起来的、用英文逗号(comma)分隔开的内容的集合，每个项叫数组(array)的一个元素(element)。每个元素(element)可以是其他的任何值类型。</p>
<p><strong>例</strong>:</p>
<ul>
<li><code>[1, 2, 3]</code></li>
<li><code>[-5, "abc", true]</code>
(在此数组中第一项是数字 <code>-5</code>，第二项是字符串 <code>"abc"</code>，第三项是布尔值 <code>true</code>，该数组是合法的，数组的元素也可以是接下来的 object)</li>
<li><code>["小程序必火", "666", "Mr.Hope有点帅"]</code></li>
</ul>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<ul>
<li><code>[1,2,3,]</code> 是非法的，因为最后多了一个逗号导致格式不正确</li>
<li><code>[1,2,3</code> 也是非法的，因为没有结束标识符 <code>]</code> 导致格式不正确</li>
</ul>
</div>
<p><strong>总结</strong>:</p>
<p><strong>array</strong> 是一个包含若干 <strong>元素</strong> 的集合，用 <code>[</code> <code>]</code> 表示，每一个 <strong>元素</strong> 之间需要用 <strong>英文逗号</strong> 隔开，即 <code>array = [element1 , element2 , ...]</code>，其中<strong>元素</strong>可以是其他数据类型。</p>
<h3> 什么是<strong>object</strong></h3>
<p><strong>object</strong> 中文名叫对象(不是您想的那个对象)，它是用 <code>{</code> <code>}</code> 包括起来的用逗号分隔开的一堆属性(property)的集合，每个属性(property)是一个不可重复的字符串，对应着一个值(value)，用冒号对应。该值(value)可以是任何内容。</p>
<p><strong>例</strong>:</p>
<ul>
<li>
<p><code>{"a":1,"b":"2","c":true,"d":"false"}</code></p>
<p>该对象有四项，分别是:</p>
<ul>
<li>值为数字 <code>1</code> 的 <code>a</code></li>
<li>值为字符串 <code>2</code> 的 <code>b</code></li>
<li>值为布尔值 真(<code>true</code>)的 <code>c</code></li>
<li>值为字符串 <code>false</code> 的 <code>d</code></li>
</ul>
</li>
<li>
<p><code>{"tag":"p","head":"校园卡说明","text":"校园卡是东师的金融消费卡"}</code>。</p>
</li>
</ul>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<ul>
<li><code>{a:1,b:2}</code> 是非法的，因为属性不是一个字符串</li>
<li><code>{"a":1,"a":2}</code> 是非法的，因为属性 <code>a</code> 出现了两次无法确定其值</li>
<li><code>{a:1,b:2,}</code>、<code>a:1,b:2}</code> 是非法的，因为格式不正确。</li>
</ul>
</div>
<p><strong>总结</strong>:</p>
<p><strong>object</strong>是一个拥有若干<strong>property</strong>的集合，用 <code>{</code> <code>}</code> 表示，每一个<strong>property</strong>都是不可重复的<strong>string</strong>，而每个<strong>property</strong>对应着一个<strong>value</strong>即 <code>object = { property1 : value1 , proprety2 : value2 , ... }</code>，其中<strong>value</strong>可以是其他数据类型。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>使用 VS Code 可以格式化<strong>object</strong>，可以使<strong>object</strong>更易于阅读。</p>
<p>如:</p>
<p><code>{"tag":"p","head":"校园卡说明","text":"校园卡是东师的金融消费卡"}</code></p>
<p>可以格式化为:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h3> 关于值的嵌套</h3>
<p>由于<strong>array</strong>的<strong>element</strong>和 <strong>object</strong> 的<strong>value</strong>可以是五种值的任一个，故可以发生嵌套。</p>
<p><strong>如</strong>:</p>
<p><code>[{"a":"Mr.Hope"},{"b":"Ms.Hope"}]</code></p>
<p>就是一个数组: <code>[ element1 , element2 ]</code>，而该数组的<strong>element1</strong>是<strong>object</strong><code>{ "a" : "Mr.Hope" }</code>，<strong>element2</strong>是<strong>object</strong><code>{ "b" : "Ms.Hope" }</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>小程序页面参数表</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/framework/tag-list.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/framework/tag-list.html</guid>
      <source url="https://leijue222.github.io/rss.xml">小程序页面参数表</source>
      <description>版本: V5 总体结构 参数 必填 值类型 内容 备注 :-------: :--: :------------------: ------------------ ----------------------------------------------- title 是 string 导航栏标题 一般不超过八个字，六字及以下为佳 desc 否 s...</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p><img src="https://img.shields.io/badge/版本-V5-blue.svg?style=for-the-badge" alt="版本: V5" loading="lazy"></p>
<h2> 总体结构</h2>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>导航栏标题</td>
<td>一般不超过八个字，六字及以下为佳</td>
</tr>
<tr>
<td style="text-align:center">desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>页面描述</td>
<td>会显示在页脚</td>
</tr>
<tr>
<td style="text-align:center">author</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>页面的作者</td>
<td>会显示在页脚</td>
</tr>
<tr>
<td style="text-align:center">time</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>页面更新时间</td>
<td>会显示在页脚</td>
</tr>
<tr>
<td style="text-align:center">grey</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>使用灰色背景</td>
<td>默认为白色背景</td>
</tr>
<tr>
<td style="text-align:center">cite</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | string[]</code></td>
<td>页面引用链接</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">content</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>ComponentConfig[]</code></td>
<td>页面的内容</td>
<td>数组的每个对象会最终渲染为一个组件</td>
</tr>
<tr>
<td style="text-align:center">from</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>左上角返回按钮文字</td>
<td>设置左上角文字，默认为上一级页面标题</td>
</tr>
<tr>
<td style="text-align:center">outdated</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否已过时</td>
<td>可展示一条“页面过时”提示</td>
</tr>
<tr>
<td style="text-align:center">shareable</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否可被分享</td>
<td>是否可以使用小程序的界面分享，默认为 <code>false</code></td>
</tr>
<tr>
<td style="text-align:center">contact</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>“联系开发者”按钮</td>
<td>是否在分享菜单中显示“联系开发者”，默认为 <code>true</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">高级参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">action</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | false</code></td>
<td>左上角按钮触发函数</td>
<td>不填时执行返回，设置为 <code>false</code> 会隐藏按钮</td>
</tr>
<tr>
<td style="text-align:center">hidden</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>隐藏导航栏</td>
<td>默认显示导航栏</td>
</tr>
<tr>
<td style="text-align:center">footer</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否显示页脚</td>
<td>默认为 <code>true</code></td>
</tr>
</tbody>
</table>
<h2> 支持的组件</h2>
<p><code>content</code> 的每个元素都为一个对象，该对象会最终渲染为一个组件。</p>
<p>每个配置对象有一个固定的键 <code>tag</code> 来决定渲染的组件。有效的 <code>tag</code> 值及对应的渲染结果如下:</p>
<ul>
<li><a href="#title">title</a>: 标题</li>
<li><a href="#text">text</a>: 文字 (可设置标题与样式)</li>
<li><a href="#p">p</a>: 段落 (可设置标题与样式)</li>
<li><a href="#ol">ol</a>: 有序列表 (可设置标题与样式)</li>
<li><a href="#ul">ul</a>: 无序列表 (可设置标题与样式)</li>
<li><a href="#list">list</a>: 带有跳转功能的列表 (列表项可包含文字、图标、描述)</li>
<li><a href="#img">img</a>: 图片组件 (可附带说明，点击可预览，支持放大与下载)</li>
<li><a href="#doc">doc</a>: 文档组件 (常见文档的查看与下载)</li>
<li><a href="#phone">phone</a>: 电话组件 (支持拨打电话与快速保存联系人)</li>
<li><a href="#copy">copy</a>: 复制组件 (快速复制指定文字)</li>
<li><a href="#account">account</a>: 账号组件 (用于主体 Logo、网址、媒体号、口号展示)</li>
<li><a href="#location">location</a>: 地理位置组件 (用于在地图上展示地点，提供地点详情与导航)</li>
<li><a href="#carousel">carousel</a>: 图片轮播图</li>
<li><a href="#card">card</a>: 卡片组件 (卡片形式，可跳转到指定页面、打开公众号图文或复制链接)</li>
<li><a href="#grid">grid</a>: 九宫格 (分类展示与跳转)</li>
<li><a href="#media">media</a>: 媒体组件 (展示音频和视频)</li>
<li><a href="#functional-list">functional-list</a>: 功能列表 (可展示滑块、开关、选择器、按钮，可调用自定义函数、微信原生功能)</li>
</ul>
<h2> title</h2>
<p>标题</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>大标题文字</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>高级参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>style</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | Record&lt;string, string&gt;</code></td>
<td>标题 css 样式</td>
<td></td>
</tr>
</tbody>
</table>
<h2> text</h2>
<p>文字块，可设置标题与样式</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>heading</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | boolean</code></td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string | string[]</code></td>
<td>文字内容</td>
<td></td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>'tip' | 'warn' | 'danger' | 'info' | 'none'</code></td>
<td>文字块样式</td>
<td>默认为 <code>'none'</code></td>
</tr>
<tr>
<td>align</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>'left' | 'right' | 'center' | 'justify'</code></td>
<td>段落对齐方式</td>
<td>默认为 <code>'justify'</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>高级参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>style</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | Record&lt;string, string&gt;</code></td>
<td>段落文字样式</td>
<td>填入 css 样式，会对段落的默认样式进行覆盖，该样式不会影响到标题</td>
</tr>
</tbody>
</table>
<h2> p</h2>
<p>段落，可设置标题与样式</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>heading</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | boolean</code></td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string | string[]</code></td>
<td>段落文字内容</td>
<td></td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>'tip' | 'warn' | 'danger' | 'info'</code></td>
<td>文字块样式</td>
<td>不填无额外样式</td>
</tr>
<tr>
<td>path</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>对应页面的路径</td>
<td>仅设置 <code>type</code> 时可用</td>
</tr>
<tr>
<td>align</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>'left' | 'right' | 'center' | 'justify'</code></td>
<td>段落对齐方式</td>
<td>默认为 <code>'justify'</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>高级参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>style</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | Record&lt;string, string&gt;</code></td>
<td>段落文字样式</td>
<td>填入 css 样式，会对段落的默认样式进行覆盖，该样式不会影响到标题</td>
</tr>
</tbody>
</table>
<h2> ul</h2>
<p>无序列表，可设置标题与样式</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>heading</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | boolean</code></td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string | string[]</code></td>
<td>无序列表项文字内容</td>
<td></td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>'tip' | 'warn' | 'danger' | 'info'</code></td>
<td>文字块样式</td>
<td>不填无额外样式</td>
</tr>
<tr>
<td>path</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>对应页面的路径</td>
<td>仅设置 <code>type</code> 时可用</td>
</tr>
<tr>
<td>align</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>'left' | 'right' | 'center' | 'justify'</code></td>
<td>段落对齐方式</td>
<td>默认为 <code>'justify'</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>高级参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>style</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | Record&lt;string, string&gt;</code></td>
<td>段落文字样式</td>
<td>填入 css 样式，会对段落的默认样式进行覆盖，该样式不会影响到标题</td>
</tr>
</tbody>
</table>
<h2> ol</h2>
<p>有序列表，可设置标题与样式</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>heading</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | boolean</code></td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string | string[]</code></td>
<td>有序列表项文字内容</td>
<td></td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>'tip' | 'warn' | 'danger' | 'info'</code></td>
<td>文字块样式</td>
<td>不填无额外样式</td>
</tr>
<tr>
<td>path</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>对应页面的路径</td>
<td>仅设置 <code>type</code> 时可用</td>
</tr>
<tr>
<td>align</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>'left' | 'right' | 'center' | 'justify'</code></td>
<td>段落对齐方式</td>
<td>默认为 <code>'justify'</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>高级参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>style</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | Record&lt;string, string&gt;</code></td>
<td>段落文字样式</td>
<td>填入 css 样式，会对段落的默认样式进行覆盖，该样式不会影响到标题</td>
</tr>
</tbody>
</table>
<h2> list</h2>
<p>带有跳转功能的列表，列表项可包含文字、图标、描述</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | boolean</code></td>
<td>头部标题</td>
<td>不填会在标题所在处留空占位，设置为 <code>false</code> 来取消留空占位</td>
</tr>
<tr>
<td>footer</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>尾部标题</td>
<td></td>
</tr>
<tr>
<td>items</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>SimpleList[]</code></td>
<td>列表内容</td>
<td></td>
</tr>
</tbody>
</table>
<p>列表每一项参数如下:</p>
<h3> 通用参数</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>icon</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>列表图标的简称或在线网址</td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>列表项文字</td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>列表项描述，显示在尾部</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>指向配置文件页面</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>path</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>对应配置文件的相对或绝对路径(不带后缀名)，以 <code>/</code> 结尾默认为 <code>index</code></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>指向程序内页面</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>列表指向的界面路径或短名称，可带参数</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2> img</h2>
<p>图片组件，可附带说明。点击可预览、支持放大与下载。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>图片地址</td>
<td></td>
</tr>
<tr>
<td>res</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>图片预览地址</td>
<td>预览时需要高清图片的时候使用</td>
</tr>
<tr>
<td>lazy</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>图片懒加载</td>
<td>默认执行，设置 <code>false</code> 取消</td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>图片的描述文字</td>
<td>填入后会自动最前加入一个三角号，不填则没有描述文字</td>
</tr>
<tr>
<td>imgmode</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>图片显示模式</td>
<td>默认为 <code>'widthFix'</code></td>
</tr>
</tbody>
</table>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p>图片懒加载是指只有图片滚动到页面显示区域才开始加载图片。</p>
</div>
<h2> doc</h2>
<p>文档组件，支持查看与下载</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>文档名称</td>
<td></td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>文档在线路径</td>
<td></td>
</tr>
<tr>
<td>header</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>组件标题</td>
<td></td>
</tr>
<tr>
<td>downloadable</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>该文档是否可下载</td>
<td>默认为 <code>true</code></td>
</tr>
</tbody>
</table>
<div class="hint-container info">
<p class="hint-container-title">支持情况</p>
<p>仅支持 doc、docx、ppt、pptx、xls、xlsx、pdf、jpg、jpeg、png、gif。</p>
</div>
<h2> phone</h2>
<p>电话组件，支持拨打电话与快速保存联系人。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>num</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string | number</code></td>
<td>联系人电话号码</td>
</tr>
<tr>
<td>header</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>组件标题</td>
</tr>
<tr>
<td>fName</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的名</td>
</tr>
<tr>
<td>lName</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的姓</td>
</tr>
<tr>
<td>org</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人所在公司</td>
</tr>
<tr>
<td>remark</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的备注</td>
</tr>
<tr>
<td>workNum</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | number</code></td>
<td>联系人的工作电话</td>
</tr>
<tr>
<td>hostNum</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | number</code></td>
<td>联系人的公司电话</td>
</tr>
<tr>
<td>homeNum</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | number</code></td>
<td>联系人的住宅电话</td>
</tr>
<tr>
<td>nick</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的昵称</td>
</tr>
<tr>
<td>avatar</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人头像图片路径(仅限本地路径)</td>
</tr>
<tr>
<td>title</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的职位</td>
</tr>
<tr>
<td>site</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的网站</td>
</tr>
<tr>
<td>mail</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的电子邮件</td>
</tr>
<tr>
<td>wechat</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的微信号</td>
</tr>
<tr>
<td>province</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的地址省份</td>
</tr>
<tr>
<td>city</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的地址城市</td>
</tr>
<tr>
<td>street</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>联系人的地址街道</td>
</tr>
<tr>
<td>postCode</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | number</code></td>
<td>联系人的地址邮政编码</td>
</tr>
</tbody>
</table>
<h2> action</h2>
<p>动作组件，允许快速复制文字或跳转网页</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>content</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>动作内容</td>
</tr>
<tr>
<td>header</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>可选的组件标题</td>
</tr>
</tbody>
</table>
<h2> account</h2>
<p>介绍组件，用于主体 Logo、网址、媒体号、口号展示。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>主体名称</td>
</tr>
<tr>
<td>logo</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>头像图标在线地址</td>
</tr>
<tr>
<td>detail</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>主体的全称</td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>主体描述</td>
</tr>
<tr>
<td>qq</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>number</code></td>
<td>主体的 QQ 号</td>
</tr>
<tr>
<td>qqid</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>主体的 QQ Openid</td>
</tr>
<tr>
<td>qqcode</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>主体的 QQ 二维码地址</td>
</tr>
<tr>
<td>wxid</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>主体的微信公众号 ID</td>
</tr>
<tr>
<td>wxcode</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>主体的微信二维码地址</td>
</tr>
<tr>
<td>account</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>主体的微信公众号配置文件 ID</td>
</tr>
<tr>
<td>location</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>LocationConfig</code></td>
<td>主体的地址</td>
</tr>
<tr>
<td>site</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>主体的网站地址</td>
</tr>
</tbody>
</table>
<h3> LocationConfig</h3>
<p>地点配置</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>longtidude</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>number</code></td>
<td>经度</td>
</tr>
<tr>
<td>latitude</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>number</code></td>
<td>维度</td>
</tr>
</tbody>
</table>
<h2> location</h2>
<p>位置组件，用于在地图上显示位置并允许详情与导航。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>位置展示的内容</td>
<td></td>
</tr>
<tr>
<td>points</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>Point[]</code></td>
<td>展示地点</td>
<td>数组的每个元素对应一个地点</td>
</tr>
<tr>
<td>navigate</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>false</code></td>
<td>是否允许导航</td>
<td>仅在企业主体微信小程序上可用</td>
</tr>
</tbody>
</table>
<h3> Point</h3>
<p>点位配置</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>longtidude</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>number</code></td>
<td>经度</td>
<td></td>
</tr>
<tr>
<td>latitude</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>number</code></td>
<td>维度</td>
<td></td>
</tr>
<tr>
<td>name</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>点位名称</td>
<td>默认同 <code>title</code></td>
</tr>
<tr>
<td>detail</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>点位详情文字</td>
<td>默认为 <code>详情</code></td>
</tr>
<tr>
<td>path</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>地点详情路径</td>
<td>基于 <code>function/map</code></td>
</tr>
</tbody>
</table>
<h2> carousel</h2>
<p>轮播图</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>images</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string[]</code></td>
<td>展示的图片地址</td>
<td>将所有图片按顺序设置为数组元素</td>
</tr>
<tr>
<td>fill</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>组件是否填满屏幕宽度</td>
<td>默认为 <code>false</code></td>
</tr>
<tr>
<td>indicatorDots</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否显示面板指示点</td>
<td>默认显示，设置 <code>false</code> 取消</td>
</tr>
<tr>
<td>dotColor</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>指示点颜色</td>
<td>默认为<code>#ffffff88</code></td>
</tr>
<tr>
<td>autoplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>自动切换</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>interval</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>number</code></td>
<td>自动切换时间间隔</td>
<td>默认为 <code>5000</code></td>
</tr>
<tr>
<td>duration</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>number</code></td>
<td>滑动动画时长</td>
<td>默认为 <code>500</code></td>
</tr>
<tr>
<td>circular</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否衔接滑动</td>
<td>默认为 <code>true</code></td>
</tr>
<tr>
<td>vertical</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>滑动方向是否纵向</td>
<td>默认为 <code>false</code></td>
</tr>
<tr>
<td>imgmode</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>carousel 中图片的显示模式</td>
<td>默认为 <code>aspectFill</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>高级参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>carousel 项目的类名</td>
<td>默认为 <code>width:100%;height:400rpx;</code></td>
</tr>
<tr>
<td>style</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>carousel 项目的样式</td>
<td>填入 css 样式</td>
</tr>
<tr>
<td>imgClass</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>carousel 中图片的类名</td>
<td>默认为 <code>width:100%!important;height:100%!important;</code></td>
</tr>
<tr>
<td>preMargin</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>前一项露出边距</td>
<td>默认为 <code>0px</code>，接受 px 和 rpx 值</td>
</tr>
<tr>
<td>nextMargin</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>后一项露出边距</td>
<td>默认为 <code>0px</code>，接受 px 和 rpx 值</td>
</tr>
<tr>
<td>change</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>carousel 改变时触发的函数名称</td>
<td>默认不触发函数</td>
</tr>
<tr>
<td>animation</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>carousel 动画结束时触发的函数名称</td>
<td>默认不触发函数</td>
</tr>
</tbody>
</table>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>carousel 组件默认高度为 400rpx，可以通过 style 属性调节</p>
</div>
<h2> card</h2>
<p>卡片组件，可跳转到指定页面、打开公众号图文或复制链接</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>跳转的路径</td>
</tr>
<tr>
<td>src</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>卡片图片地址</td>
</tr>
<tr>
<td>type</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>'page' | 'web'</code></td>
<td>卡片类型</td>
</tr>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>卡片标题</td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>卡片描述</td>
</tr>
<tr>
<td>logo</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>卡片 logo 地址</td>
</tr>
<tr>
<td>name</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>卡片 logo 名称</td>
</tr>
<tr>
<td>options</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>小程序卡片选项</td>
</tr>
</tbody>
</table>
<h2> grid</h2>
<p>九宫格组件，用于分类展示与跳转</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>九宫格的标题文字</td>
</tr>
<tr>
<td>footer</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>九宫格的尾部文字</td>
</tr>
<tr>
<td>items</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>GridItem[]</code></td>
<td>该数组的每个元素均为一个格子内容</td>
</tr>
</tbody>
</table>
<h3> GridItem</h3>
<p>九宫格项目配置</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>icon</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>九宫格的图标的简称或在线网址</td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>九宫格文字</td>
</tr>
<tr>
<td>color</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>'blue' | 'orange' | 'red' | 'purple' | 'cyan' | 'olive' | 'mauve' | 'grey'</code></td>
<td>Android 主题下的颜色</td>
</tr>
<tr>
<td>name</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>对应的英文文字</td>
</tr>
<tr>
<td>path</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>对应配置文件的相对或绝对路径(不带后缀名)，以 <code>/</code> 结尾默认为 <code>index</code></td>
</tr>
<tr>
<td>url</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>列表指向的界面路径或短名称，可带参数</td>
</tr>
</tbody>
</table>
<h2> media</h2>
<p>媒体组件，可展示音频和视频。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>type</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>'audio' | 'video'</code></td>
<td>媒体类型</td>
<td></td>
</tr>
<tr>
<td>src</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>媒体文件地址</td>
<td></td>
</tr>
<tr>
<td>loop</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否循环播放</td>
<td>默认为 <code>false</code></td>
</tr>
<tr>
<td>controls</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>显示默认控件</td>
<td>默认为 <code>true</code></td>
</tr>
</tbody>
</table>
<h3> audio</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>音频名字</td>
<td>controls 为 <code>false</code> 时无效</td>
</tr>
<tr>
<td>author</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>音频作者</td>
<td>controls 为 <code>false</code> 时无效</td>
</tr>
</tbody>
</table>
<h3> video</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>poster</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>视频封面的图片网络资源地址</td>
<td>controls 为 <code>false</code> 时无效</td>
</tr>
<tr>
<td>autoplay</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否自动播放</td>
<td>默认为 <code>false</code></td>
</tr>
<tr>
<td>startTime</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>number</code></td>
<td>视频初始播放位置</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>高级参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>danmu-list</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>Object Array</code></td>
<td>弹幕列表</td>
<td></td>
</tr>
<tr>
<td>danmu-btn</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否显示弹幕按钮</td>
<td>只在初始化有效</td>
</tr>
</tbody>
</table>
<h2> functional-list</h2>
<p>生成一个功能列表，可展示滑块、开关、选择器、按钮，可调用自定义函数、微信原生功能。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>header</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string | boolean</code></td>
<td>头部标题</td>
<td>不填会在标题所在处留空占位，设置为 <code>false</code> 来取消留空占位</td>
</tr>
<tr>
<td>footer</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>结尾标题</td>
<td></td>
</tr>
<tr>
<td>content</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>FunctionalList[]</code></td>
<td>列表内容</td>
<td></td>
</tr>
</tbody>
</table>
<h2> FunctionalList</h2>
<p>功能列表每一项参数</p>
<h3> AdvancedList 通用参数</h3>
<p>下面参数是通用于每一个选项的参数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>icon</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>列表图标的本地路径或在线网址</td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>列表单元的显示文字</td>
</tr>
<tr>
<td>hidden</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>设置为 <code>true</code> 时隐藏该列表项</td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>列表内容的描述</td>
</tr>
</tbody>
</table>
<h3> 跳转列表</h3>
<ul>
<li>指向资源页面</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>path</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>对应页面的路径</td>
</tr>
</tbody>
</table>
<ul>
<li>指向小程序页面</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>url</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>列表指向的页面路径或短名称</td>
</tr>
</tbody>
</table>
<h3> 原生能力</h3>
<p>设置 <code>type</code> 为 <code>'navigator'</code> 使用微信 navigator 的原生能力。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>openType</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>小程序提供的开放能力</td>
</tr>
<tr>
<td>target</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>跳转目标</td>
</tr>
</tbody>
</table>
<h3> 开关</h3>
<p>设置 <code>type</code> 为 <code>'switch'</code> 渲染一个开关。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>所控变量在 storage 中的 key 值</td>
<td></td>
</tr>
<tr>
<td>handler</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>开关对应的函数名称</td>
<td>不填仅改变 storage 中 swiKey 的值</td>
</tr>
<tr>
<td>color</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>开关颜色</td>
<td>同 css 的 color 填入 rgb 代码</td>
</tr>
</tbody>
</table>
<h3> 选择器</h3>
<p>设置 <code>type</code> 为 <code>'picker'</code> 渲染一个选择器。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>Value[]</code></td>
<td>选择器中包含的值</td>
<td></td>
</tr>
<tr>
<td>key</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>选择器所改变的变量在本地存储中的名称</td>
<td></td>
</tr>
<tr>
<td>handler</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>picker 选择器对应的函数名称</td>
<td>不填仅改变界面显示值与 storage 中 key 的值</td>
</tr>
<tr>
<td>single</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>设置 <code>true</code> 时为单列选择器</td>
<td>默认为多列选择器</td>
</tr>
<tr>
<td>inlay</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否为嵌入式 picker</td>
<td>默认为 <code>false</code>，弹出式 picker</td>
</tr>
</tbody>
</table>
<h3> 按钮</h3>
<p>设置 <code>type</code> 为 <code>'button'</code> 渲染一个自定义按钮。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>handler</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>按钮函数名</td>
<td>填入按钮点击后触发的函数名</td>
</tr>
<tr>
<td>disabled</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否禁用按钮</td>
<td>默认为 <code>false</code> (不禁用)，一般仅供开发界面时使用</td>
</tr>
</tbody>
</table>
<h3> 滑块</h3>
<p>设置 <code>type</code> 为 <code>'slider'</code> 渲染一个自定义滑块。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>key</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>滑块 Key 值</td>
<td>滑块所控变量在 storage 中的 key 值</td>
</tr>
<tr>
<td>handler</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>滑块对应的的函数名称</td>
<td>不填仅改变界面显示值与 storage 中 key 的值</td>
</tr>
<tr>
<td>min</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>number</code></td>
<td>滑块的最小值</td>
<td>默认为 <code>0</code></td>
</tr>
<tr>
<td>max</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>number</code></td>
<td>滑块的最大值</td>
<td>默认为 <code>100</code></td>
</tr>
<tr>
<td>step</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>number</code></td>
<td>滑块的步长</td>
<td>默认为 <code>1</code></td>
</tr>
</tbody>
</table>
<h2> 其他参数</h2>
<h3> imgmode</h3>
<ul>
<li>widthFix: 宽度不变，高度自动变化，保持原图宽高比不变;</li>
<li>scaleToFill: 保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素；</li>
<li>aspectFit: 保持纵横比缩放图片，使图片的长边能完全显示出来；</li>
<li>aspectFill: 保持纵横比缩放图片，只保证图片的短边能完全显示出来；</li>
<li>top: 不缩放图片，只显示图片的顶部区域；</li>
<li>bottom: 不缩放图片，只显示图片的底部区域；</li>
<li>center: 不缩放图片，只显示图片的中间区域；</li>
<li>left: 不缩放图片，只显示图片的左边区域；</li>
<li>right: 不缩放图片，只显示图片的右边区域；</li>
<li>top left: 不缩放图片，只显示图片的左上边区域；</li>
<li>top right: 不缩放图片，只显示图片的右上边区域；</li>
<li>bottom left: 不缩放图片，只显示图片的左下边区域；</li>
<li>bottom right: 不缩放图片，只显示图片的右下边区域；</li>
</ul>
<h2> popup</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:center">必填</th>
<th style="text-align:center">值类型</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>title</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>主标题</td>
</tr>
<tr>
<td>subtitle</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>副标题</td>
</tr>
<tr>
<td>text</td>
<td style="text-align:center">是</td>
<td style="text-align:center"><code>string</code></td>
<td>弹窗文字</td>
</tr>
<tr>
<td>desc</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>弹窗文字解释</td>
</tr>
<tr>
<td>more</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean</code></td>
<td>是否显示更多按钮，默认为 <code>false</code></td>
</tr>
<tr>
<td>confirm</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>string</code></td>
<td>确定按钮文字，默认为 <code>'确定'</code></td>
</tr>
<tr>
<td>cancel</td>
<td style="text-align:center">否</td>
<td style="text-align:center"><code>boolean | string</code></td>
<td>取消按钮文字，默认为 <code>'取消'</code>，设置为 <code>false</code> 来隐藏取消按钮</td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://img.shields.io/badge/版本-V5-blue.svg?style=for-the-badge" type="image/"/>
    </item>
    <item>
      <title>小程序指南</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/guide/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/guide/</guid>
      <source url="https://leijue222.github.io/rss.xml">小程序指南</source>
      <description>目录 文件结构 (file-structure.md); 运行环境 (env.md); 小程序配置 (config/README.md); 全局配置 (config/app-config.md); 页面配置 (config/page-config.md); sitemap 配置 (config/sitemap-config.md); 小程序框架 (fr...</description>
      <category>小程序</category>
      <pubDate>Mon, 25 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 目录</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/file-structure.html" target="blank">文件结构</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/env.html" target="blank">运行环境</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/config/" target="blank">小程序配置</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/config/app-config.html" target="blank">全局配置</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/config/page-config.html" target="blank">页面配置</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/config/sitemap-config.html" target="blank">sitemap 配置</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/" target="blank">小程序框架</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/intro.html" target="blank">框架介绍</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/scene.html" target="blank">场景值</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/env.html" target="blank">运行环境</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/mechanism.html" target="blank">运行机制</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/frame/update.html" target="blank">更新机制</a> </p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/" target="blank">逻辑层</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/lifetime.html" target="blank">生命周期</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/route.html" target="blank">路由</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/register.html" target="blank">注册</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/app.html" target="blank">App()</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/page.html" target="blank">Page()</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/run.html" target="blank">运行</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/module.html" target="blank">模块化</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/service/api/" target="blank">API</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/" target="blank">视图层</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxml.html" target="blank">WXML</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/data-bind.html" target="blank">数据绑定</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/condition-render.html" target="blank">条件渲染</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/list-render.html" target="blank">列表渲染</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/template.html" target="blank">模板</a></p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxss.html" target="blank">WXSS</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxs.html" target="blank">WXS</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/event.html" target="blank">事件</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/component.html" target="blank">基础组件</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/animation.html" target="blank">动画</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxs.html" target="blank">WXS</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/wxs-event.html" target="blank">WXS 事件</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/model.html" target="blank">建议双向绑定</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/selector.html" target="blank">获取界面上的节点信息</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/selector.html" target="blank">相应显示区域变化</a> </p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/view/rendering-cache.html" target="blank">初始渲染缓存</a> </p>
</li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/" target="blank">小程序能力</a></p>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/network.html" target="blank">网络请求</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/storage.html" target="blank">存储</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/file-system.html" target="blank">文件系统</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/guide/ability/debug.html" target="blank">调试</a></p>
</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>宿主环境</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/guide/env.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/guide/env.html</guid>
      <source url="https://leijue222.github.io/rss.xml">宿主环境</source>
      <description>宿主环境是微信客户端给小程序所提供的环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>宿主环境是微信客户端给小程序所提供的环境。小程序借助宿主环境提供的能力，可以完成许多普通网页无法完成的功能。</p>
<!-- more -->
<h2> 渲染层和逻辑层</h2>
<p>小程序的运行环境分成渲染层和逻辑层。</p>
<ul>
<li>WXML 模板和 WXSS 样式工作在渲染层；</li>
<li>JS 脚本工作在逻辑层。</li>
</ul>
<p>小程序的渲染层和逻辑层分别由 2 个线程管理:</p>
<ul>
<li>渲染层的界面使用了 WebView 进行渲染；</li>
<li>逻辑层采用 JsCore 线程运行 JS 脚本。</li>
</ul>
<p>一个小程序存在多个界面，所以渲染层存在多个 WebView 线程，这两个线程的通信会经由微信客户端(Native)做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型下图所示。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png" alt="通信模型" loading="lazy"></p>
<h2> 程序与页面</h2>
<p>微信客户端在打开小程序之前，会把整个小程序的代码包下载到本地。</p>
<p>客户端通过 <code>app.json</code> 的 <code>pages</code> 字段获得当前小程序的所有页面路径:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>QuickStart 项目通过该配置定义了两个页面，分别位于 <code>pages/index/index</code> 和 <code>pages/logs/logs</code>。写在 <code>pages</code> 字段的第一个页面就是这个小程序的首页(打开小程序看到的第一个页面)。</p>
</div>
<p>于是微信客户端就把首页的代码装载进来，染出这个首页。</p>
<p>小程序启动之后，在 <code>app.js</code> 定义的 <code>App</code> 实例的 <code>onLaunch</code> 回调会被执行:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整个小程序只有一个 App 实例，是全部页面共享的，更多的事件回调参考文档 <a href="/tutorial/front-end/mini-app/guide/service/app.html" target="blank">注册程序 App</a> 。</p>
<p>接下来我们简单看看小程序的一个页面是怎么写的。</p>
<p>您可以观察到 <code>pages/logs/logs</code> 下其实是包括了 4 种文件的，微信客户端会先根据 <code>logs.json</code> 配置生成一个界面，顶部的颜色和文字您都可以在这个 json 文件里边定义好。紧接着客户端就会装载这个页面的 WXML 结构和 WXSS 样式。最后客户端会装载 <code>logs.js</code>，您可以看到 <code>logs.js</code> 的大体内容就是:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Page 是一个页面构造器，这个构造器就生成了一个页面。在生成页面的时候，小程序框架会把 <code>data</code> 数据和对应的 wxml 一起渲染出最终的结构，于是就得到了您看到的小程序的样子。</p>
<p>在渲染完界面之后，页面实例就会收到一个 <code>onLoad</code> 的回调，您可以在这个回调处理您的逻辑。</p>
<p>有关于 Page 构造器更多详细的文档参考 <a href="/tutorial/front-end/mini-app/guide/service/page.html" target="blank">注册页面 Page</a>。</p>
<h2> 组件</h2>
<p>小程序提供了丰富的基础组件给开发者，开发者可以像搭积木一样，组合各种组件拼合成自己的小程序。</p>
<p>就像 HTML 的 <code>div</code>, <code>p</code> 等标签一样，在小程序里边，您只需要在 WXML 写上对应的组件标签名字就可以把该组件显示在界面上，例如，您需要在界面上显示地图，您只需要这样写即可:</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用组件的时候，还可以通过属性传递值给组件，让组件可以以不同的状态去展现，例如，我们希望地图一开始的中心的经纬度是长春，那么您需要声明地图的 <code>longitude</code>(中心经度) 和 <code>latitude</code>(中心纬度)两个属性:</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>组件的内部行为也会通过事件的形式让开发者可以感知，例如用户点击了地图上的某个标记，您可以在 js 编写 markertap 函数来处理:</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当然您也可以通过 <code>style</code> 或者 <code>class</code> 来控制组件的外层样式，以便适应您的界面宽度高度等等。</p>
<h2> API</h2>
<p>为了让开发者可以很方便的调起微信提供的能力，例如获取用户信息、微信支付等等，小程序提供了很多 API 给开发者去使用。</p>
<p>要获取用户的地理位置时，只需要:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用微信扫一扫能力，只需要:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需要注意的是: 多数 API 的回调都是异步，您需要处理好代码逻辑的异步问题。</p>
<p>更多的 API 能力见 <a href="https://developers.weixin.qq.com/miniprogram/dev/api/" target="_blank" rel="noopener noreferrer">小程序的 API</a>。</p>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/4-1.ad156d1c.png" type="image/png"/>
    </item>
    <item>
      <title>代码构成</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/guide/file-structure.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/guide/file-structure.html</guid>
      <source url="https://leijue222.github.io/rss.xml">代码构成</source>
      <description>文件组成 小程序的代码由四种文件组成: .json 后缀的 JSON 配置文件，主要用作小程序配置; .wxml 后缀的 WXML 模板文件，为视图层，相当于 HTML; .wxss 后缀的 WXSS 样式文件，为样式部分，相当于 CSS; .js 后缀的 JS 脚本逻辑文件，为脚本部分，处理小程序逻辑与行为; 目录结构 小程序包含一个描述整体程序的 ...</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 文件组成 </h2>
<p>小程序的代码由四种文件组成:</p>
<ul>
<li><code>.json</code> 后缀的 JSON 配置文件，主要用作小程序配置</li>
<li><code>.wxml</code> 后缀的 WXML 模板文件，为视图层，相当于 HTML</li>
<li><code>.wxss</code> 后缀的 WXSS 样式文件，为样式部分，相当于 CSS</li>
<li><code>.js</code> 后缀的 JS 脚本逻辑文件，为脚本部分，处理小程序逻辑与行为</li>
</ul>
<h2> 目录结构 </h2>
<p>小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。</p>
<p>一个小程序主体部分由三个文件组成，必须放在项目的根目录:</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>app.js</td>
<td>是</td>
<td>小程序逻辑</td>
</tr>
<tr>
<td>app.json</td>
<td>是</td>
<td>小程序公共配置</td>
</tr>
<tr>
<td>app.wxss</td>
<td>否</td>
<td>小程序公共样式表</td>
</tr>
</tbody>
</table>
<p>一个小程序页面由四个文件组成:</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>必需</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>js</td>
<td>是</td>
<td>页面逻辑</td>
</tr>
<tr>
<td>wxml</td>
<td>是</td>
<td>页面结构</td>
</tr>
<tr>
<td>json</td>
<td>否</td>
<td>页面配置</td>
</tr>
<tr>
<td>wxss</td>
<td>否</td>
<td>页面样式表</td>
</tr>
</tbody>
</table>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。</p>
<p>这样开发者工具会自动将它们视作一个小程序页面的不同代码部分。</p>
</div>
<h3> 允许上传的文件 </h3>
<p>见页脚<sup class="footnote-ref"><a href="#footnote1">[1]</a><a class="footnote-anchor" id="footnote-ref1"></a></sup></p><a class="footnote-anchor" id="footnote-ref1">
</a><h2><a class="footnote-anchor" id="footnote-ref1"></a> JSON 配置</h2>
<p>JSON 是一种数据格式，<strong>在小程序中，JSON 负责描述小程序的静态配置，负责配置项目、小程序整体和每个页面。</strong></p>
<p>我们可以看到在项目的根目录有一个 <code>app.json</code> 和 <code>project.config.json</code>，此外在 <code>pages/logs</code> 目录下还有一个 <code>logs.json</code>。下面是它们的用途说明。</p>
<h3> 小程序配置 app.json </h3>
<p>app.json 是当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的 app.json 配置内容如下:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p><code>pages</code> 字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前您的小程序页面定义在哪个目录。</p>
</li>
<li>
<p><code>window</code> 字段 —— 定义小程序所有页面的顶部背景颜色，文字颜色定义等。</p>
</li>
</ul>
<p>其他配置项可以参考文档 <a href="/tutorial/front-end/mini-app/guide/config/app-config.html" target="blank">全局配置</a>。</p>
<h3> 页面配置 page.json </h3>
<p>这里的 <code>page.json</code> 其实用来表示小程序页面相关的配置。</p>
<p>如果您整个小程序的风格是蓝色调，那么您可以在 <code>app.json</code> 里边声明顶部颜色是蓝色即可。实际您可能希望小程序里边的每个页面都有不一样的色调来区分不同功能模块，<code>page.json</code> 就提供了定义每个页面的一些属性的能力。</p>
<p>配置项可以参考文档 <a href="/tutorial/front-end/mini-app/guide/config/page-config.html" target="blank">页面配置</a>。</p>
<h3> 工具配置 project.config.json </h3>
<p>通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当您换了另外一台电脑重新安装工具的时候，您还要重新配置。</p>
<p>考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，您在工具上做的任何配置都会写入到这个文件，当您重新安装工具或者换电脑工作时，您只要载入同一个项目的代码包，开发者工具就自动会帮您恢复到当时您开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。</p>
<p>其他配置项细节可以参考文档 <a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/projectconfig.html" target="_blank" rel="noopener noreferrer">开发者工具的配置</a>。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>更多 JSON 相关教程，请查看 <a href="/tutorial/front-end/language/json/" target="blank">JSON 教程</a></p>
</div>
<h2> WXML 模板 </h2>
<p>在小程序中 WXML 充当的就是类似 HTML 的角色。打开 <code>pages/index/index.wxml</code>，您会看到以下的内容:</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和 HTML 非常相似，WXML 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下:</p>
<ul>
<li>
<p>自己的一套标签名称</p>
<blockquote>
<p>e.g.: 小程序把最常见的 <code>&lt;span /&gt;</code> 改成了 <code>&lt;text /&gt;</code>，<code>&lt;div /&gt;</code> 改成了 <code>&lt;view /&gt;</code></p>
</blockquote>
</li>
</ul>
<div v-pre="">
<ul>
<li>多了一些 <code>wx:if</code> 这样的属性以及 <code>{{ }}</code> 这样的表达式</li>
</ul>
</div>
<p>由于小程序不允许用户进行 DOM 操作，所以小程序在编译的时候就要编译好整个的 DOM 结构。</p>
<p>小程序下通过提供动态绑定、条件渲染与循环渲染帮助您去动态改变编译好的 DOM 结构。</p>
<p>更详细的文档可以参考 <a href="/tutorial/front-end/mini-app/guide/view/wxml.html" target="blank">WXML</a> 。</p>
<h2> 动态绑定 </h2>
<p>动态绑定负责把 JS 的变量映射绑定到 WXML 上，也就是说负责把逻辑层的变量显示在视图层的具体位置。</p>
<p>WXML:</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>JS 只需要管理状态即可:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div v-pre="">
<p>通过 <code>{{ }}</code> 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 <code>if</code> / <code>else</code>, <code>for</code> 等控制能力，在小程序里边，这些控制能力都用 <code>wx:</code> 开头的属性来表达。</p>
</div>
<h2> WXSS 样式 </h2>
<p>WXSS 具有 CSS 大部分的特性，也做了一些扩充和修改。</p>
<ul>
<li>
<p>新增了尺寸单位。WXSS 在底层支持新的尺寸单位 rpx ，规定屏幕宽 750 rpx。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。</p>
<p>所以 Mr.Hope 并不建议使用 rpx 单位。</p>
</div>
</li>
<li>
<p>提供了全局的样式和局部样式。</p>
<p>和前边 <code>app.json</code>, <code>page.json</code> 的概念相同，您可以写一个 <code>app.wxss</code> 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 <code>page.wxss</code> 仅对当前页面生效。</p>
</li>
<li>
<p>此外 WXSS 仅支持部分 CSS 选择器</p>
</li>
</ul>
<p>更详细的文档可以参考 <a href="/tutorial/front-end/mini-app/guide/view/wxss.html" target="blank">WXSS</a>。</p>
<h2> JS 逻辑交互 </h2>
<p>小程序仅仅只有界面展示是不够的，还需要和用户做交互: 响应用户的点击、获取用户的位置等等。小程序通过 JS 脚本文件来处理用户的操作。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>点击 button 按钮的时候，我们希望把界面上 <code>msg</code> 显示成 <code>"Hello World"</code>，于是我们在 button 上声明一个属性: <code>bindtap</code> ，在 JS 文件里边声明了 <code>clickMe</code> 方法来响应这次点击操作:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>响应用户的操作就是这么简单，更详细的事件可以参考文档 <a href="/tutorial/front-end/mini-app/guide/view/event.html" target="blank">WXML - 事件</a> 。</p>
<p>此外您还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在 <code>pages/index/index.js</code> 就调用了 <code>wx.getUserInfo</code> 获取微信用户的头像和昵称，最后通过 <code>setData</code> 把获取到的信息显示到界面上。</p>
<p>更多 API 可以参考文档 <a href="/tutorial/front-end/mini-app/guide/service/api/" target="blank">小程序的 API</a> 。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="footnote1" class="footnote-item"><p>在项目目录中，以下文件会经过编译，因此上传之后无法直接访问到: <code>.js</code>、<code>app.json</code>、<code>.wxml</code>、<code>*.wxss</code>(其中 <code>wxml</code> 和 <code>wxss</code> 文件仅针对在 <code>app.json</code> 中配置了的页面)。除此之外，只有后缀名在白名单内的文件可以被上传。具体白名单列表如下:</p>
<ul>
<li>wxs</li>
<li>png</li>
<li>jpg</li>
<li>jpeg</li>
<li>gif</li>
<li>svg</li>
<li>json</li>
<li>cer</li>
<li>mp3</li>
<li>aac</li>
<li>m4a</li>
<li>mp4</li>
<li>wav</li>
<li>ogg</li>
<li>silk</li>
</ul>
 <a href="#footnote-ref1" class="footnote-backref">↩︎</a></li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>工具使用</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/tools/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/tools/</guid>
      <source url="https://leijue222.github.io/rss.xml">工具使用</source>
      <description>工具 工具页面简介 (interface.md); 调试 (debug.md); npm (npm.md); 体验评分 (audit.md);</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 工具</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/mini-app/tools/interface.html" target="blank">工具页面简介</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/tools/debug.html" target="blank">调试</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/tools/npm.html" target="blank">npm</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/mini-app/tools/audit.html" target="blank">体验评分</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>体验评分</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/tools/audit.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/tools/audit.html</guid>
      <source url="https://leijue222.github.io/rss.xml">体验评分</source>
      <description>这是一项给小程序的体验好坏打分的功能，它会在小程序运行过程中实时检查，分析出一些可能导致体验不好的地方，并且定位出哪里有问题，以及给出一些优化建议。</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>这是一项给小程序的体验好坏打分的功能，它会在小程序运行过程中实时检查，分析出一些可能导致体验不好的地方，并且定位出哪里有问题，以及给出一些优化建议。</p>
<!-- more -->
<h2> 使用流程</h2>
<ol>
<li>打开开发者工具，在详情里切换基础库到 2.2.0 或以上版本。</li>
<li>在调试器区域切换到 Audits 面板。</li>
<li>点击”开始“按钮，然后自行操作小程序界面，运行过的页面就会被“体验评分”检测到。</li>
</ol>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/audits_start.8773023b.png" alt="audits_start" loading="lazy"></p>
<ol>
<li>点击 "停止" 则结束检测，在当前面板显示相应的检测报告，开发者可根据报告中的建议对相应功能进行优化。</li>
<li>如需再次运行体验评分，可点击报告上方的“清空体验评分”恢复初始状态。请注意，目前系统不提供报告存储服务，一旦清空体验评分，将无法再查看本次评分结果。</li>
</ol>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/audits_clear.5fb85a1d.png" alt="audits_clear" loading="lazy"></p>
<h2> 自动运行</h2>
<p>为了方便开发者能够及时发现小程序的体验问题，从开发者工具 1.02.1811150 版本起支持体验评分的 “自动运行” 功能。</p>
<p>该功能会在开发调试小程序时，实时检查，一旦发现体验分数低于 70 分时，系统会在 console 面板打印一个 warning 信息提示开发者，此时开发者可以切到 Audits 面板查看详情。</p>
<p>开发者在工具的右上角 “详情” 面板的 本地设置 中勾选 “自动运行体验评分” 选项即可开启。</p>
<p>评分规则
具体的评分细则和详情的规则说明可参考下列文档:</p>
<h2> 评分方法</h2>
<ul>
<li><a href="/tutorial/front-end/mini-app/tools/score.html" target="blank">点击查看</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/audits_start.8773023b.png" type="image/png"/>
    </item>
    <item>
      <title>调试</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/tools/debug.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/tools/debug.html</guid>
      <source url="https://leijue222.github.io/rss.xml">调试</source>
      <description>程序调试主要有三大功能区: 模拟器、调试工具和小程序操作区</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>程序调试主要有三大功能区: 模拟器、调试工具和小程序操作区</p>
<!-- more -->
<h2> 模拟器</h2>
<p>模拟器模拟微信小程序在客户端真实的逻辑表现，对于绝大部分的 API 均能够在模拟器上呈现出正确的状态。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/simulator.eae9f1b6.png" alt="Debug" loading="lazy"></p>
<h2> 自定义编译</h2>
<p>点击工具栏中的编译按钮或者使用快捷键 Ctrl(⌘) + B，可以编译当前代码，并自动刷新模拟器。</p>
<p>同时为了帮助开发者调试从不同场景值进入具体的页面，开发者可以添加或选择已有的自定义编译条件进行编译和代码预览(如图)。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/customcompile.e2f5a7ad.png" alt="Condition" loading="lazy"></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>编译条件跟项目相关，写在 <code>package.config.json</code> 中。每个项目可以保存自己相关的编译条件</p>
</div>
<h2> 编译异常信息</h2>
<p>在预览或上传的过程中，可能会出现编译异常信息。</p>
<ul>
<li>
<p>忽略上传的文件: 在项目文件夹下，某些文件可能不是小程序运行所需的，例如 readme 文档、.gitignore 文件等。为了优化大小，在预览和上传的过程中，这些文件将不会被打包。</p>
</li>
<li>
<p>体积过大的文件: 如果勾选了 ES6 转 ES5 或代码压缩的选项，为了优化编译速度，对于某些体积很大的 JS 文件，工具会跳过对这些文件的处理。</p>
</li>
</ul>
<h2> 自定义预处理</h2>
<p>在项目设置页卡，我们提供了以下几个默认的预处理，可以解决大部分的代码文件预处理的问题</p>
<ol>
<li>ES6 转 ES5(可以应用于编译、预览、上传)，使用 "babel-core": "^6.26.0"</li>
<li>上传代码时样式自动补全，使用 "postcss": "^6.0.1"</li>
<li>上传代码时自动压缩，使用 "uglify-js": "3.0.27"</li>
</ol>
<p>对于高级开发者来说，完全可以自己编写自动化构建脚本对代码文件进行预处理，所以我们提供了 <code>启用自定义处理命令</code> 选项 开发者可以指定 <code>编译前/预览前/上传前</code> 需要预处理的命令 开发者工具使用 shell 的方式运行指定的命令，并在控制台中输出命令的执行日志</p>
<p>预处理命令的执行顺序</p>
<ol>
<li>自定义预处理命令</li>
<li>默认预处理命令</li>
<li>编译/预览/上传</li>
</ol>
<p>注:</p>
<ol>
<li>编译前预处理命令，需要手动点击 "编译" 按钮，或者使用快捷键编译才能触发。文件修改无法触发该命令。</li>
<li>Mac 版本的开发者工具无法复用 bash 中的 Path 环境变量。可能需要手动设置系统的 Path 环境变量，才能正常执行命令。</li>
</ol>
<h2> 前后台切换</h2>
<p>工具栏中前后台切换帮助开发者模拟一些客户端的环境操作。例如当用户从小程序中回到聊天窗口，会触发一个小程序被设置为后台的回调。</p>
<h2> 调试工具</h2>
<p>调试工具分为 7 大功能模块: Wxml、Console、Sources、Network、Appdata、Storage、Sensor、Trace</p>
<h3> Wxml panel</h3>
<p>Wxml panel 用于帮助开发者开发 wxml 转化后的界面。在这里可以看到真实的页面结构以及结构对应的 wxss 属性，同时可以通过修改对应 wxss 属性，在模拟器中实时看到修改的情况(仅为实时预览，无法保存到文件)。通过调试模块左上角的选择器，还可以快速定位页面中组件对应的 wxml 代码。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/wxml.17f54a04.gif" alt="WXML" loading="lazy"></p>
<h3> Sources panel</h3>
<p>Sources panel 用于显示当前项目的脚本文件，同浏览器开发不同，微信小程序框架会对脚本文件进行编译的工作，所以在 Sources panel 中开发者看到的文件是经过处理之后的脚本文件，开发者的代码都会被包裹在 define 函数中，并且对于 Page 代码，在尾部会有 require 的主动调用。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/source.052d621d.png" alt="source" loading="lazy"></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>当代码运行到断点的时候，整个小程序都停止了，所以模拟器会出现白屏或者无法操作的情况</p>
</div>
<h3> AppData panel</h3>
<p>AppData panel 用于显示当前项目运行时小程序 AppData 具体数据，实时地反映项目数据情况，可以在此处编辑数据，并及时地反馈到界面上。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/appdata.f6dd7efb.gif" alt="appdata" loading="lazy"></p>
<h3> Storage panel</h3>
<p>Storage panel 用于显示当前项目使用 wx.setStorage 或者 wx.setStorageSync 后的数据存储情况。</p>
<p>可以直接在 Storage panel 上对数据进行删除(按 delete 键)、新增、修改</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/storage.07560615.gif" alt="storage" loading="lazy"></p>
<h3> Network panel</h3>
<p>Network Panel 用于观察和显示 request 和 socket 的请求情况</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/network.cc726875.png" alt="network" loading="lazy"></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>uploadFile 和 downloadFile 暂时不支持在 Network Panel 中查看</p>
</div>
<h3> Console panel</h3>
<p>Console panel 有两大功能:</p>
<ul>
<li>
<p>开发者可以在此输入和调试代码</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/console.a0ddb28e.gif" alt="console" loading="lazy"></p>
</li>
<li>
<p>小程序的错误输出，会显示在此处</p>
</li>
<li>
<p>在控制台中可以输入以下命令</p>
<ul>
<li>
<p>build: 编译小程序</p>
</li>
<li>
<p>preview: 预览</p>
</li>
<li>
<p>upload: 上传代码</p>
</li>
<li>
<p>openVendor: 打开基础库所在目录</p>
</li>
<li>
<p>openToolsLog: 打开工具日志目录</p>
</li>
<li>
<p>checkProxy(url): 检查指定 URL 的代理使用情况</p>
</li>
</ul>
</li>
</ul>
<h3> Sensor panel</h3>
<p>Sensor panel 有两大功能:</p>
<ul>
<li>
<p>开发者可以在这里选择模拟地理位置</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/location.78d3b40d.gif" alt="location" loading="lazy"></p>
</li>
<li>
<p>开发可以在这里模拟移动设备表现，用于调试重力感应 API</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/accelerometerchange.537b68c8.gif" alt="accelerometerchange" loading="lazy"></p>
</li>
</ul>
<h2> 自定义数据上报</h2>
<p>开发者工具上可以编辑和调试自定义分析的数据上报功能，点击菜单栏中的 “工具 - 自定义分析” 即可弹窗打开自定义分析:</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/event_list.011e466a.png" alt="event_list" loading="lazy"></p>
<p>在页面中可以新建、查看或修改事件，在修改事件的页面中编辑完毕后，点击底部的保存并测试按钮将保存当前配置，同时工具将在调试器上提示收到最新配置，并展示配置信息，展示的内容包括事件的 ID 和名称，以及每个动作的触发条件和上报数据:</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/begin_test.52222154.png" alt="begin_test" loading="lazy"></p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/on_app_config.5338b60e.png" alt="on_app_config" loading="lazy"></p>
<p>接着可以在模拟器中操作和触发事件。在模拟器中刷新小程序也将获取该测试配置，除非窗口被关闭。窗口关闭后模拟器不会再收到配置。当事件被触发上报时，工具上会展示上报信息，包括事件 ID、触发页面、触发方式、触发时动作、以及上报的字段值和数据:</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/report_ide.9358e199.png" alt="report_ide" loading="lazy"></p>
<p>同时可以在窗口中点击 “同步结果” 会同步显示上报的数据:</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/report_mp.af47c41c.png" alt="report_mp" loading="lazy"></p>
<p>关闭窗口后，配置将全部失效，模拟器不再收到配置并不再触发上报(小程序中使用 wx.reportAnalytics API 进行的数据上报仍会在工具中输出)。测试成功后，可到小程序后台发布事件配置，即可正式生效收集所定义的事件数据。</p>
<h2> 自动预览</h2>
<p>自动预览可以实现编写小程序时快速预览，免去了每次查看小程序效果时都要扫码或者使用小程序助手的麻烦。只需按下快捷键，保持前台运行的微信即可自动唤出或刷新小程序。</p>
<p>要使用自动预览功能，需要配合 6.6.7 及以上的微信客户端版本。</p>
<p>要开始使用 “自动预览” 功能，可以在打开预览二维码的时候，点击 “自动预览” 标签以切换到自动预览模式。切换到自动预览模式后，只需按下预览快捷键，或者点击浮窗上的 “编译并预览” 按钮，即可触发自动预览。此时工具会上传代码，保持前台运行的微信客户端会自动刷新当前开发的小程序。</p>
<p>当自动预览成功时，工具栏上的预览图标会显示为一个绿勾。如果预览出错，则会显示为一个红色惊叹号，可以点击查看详情。</p>
<p>注意，自动预览功能仅限与登陆开发者工具的同帐号微信使用。如需换回普通预览模式，只需要点击 “扫描二维码预览” 标签即可。</p>
<p>用户可以在快捷键设置里自定义预览快捷键。</p>
<h2> Source Map</h2>
<blockquote>
<p>目前只在 iOS 6.7.2 及以上版本支持</p>
</blockquote>
<p>小程序打包时，会将所有 js 代码打包成一个文件，为了便于开发者在手机上调试时定位错误位置，小程序提供了 Source Map 支持。</p>
<p>在开发者工具中开启 ES6 转 ES5、代码压缩时，会生成 Source Map 的 .map 文件。开发版小程序中，基础库会使用代码包中的 .map 文件，对 vConsole 中展示的错误信息堆栈进行重新映射(只对开发者代码文件进行)。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/sourceMap.17b75816.jpg" alt="sourceMap" loading="lazy"></p>
<p>如果使用外部的编译脚本对源文件进行处理，只需将对应生成的 Source Map 文件放置在源文件的相同目录下</p>
<p>开发者工具会读取、解析 Source Map 文件，并进行将其上传</p>
<p>后续可以在小程序后台的运营中心可以利用上传的 Source Map 文件进行错误分析</p>
<ol>
<li>Source Map 文件不计入代码包大小计算。</li>
<li>line source map 不计入代码包大小计算。</li>
<li>开发版代码包中由于包含了 .map 文件，实际代码包大小会比体验版和正式版大。</li>
</ol>
<h2> 真机调试</h2>
<p>真机远程调试功能可以实现直接利用开发者工具，通过网络连接，对手机上运行的小程序进行调试，帮助开发者更好的定位和查找在手机上出现的问题。</p>
<h3> 调试流程</h3>
<p>要发起一个真机远程调试流程，需要先点击开发者工具的工具栏上 “远程调试” 按钮。</p>
<p>此时，工具会将本地代码进行处理打包并上传，就绪之后，使用手机客户端扫描二维码即可弹出调试窗口，开始远程调试。</p>
<h3> 远程调试窗口</h3>
<p>使用手机扫描二维码，即可开始远程调试。</p>
<p>要结束调试，直接关闭此调试窗口，或点击右下角 “结束调试” 按钮即可。</p>
<p>远程调试窗口分为两部分，分别是左侧的调试器视图、右侧的信息视图。开发者可以在调试器里直接进行代码的调试，并查看 Storage 情况；信息视图则可以查看目前与手机和服务器的连接情况，以及发生的错误信息等。</p>
<h3> 调试器</h3>
<p>在远程调试的调试器里，开发者可以在 Console 面板里对代码进行调试，在 Sources 面板里查看小程序的源代码并进行断点单步调试，在 Storage 面板里查看小程序的 Storage 使用情况等。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>要在 Console 里对小程序进行调试，需要将调试的上下文切换到 VM Context 1，如图所示。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/context.182d265d.jpg" alt="context" loading="lazy"></p>
</div>
<p>在 Sources 面板查看源代码时，开发者所有的文件路径都是以 <code>weapp://</code> 开头的。</p>
<p>除了可以在调试器进行单步调试，开发者还能在代码中手动插入 debugger; 语句进行断点调试。因此，如果想要在小程序启动的尽早时刻断点，可以在进入远程调试之前，编辑代码手动在需要断点处的代码插入 debugger; 语句来实现。</p>
<p>WXML、AppData、Storage 面板的操作和开发者工具调试模拟器时的操作一致。注意，如果在右侧信息视图取消勾选了 “使用工具端的 Storage”，则所有的 Storage 数据将被存储在手机上，将不再出现 Storage 面板。</p>
<h3> 信息视图</h3>
<p>右侧的信息视图展示了手机、网络连接的信息。手机信息展示手机的型号、系统、名称、微信版本等信息，以及通信延时。通信延时越小，与手机的通信越流畅。</p>
<p>在 “连接信息” 里，展示了工具与服务器的连接信息，包括了连接状态、服务器状态等，当连接故障、服务器阻塞影响到调试的过程和流畅度时，此处将展示这一状态。当连接状态为 “已结束” 时，表明调试已被终止。</p>
<p>“警告和错误” 展示了最近发生的错误和警告信息。如果网络连接断开，此处将会询问开发者是否需要重新连接。</p>
<h3> 手机端展示</h3>
<p>当手机无网络或者进入了断点状态时，将会出现一个浮层提示并阻止进一步的操作。</p>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/simulator.eae9f1b6.png" type="image/png"/>
    </item>
    <item>
      <title>界面</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/tools/interface.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/tools/interface.html</guid>
      <source url="https://leijue222.github.io/rss.xml">界面</source>
      <description>启动页 登录页 在登录页，可以使用微信扫码登陆开发者工具，开发者工具将使用这个微信帐号的信息进行小程序的开发和调试。 login 项目列表 登录成功后，会看到已经存在的项目列表和代码片段列表， 在项目列表可以选择公众号网页调试，进入到公众号网页调试模式。 project list 新建项目 当符合以下条件时，可以在本地创建一个小程序项目 1. 需要一个...</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 启动页</h2>
<h2> 登录页</h2>
<p>在登录页，可以使用微信扫码登陆开发者工具，开发者工具将使用这个微信帐号的信息进行小程序的开发和调试。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/login.b4162666.png" alt="login" loading="lazy"></p>
<h2> 项目列表</h2>
<p>登录成功后，会看到已经存在的项目列表和代码片段列表，</p>
<p>在项目列表可以选择公众号网页调试，进入到公众号网页调试模式。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/projectlist.aae3a02e.png" alt="project list" loading="lazy"></p>
<h3> 新建项目</h3>
<p>当符合以下条件时，可以在本地创建一个小程序项目</p>
<ol>
<li>需要一个小程序的 AppID；如没有 AppID，可以选择申请使用测试号。</li>
<li>登录的微信号需要是该 AppID 的开发者；</li>
<li>需要选择一个空目录，或者选择的非空目录下存在 <code>app.json</code> 或者 <code>project.config.json</code>。当选择空目录时，可以选择是否在该目录下生成一个简单的项目。</li>
</ol>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/addproject.ec48a6a3.png" alt="New project" loading="lazy"></p>
<h3> 多开项目</h3>
<p>工具支持同时打开多个项目，每次打开项目时会从新窗口打开，入口有以下几种:</p>
<ul>
<li>从项目选择页打开项目，处于项目窗口时可以从菜单栏的项目 -&gt; 查看所有项目打开项目选择页</li>
<li>从菜单栏的最近打开项目列表中打开的项目会从新窗口打开</li>
<li>新建项目</li>
<li>命令行或 HTTP 调用工具打开项目</li>
</ul>
<h3> 管理项目</h3>
<p>对本地项目进行删除和批量删除</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/projectmanage.8cdedbdc.png" alt="manage" loading="lazy"></p>
<h2> 主界面</h2>
<p>开发者工具主界面，从上到下，从左到右，分别为: 菜单栏、工具栏、模拟器、编辑器、调试器 五大部分。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/parts.c8bf6336.png" alt="layout" loading="lazy"></p>
<h3> 菜单栏</h3>
<h4> 微信 Web 开发者工具</h4>
<p>切换帐号: 快速切换登录用户</p>
<p>关于: 关于开发者工具</p>
<p>检查更新: 检查版本更新</p>
<p>开发者论坛: 前往开发者论坛</p>
<p>开发者文档: 前往开发者文档</p>
<p>调试: 调试开发者工具、调试编辑器；如果遇到疑似开发者工具或者编辑器的 bug，可以打开调试工具查看是否有出错日志，欢迎在论坛上反馈相关问题</p>
<p>更换开发模式: 快速切换公众号网页调试和小程序调试</p>
<p>退出: 退出开发者工具</p>
<h4> 项目</h4>
<p>新建项目: 快速新建项目</p>
<p>打开最近: 可以查看最近打开的项目列表，并选择是否进入对应项目</p>
<p>查看所有项目: 新窗口打开启动页的项目列表页</p>
<p>关闭当前项目: 关闭当前项目，回到启动页的项目列表页</p>
<h4> 文件</h4>
<p>新建文件</p>
<p>保存</p>
<p>保存所有</p>
<p>关闭文件</p>
<h4> 编辑: 可以查看编辑相关的操作和快捷键</h4>
<h4> 工具</h4>
<p>编译: 编译当前小程序项目</p>
<p>刷新: 与编译的功能一致，由于历史原因保留对应的快捷键 ctrl(⌘) + R</p>
<p>编译配置: 可以选择普通编译或自定义编译条件</p>
<p>前后台切换: 模拟客户端小程序进入后台运行和返回前台的操作</p>
<p>清除缓存: 清除文件缓存、数据缓存、以及授权数据</p>
<h4> 界面: 控制主界面窗口模块的显示与隐藏</h4>
<h4> 设置</h4>
<p>外观设置: 控制编辑器的配色主题、字体、字号、行距</p>
<p>编辑设置: 控制文件保存的行为，编辑器的表现</p>
<p>代理设置: 选择直连网络、系统代理和手动设置代理</p>
<p>通知设置: 设置是否接受某种类型的通知</p>
<h3> 工具栏</h3>
<p>点击用户头像可以打开个人中心，在这里可以便捷的切换用户和查看开发者工具收到的消息。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/noticecenter.ffa6e967.png" alt="Tool" loading="lazy"></p>
<p>用户头像右侧是控制主界面模块显示/隐藏的按钮。至少需要有一个模块显示。</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/showandhide.5388b188.gif" alt="button" loading="lazy"></p>
<p>工具栏中间，可以选择普通编译，也可以新建并选择自定义条件进行编译和预览。</p>
<p>通过切后台按钮，可以模拟小程序进入后台的情况</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/background.2cd7c93b.png" alt="scence" loading="lazy"></p>
<p>工具栏上提供了清缓存的快速入口。可以便捷的清除工具上的文件缓存、数据缓存、还有后台的授权数据，方便开发者调试。</p>
<p>工具栏右侧是开发辅助功能的区域，在这里可以上传代码、申请测试、上传腾讯云、查看项目信息</p>
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/righttools.8bacf906.png" alt="righttools" loading="lazy"></p>
<h3> 工具栏管理</h3>
<p>在工具栏上点击鼠标右键，可以打开工具栏管理</p>
<h3> 模拟器</h3>
<p>模拟器可以模拟小程序在微信客户端的表现。小程序的代码通过编译后可以在模拟器上直接运行。</p>
<p>开发者可以选择不同的设备，也可以添加自定义设备来调试小程序在不同尺寸机型上的适配问题。</p>
<p>在模拟器底部的状态栏，可以直观地看到当前运行小程序的场景值，页面路径及页面参数</p>
<h4> 独立窗口</h4>
<p>点击 模拟器/调试器 右上角的按钮可以使用独立窗口显示 模拟器/调试器</p>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/login.b4162666.png" type="image/png"/>
    </item>
    <item>
      <title>npm 支持</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/tools/npm.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/tools/npm.html</guid>
      <source url="https://leijue222.github.io/rss.xml">npm 支持</source>
      <description>从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。 此文档要求开发者们对 npm 有一定的了解，因此不会再去介绍 npm 的基本功能。如若之前未接触过 npm，请翻阅官方 npm 文档进行学习。</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>从小程序基础库版本 2.2.1 或以上、及开发者工具 1.02.1808300 或以上开始，小程序支持使用 npm 安装第三方包。</p>
<p>此文档要求开发者们对 npm 有一定的了解，因此不会再去介绍 npm 的基本功能。如若之前未接触过 npm，请翻阅官方 npm 文档进行学习。</p>
<!-- more -->
<h2> 使用 npm 包</h2>
<ol>
<li>
<p>在小程序中执行命令安装 npm 包:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此处并没有强制要求 <code>node_modules</code> 必须在小程序根目录下(即 <code>project.config.js</code> 中的 <code>miniprogramRoot</code> 字段)，也可以存在于小程序根目录下的各个子目录中。但是不允许 <code>node_modules</code> 在小程序根目录外。</p>
</li>
<li>
<p>点击开发者工具中的菜单栏: 工具 --&gt; 构建 npm</p>
</li>
<li>
<p>勾选“使用 npm 模块”选项:</p>
</li>
<li>
<p>构建完成后即可使用 npm 包。</p>
</li>
</ol>
<p><strong>js 中引入 npm 包</strong>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 npm 包中的自定义组件:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>此处使用 npm 包时如果只引入包名，则默认寻找包名下的 <code>index.js</code> 文件或者 <code>index</code> 组件。</p>
</div>
<h2> 发布 npm 包</h2>
<h3> 发布小程序 npm 包的约束</h3>
<p>这里要发布的 npm 包是特指专为小程序定制的 npm 包(下称小程序 npm 包)。因为小程序自定义组件的特殊性，原有的 npm 包机制无法满足我们的需求，所以这里需要对小程序 npm 包做一些约束:</p>
<ol>
<li>
<p>小程序 npm 包要求根目录下必须有构建文件生成目录(默认为 miniprogram_dist 目录)，此目录可以通过在 package.json 文件中新增一个 miniprogram 字段来指定，比如:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>小程序 npm 包里只有构建文件生成目录会被算入小程序包的占用空间，上传小程序代码时也只会上传该目录的代码。如果小程序 npm 包有一些测试、构建相关的代码请放到构建文件生成目录外。另外也可以使用 <code>.npmignore</code> 文件来避免将一些非业务代码文件发布到 npm 中。</p>
</li>
<li>
<p>测试、构建相关的依赖请放入 <code>devDependencies</code> 字段中避免被一起打包到小程序包中。</p>
</li>
</ol>
<h3> 发布其他 npm 包的约束</h3>
<p>如果是已经发布过的一些 npm 包，因为一些原因无法改造成小程序 npm 包的结构的话，也可以通过微调后被使用，但是请确保遵循以下几点:</p>
<ol>
<li>
<p>只支持纯 js 包，不支持自定义组件。</p>
</li>
<li>
<p>必须有入口文件，即需要保证 package.json 中的 main 字段是指向一个正确的入口，如果 package.json 中没有 main 字段，则以 npm 包根目录下的 index.js 作为入口文件。</p>
</li>
<li>
<p>测试、构建相关的依赖请放入 devDependencies 字段中避免被一起打包到小程序包中，这一点和小程序 npm 包的要求相同。</p>
</li>
<li>
<p>不支持依赖 c++ addon，不支持依赖 Node.js 的内置库:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>对于一些纯 js 实现的 Node.js 内置库(如 path 模块)，可以通过额外安装其他开发者实现的 npm 包来支持。</p>
</div>
</li>
<li>
<p>使用 <code>require</code> 依赖的时候下列几种方式也是不允许的:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>小程序环境比较特殊，一些全局变量(如 window 对象)和构造器(如 Function 构造器)是无法使用的。</p>
</li>
</ol>
<h2> 原理介绍</h2>
<p>为了帮助大家更好的理解发布 npm 包中提到的各种要求，这里简单介绍一下原理:</p>
<ol>
<li>
<p>首先 <code>node_modules</code> 目录不会参与编译、上传和打包中，所以小程序想要使用 npm 包必须走一遍“构建 npm”的过程，在最外层的 <code>node_modules</code> 的同级目录下会生成一个 <code>miniprogram_npm</code> 目录，里面会存放构建打包后的 npm 包，也就是小程序真正使用的 npm 包。</p>
</li>
<li>
<p>构建打包分为两种: 小程序 npm 包会直接拷贝构建文件生成目录下的所有文件到 <code>miniprogram_npm</code> 中；其他 npm 包则会从入口 js 文件开始走一遍依赖分析和打包过程(类似 webpack)。</p>
</li>
<li>
<p>寻找 npm 包的过程和 npm 的实现类似，从依赖 npm 包的文件所在目录开始逐层往外找，直到找到可用的 npm 包或是小程序根目录为止。下面简单介绍下构建打包前后的目录情况，构建之前的结构:</p>
</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构建之后的结构:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>打包生成的代码在同级目录下会生成 source map 文件，方便进行逆向调试。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>评分方法</title>
      <link>https://leijue222.github.io/tutorial/front-end/mini-app/tools/score.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/mini-app/tools/score.html</guid>
      <source url="https://leijue222.github.io/rss.xml">评分方法</source>
      <description>目前体验评分共有 27 条规则，共分为三类: 性能、体验、最佳实践，满足规则要求得分(100 分)，否则不得分(0 分)，最后根据各规则权重和公式计算出总得分。</description>
      <category>小程序</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>目前体验评分共有 27 条规则，共分为三类: 性能、体验、最佳实践，满足规则要求得分(100 分)，否则不得分(0 分)，最后根据各规则权重和公式计算出总得分。</p>
<!-- more -->
<p><img src="https://res.wx.qq.com/wxdoc/dist/assets/img/audits_formula.ba03ca01.png" alt="audits_formula" loading="lazy"></p>
<p>权重为 0 的规则，表示该规则不参与评分，仅作为提示项。开发者可在开发者工具中可以点击“忽略”。</p>
<p>各规则的得分条件也可能会随小程序的版本更新有一定的调整。</p>
<h2> 权重表</h2>
<table>
<thead>
<tr>
<th>分类</th>
<th>规则</th>
<th>权重</th>
</tr>
</thead>
<tbody>
<tr>
<td>性能</td>
<td>脚本执行时间</td>
<td>7</td>
</tr>
<tr>
<td></td>
<td>首屏时间</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td>渲染时间</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td>setData 调用频率</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td>setData 数据大小</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td>WXML 节点数</td>
<td>6</td>
</tr>
<tr>
<td></td>
<td>请求耗时</td>
<td>5</td>
</tr>
<tr>
<td></td>
<td>网络请求数</td>
<td>5</td>
</tr>
<tr>
<td></td>
<td>图片请求数</td>
<td>5</td>
</tr>
<tr>
<td></td>
<td>图片缓存</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>图片大小</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>避免 setData 数据冗余</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td>网络请求缓存</td>
<td>2</td>
</tr>
<tr>
<td>体验</td>
<td>开启惯性滚动</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>避免使用:active 伪类来实现点击态</td>
<td>8</td>
</tr>
<tr>
<td></td>
<td>保持图片大小比例</td>
<td>4</td>
</tr>
<tr>
<td></td>
<td>可点击元素的响应区域</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td>iPhone X 兼容</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td>合理的颜色搭配</td>
<td>0</td>
</tr>
<tr>
<td>最佳实践</td>
<td>避免 JS 异常</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td>避免网络请求异常</td>
<td>3</td>
</tr>
<tr>
<td></td>
<td>废弃接口</td>
<td>2</td>
</tr>
<tr>
<td></td>
<td>使用 HTTPS</td>
<td>1</td>
</tr>
<tr>
<td></td>
<td>最低基础库版本</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>移除不可访问到的页面</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>WXSS 使用率</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>及时回收定时器</td>
<td>0</td>
</tr>
</tbody>
</table>
<h2> 性能</h2>
<ol>
<li>
<p>首屏时间</p>
<p>首屏时间是指用户从打开小程序看到第一屏主要内容的时间，首屏时间太长会导致用户长时间看到的都是白屏，影响使用体验。</p>
<p>优化首屏时间，可以分为以下几种情况:</p>
<ol>
<li>首屏渲染的内容较多，需要集合多份数据进行渲染。这种情况需要开发者把内容分优先级，把优先级高的内容做优先展示，缩短白屏时间；</li>
<li>首屏内容依赖的数据从服务端请求的时间太长。开发者需要从服务端侧具体分析服务端数据返回的时间长的原因；</li>
<li>一次性渲染数据太大或依赖的计算过于复杂。减少渲染的数据量、优化渲染相关数据的算法可以解决这类问题。</li>
</ol>
<p>得分条件: <strong>首屏时间不超过 5 秒</strong></p>
</li>
<li>
<p>渲染时间</p>
<p>渲染时间指的是首次渲染或因数据变化带来的页面结构变化的渲染花费的时间。</p>
<p>渲染界面的耗时过长会让用户觉得卡顿，体验较差，出现这一情况时，需要校验下是否同时渲染的区域太大(例如列表过长)，或渲染依赖的计算是否过于复杂。</p>
<p>得分条件: 渲<strong>染时间不超过 500ms</strong></p>
</li>
<li>
<p>脚本执行时间</p>
<p>脚本执行时间是指 JS 脚本在一次同步执行中消耗的时间，比如生命周期回调、事件处理函数的同步执行时间。</p>
<p>执行脚本的耗时过长会让用户觉得卡顿，体验较差，出现这一情况时，需要确认并优化脚本的逻辑</p>
<p>得分条件: <strong>一个执行周期内脚本运行时间不超过 1 秒</strong></p>
</li>
<li>
<p><code>setData</code> 调用频率</p>
<p><code>setData</code> 接口的调用涉及逻辑层与渲染层间的线程通信，通信过于频繁可能导致处理队列阻塞，界面渲染不及时而导致卡顿，应避免无用的频繁调用。</p>
<p>得分条件: <strong>每秒调用 setData 的次数不超过 20 次</strong></p>
</li>
<li>
<p><code>setData</code> 数据大小</p>
<p>由于小程序运行逻辑线程与渲染线程之上，<code>setData</code> 的调用会把数据从逻辑层传到渲染层，数据太大会增加通信时间。</p>
<p>得分条件: <strong><code>setData</code> 的数据在 JSON.stringify 后不超过 256KB</strong></p>
</li>
<li>
<p>避免 <code>setData</code> 数据冗余</p>
<p><code>setData</code> 操作会引起框架处理一些渲染界面相关的工作，一个未绑定的变量意味着与界面渲染无关，传入 set`Data 会造成不必要的性能消耗。</p>
<p>得分条件: <strong><code>setData</code> 传入的所有数据都在模板渲染中有相关依赖</strong></p>
</li>
<li>
<p>WXML 节点数</p>
<p>建议一个页面使用少于 1000 个 WXML 节点，节点树深度少于 30 层，子节点数不大于 60 个。一个太大的 WXML 节点树会增加内存的使用，样式重排时间也会更长，影响体验。</p>
<p>得分条件: <strong>页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个</strong></p>
</li>
<li>
<p>图片缓存</p>
<p>开启 HTTP 缓存控制后，下一次加载同样的图片，会直接从缓存读取，大大提升加载速度。</p>
<p>得分条件: <strong>所有图片均开启 HTTP 缓存</strong></p>
</li>
<li>
<p>图片大小</p>
<p>图片太大会增加下载时间和内存的消耗，应根据显示区域大小合理控制图片大小。</p>
<p>得分条件: <strong>图片宽高都不超过实际显示宽高的 3 倍</strong></p>
</li>
<li>
<p>请求耗时</p>
<p>请求的耗时太长会让用户一直等待甚至离开，应当优化好服务器处理时间、减小回包大小，让请求快速响应。</p>
<p>得分条件: <strong>所有网络请求都在 1 秒内返回结果</strong></p>
</li>
<li>
<p>网络请求数</p>
<p>短时间内发起太多请求会触发小程序并行请求数量的限制，同时太多请求也可能导致加载慢等问题，应合理控制请求数量，甚至做请求的合并等。</p>
<p>得分条件: <strong>每秒通过 wx.request 发起的请求数不超过 10 个</strong></p>
</li>
<li>
<p>图片请求数</p>
<p>短时间内发起太多图片请求会触发浏览器并行加载的限制，可能导致图片加载慢，用户一直处理等待。应该合理控制数量，可考虑使用雪碧图技术或在屏幕外的图片使用懒加载。</p>
<p>得分条件: <strong>每秒发起的图片请求数不超过 20 个</strong></p>
</li>
<li>
<p>网络请求缓存</p>
<p>发起网络请求总会让用户等待，可能造成不好的体验，应尽量避免多余的请求，比如对同样的请求进行缓存</p>
<p>得分条件: <strong>3 分钟以内同一个 URL 请求不出现两次回包大于 128KB 且一模一样的内容</strong></p>
</li>
</ol>
<h2> 体验</h2>
<ol>
<li>
<p>开启惯性滚动</p>
<p>惯性滚动会使滚动比较顺畅，在安卓下默认有惯性滚动，而在 iOS 下需要额外设置 <code>-webkit-overflow-scrolling: touch</code> 的样式；</p>
<p>得分条件: <strong>wxss 中带有 <code>overflow: scroll</code> 的元素，在 iOS 下需要设置 <code>-webkit-overflow-scrolling: touch</code> 样式</strong></p>
</li>
<li>
<p>避免使用 <code>:active</code> 伪类来实现点击态</p>
<p>使用 CSS <code>:active</code> 伪类来实现点击态，很容易触发，并且滚动或滑动时点击态不会消失，体验较差。建议使用小程序内置组件的 <code>'hover-class'</code> 属性来实现</p>
<p>得分条件: 不使用 <code>:active</code> 伪类，并使用 <code>hover-class</code> 替换 <code>:active</code></p>
</li>
<li>
<p>保持图片大小比例</p>
<p>图片若没有按原图宽高比例显示，可能导致图片歪曲，不美观，甚至导致用户识别困难。可根据情况设置 image 组件的 <code>mode</code> 属性，以保持原图宽高比。</p>
<p>得分条件: <strong>显示的高/宽与原图的高/宽不超过 15%</strong></p>
</li>
<li>
<p>可点击元素的响应区域</p>
<p>我们应该合理地设置好可点击元素的响应区域大小，如果过小会导致用户很难点中，体验很差。</p>
<p>得分条件: <strong>可点击元素的宽高都不小于 20px</strong></p>
</li>
<li>
<p>iPhone X 兼容</p>
<p>对于 <code>position: fixed</code> 的可交互组件，如果渲染在 iPhone X 的安全区域外，容易误触 Home Indicator，应当把可交互的部分都渲染到安全区域内。</p>
<p>建议使用以下 wxss 进行兼容</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>得分条件: <code>position: fixed</code> 的可交互组件渲染在安全区域内</p>
</li>
<li>
<p>合理的颜色搭配</p>
<p>文字颜色与背景色需要搭配得当，适宜的颜色对比度可以让用户更好地阅读，提升小程序的用户体验。</p>
<p>由于颜色搭配的计算方法较为复杂，目前算法还在不断优化中。因此该指标仅作为评分的提醒项，不计入总分中。</p>
<p>判断标准:</p>
<ol>
<li>
<p>对于较大字体(font-size &gt;= 24px，或同时满足 font-size &gt;= 19px 与 font-weight &gt;= 700)，文字颜色和背景颜色的对比度不小于 3</p>
</li>
<li>
<p>其他字体，文字颜色和背景颜色的对比度不小于 4.5</p>
</li>
</ol>
</li>
</ol>
]]></content:encoded>
      <enclosure url="https://res.wx.qq.com/wxdoc/dist/assets/img/audits_formula.ba03ca01.png" type="image/png"/>
    </item>
    <item>
      <title>axios</title>
      <link>https://leijue222.github.io/tutorial/front-end/node-js/package/axois.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/node-js/package/axois.html</guid>
      <source url="https://leijue222.github.io/rss.xml">axios</source>
      <description>GitHub 地址: https://github.com/axios/axios axois 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 node.js</description>
      <category>Node.js</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>GitHub 地址: <a href="https://github.com/axios/axios" target="_blank" rel="noopener noreferrer">https://github.com/axios/axios</a></p>
</blockquote>
<p>axois 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 node.js</p>
<!-- more -->
<h2> 特点</h2>
<ul>
<li>从浏览器发出 XMLHttpRequests</li>
<li>从 Node.js 发出 HTTP 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求和响应数据</li>
<li>取消请求</li>
<li>JSON 数据的自动转换</li>
<li>客户端防止 XSRF 支持</li>
</ul>
<h2> 安装</h2>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 使用</h2>
<div class="hint-container info">
<p class="hint-container-title">CommonJS 用法</p>
<p>为了在将 CommonJS 导入与 <code>require()</code> 一起使用时获得 TypeScript 类型(用于智能感知/自动完成)，请使用以下方法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<p>进行 GET 请求:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p><code>async</code> / <code>await</code> is part of ECMAScript 2017 and is not supported in Internet Explorer and older browsers, so use with caution.</p>
</div>
<p>进行 POST 请求:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行多个并发请求:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> API</h2>
<p>可以通过将相关配置传递给 <code>axios</code> 来发出请求。</p>
<h3> axios(config)</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> axios(url[, config])</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 请求别名</h3>
<p>为了方便起见，已为所有受支持的请求方法提供了别名。</p>
<ul>
<li><code>axios.request(config)</code></li>
<li><code>axios.get(url[, config])</code></li>
<li><code>axios.delete(url[, config])</code></li>
<li><code>axios.head(url[, config])</code></li>
<li><code>axios.options(url[, config])</code></li>
<li><code>axios.post(url[, data[, config]])</code></li>
<li><code>axios.put(url[, data[, config]])</code></li>
<li><code>axios.patch(url[, data[, config]])</code></li>
</ul>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>当使用别名时，<code>url</code>, <code>method</code> 和 <code>data</code> 属性不需要再配置中指定。</p>
</div>
<h3> 并发</h3>
<p>一些用于处理并发请求的有用函数:</p>
<ul>
<li>
<p><code>axios.all(iterable)</code></p>
</li>
<li>
<p><code>axios.spread(callback)</code></p>
</li>
</ul>
<h3> 创建实例</h3>
<p>您可以使用自定义配置创建 axios 的新实例。</p>
<ul>
<li><code>axios.create([config])</code></li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 实例方法</h3>
<p>可用的实例方法在下面列出。指定的配置将与实例配置合并。</p>
<ul>
<li><code>axios#request(config)</code></li>
<li><code>axios#get(url[, config])</code></li>
<li><code>axios#delete(url[, config])</code></li>
<li><code>axios#head(url[, config])</code></li>
<li><code>axios#options(url[, config])</code></li>
<li><code>axios#post(url[, data[, config]])</code></li>
<li><code>axios#put(url[, data[, config]])</code></li>
<li><code>axios#patch(url[, data[, config]])</code></li>
<li><code>axios#getUri([config])</code></li>
</ul>
<h2> 请求配置</h2>
<p>These are the available config options for making requests. Only the <code>url</code> is required. Requests will default to <code>GET</code> if <code>method</code> is not specified.</p>
<p>这些是发出请求的可用配置选项。只有 <code>url</code> 是必填的。如果未指定 <code>method</code>，则请求将默认为 <code>GET</code>。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 相应模式</h2>
<p>请求的响应包含以下信息。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>then</code> 时，您将收到如下响应:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当使用 <code>catch</code> 或传递 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank" rel="noopener noreferrer">拒绝回调</a> 作为 <code>then</code> 的第二个参数时， 如 <a href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF">处理错误</a>部分中所述，响应将通过 <code>error</code> 对象提供。</p>
<h2> 配置默认值</h2>
<p>您可以指定将应用于每个请求的配置默认值。</p>
<h3> 全局 axios 默认值</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 自定义实例默认值</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 配置优先顺序</h3>
<p>Config 将以优先顺序合并。顺序是在 <a href="https://github.com/axios/axios/blob/master/lib/defaults.js#L28" target="_blank" rel="noopener noreferrer">lib/defaults.js</a> 中找到的库默认值，然后是实例的 <code>defaults</code> 属性，以及 最后是请求的 <code>config</code> 参数。后者将优先于前者。这是一个例子。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 拦截器</h2>
<p>您可以先拦截请求或响应，然后再由 <code>then</code> 或 <code>catch</code> 处理。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>您可以在以后需要时删除拦截器。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>您可以将拦截器添加到 axios 的自定义实例中。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 处理错误</h2>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>validateStatus</code> 配置选项，您可以定义应该抛出错误的 HTTP 代码。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>toJSON</code>，您将获得一个对象，其中包含有关 HTTP 错误的更多信息。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 取消</h2>
<p>您可以使用<em>取消令牌</em>取消请求。</p>
<blockquote>
<p>axios 取消令牌 API 是基于撤消的 <a href="https://github.com/tc39/proposal-cancelable-promises" target="_blank" rel="noopener noreferrer">可取消承诺提案</a>.</p>
</blockquote>
<p>您可以使用 <code>CancelToken.source</code> 工厂函数创建一个取消令牌，如下所示:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>您还可以通过将执行程序函数传递给 <code>CancelToken</code> 构造函数来创建取消令牌:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>您可以使用相同的取消令牌取消多个请求。</p>
</div>
<h2> Using application/x-www-form-urlencoded format</h2>
<p>默认情况下，axios 将 JavaScript 对象序列化为 <code>JSON</code>。要改为以 <code>application/x-www-form-urlencoded</code> 格式发送数据，可以使用以下选项之一。</p>
<h3> 浏览器</h3>
<p>在浏览器中，您可以按以下方式使用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams" target="_blank" rel="noopener noreferrer"><code>URLSearchParams</code></a> API:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Node.js</h3>
<h4> Query string</h4>
<p>在 Node.js 中，您可以按照如下方式使用 <a href="https://nodejs.org/api/querystring.html" target="_blank" rel="noopener noreferrer"><code>querystring</code></a> 模块:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>您也可以使用 <a href="https://github.com/ljharb/qs" target="_blank" rel="noopener noreferrer"><code>qs</code></a> 库.</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>如果需要对嵌套对象进行字符串化处理，则最好使用 qs 库，因为 <code>querystring</code> 方法在该用例中存在已知问题(<a href="https://github.com/nodejs/node-v0.x-archive/issues/1665" target="_blank" rel="noopener noreferrer">https://github.com/nodejs/node-v0.x-archive/issues/1665</a>)</p>
</div>
<h4> 表格数据</h4>
<p>在 Node.js 中，您可以使用 <a href="https://github.com/form-data/form-data" target="_blank" rel="noopener noreferrer"><code>form-data</code></a> 库，如下所示:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者，使用拦截器:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>创建 Vue 应用</title>
      <link>https://leijue222.github.io/tutorial/front-end/vue/core/app.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/vue/core/app.html</guid>
      <source url="https://leijue222.github.io/rss.xml">创建 Vue 应用</source>
      <description>应用实例 每个 Vue 应用都是通过 createApp 函数创建一个新的应用实例： 根组件 我们传入 createApp 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。 如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。 虽然许多示例只需要一个组件，但大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的...</description>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 应用实例</h2>
<p>每个 Vue 应用都是通过 <code>createApp</code> 函数创建一个新的<strong>应用实例</strong>：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 根组件</h2>
<p>我们传入 <code>createApp</code> 的对象实际上是一个组件，每个应用都需要一个“根组件”，其他组件将作为其子组件。</p>
<p>如果你使用的是单文件组件，我们可以直接从另一个文件中导入根组件。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>虽然许多示例只需要一个组件，但大多数真实的应用都是由一棵嵌套的、可重用的组件树组成的。例如，一个待办事项 (Todos) 应用的组件树可能是这样的：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 挂载应用</h2>
<p>应用实例必须在调用了 <code>.mount()</code> 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。</p>
<p><code>.mount()</code> 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。</p>
<h3> DOM 中的根组件模板</h3>
<p>当在未采用构建流程的情况下使用 Vue 时，我们可以在挂载容器中直接书写根组件模板：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>当根组件没有设置 <code>template</code> 选项时，Vue 将自动使用容器的 <code>innerHTML</code> 作为模板。</p>
</div>
<h2> 应用配置</h2>
<p>应用实例会暴露一个 <code>.config</code> 对象允许我们配置一些应用级的选项，例如定义一个应用级的错误处理器，用来捕获所有子组件上的错误：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>应用实例还提供了一些方法来注册应用范围内可用的资源，例如注册一个组件：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这使得 <code>TodoDeleteButton</code> 在应用的任何地方都是可用的。</p>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>确保在挂载应用实例之前完成所有应用配置！</p>
</div>
<h2> 多个应用实例</h2>
<p>应用实例并不只限于一个。<code>createApp</code> API 允许你在同一个页面中创建多个共存的 Vue 应用，而且每个应用都拥有自己的用于配置和全局资源的作用域。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你正在使用 Vue 来增强服务端渲染 HTML，并且只想要 Vue 去控制一个大型页面中特殊的一小部分，应避免将一个单独的 Vue 应用实例挂载到整个页面上，而是应该创建多个小的应用实例，将它们分别挂载到所需的元素上去。</p>
]]></content:encoded>
    </item>
    <item>
      <title>快速上手 Vue.js</title>
      <link>https://leijue222.github.io/tutorial/front-end/vue/core/get-started.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/vue/core/get-started.html</guid>
      <source url="https://leijue222.github.io/rss.xml">快速上手 Vue.js</source>
      <description>Vue.js 是什么 起步 您应当已了解关于 HTML、CSS 和 JavaScript 的中级知识。 安装 (https://cn.vuejs.org/guide/quick-start.html) 尝试 Vue.js 最简单的方法是使用 SFC Playground (https://sfc.vuejs.org/)。您可以在浏览器新标签页中打开它，...</description>
      <category>Vue</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Vue.js 是什么</h2>
<h2> 起步</h2>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>您应当已了解关于 HTML、CSS 和 JavaScript 的中级知识。</p>
</div>
<p><a href="https://cn.vuejs.org/guide/quick-start.html" target="_blank" rel="noopener noreferrer">安装</a></p>
<p>尝试 Vue.js 最简单的方法是使用 <a href="https://sfc.vuejs.org/" target="_blank" rel="noopener noreferrer">SFC Playground</a>。您可以在浏览器新标签页中打开它，跟着例子自己进行一些尝试。</p>
<p>当然，由于大多数浏览器都支持 ES Module，你可以直接导入 Vue:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p><code>vue-cli</code> 已经过时，不建议在新项目中使用，请使用 <code>vite</code></p>
</div>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>Mr.Hope <strong>不推荐</strong> 新手直接使用 <code>vite</code> 或者 <code>webpack</code> 之类的 Bundler 进行上手，尤其是在您不熟悉基于 Node.js 的构建工具的情况下。</p>
<p>请使用 CDN 的方式引入 Vue，并充分熟悉 Vue 的基础知识后再引入 Bundler。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>开发环境安装</title>
      <link>https://leijue222.github.io/tutorial/front-end/vue/core/install.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/vue/core/install.html</guid>
      <source url="https://leijue222.github.io/rss.xml">开发环境安装</source>
      <description>环境准备 VS Code 安装 安装 VS Code (../../../software/vscode/install.md); 开发指南 1. 使用 VS Code 打开项目文件夹。 请打开 VS Code 选择菜单栏中的 “文件-打开文件夹”，或在文件夹上 “右键——使用 VS Code 打开” 或在文件夹内部空白处 “右键——使用 VS Cod...</description>
      <category>Vue</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 环境准备</h2>
<h3> VS Code 安装</h3>
<ul>
<li><a href="/tutorial/software/vscode/install.html" target="blank">安装 VS Code</a></li>
</ul>
<h4> 开发指南</h4>
<ol>
<li>
<p>使用 VS Code 打开项目文件夹。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>请打开 VS Code 选择菜单栏中的 “文件-打开文件夹”，或在文件夹上 “右键——使用 VS Code 打开” 或在文件夹内部空白处 “右键——使用 VS Code 打开”。</p>
</div>
</li>
<li>
<p>打开终端(快捷键 <code>Ctrl + `</code> )。</p>
</li>
<li>
<p>在终端中输入相关指令即可执行相关功能。</p>
</li>
</ol>
<h3> Git 安装</h3>
<ul>
<li><a href="/tutorial/software/git/install.html" target="blank">安装 Git</a></li>
</ul>
<h3> Node.js 环境安装</h3>
<p>请先安装 Node.js 并将 npm 与 Node.js 添加至 path。</p>
<ul>
<li>
<p><a href="/tutorial/front-end/node-js/install.html" target="blank">安装 Node.js</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/windows/env-variable.html" target="blank">添加到 path</a></p>
</li>
</ul>
<h2> 开发工具安装</h2>
<p>Vue 官方提供的浏览器插件 Vue.js devtools 可以更好的帮助开发。</p>
<ul>
<li>用 Chrome 通过代理打开 <a href="https://chrome.google.com/webstore/detail/nhdogjmejiglipccpnnnanhbledajbpd" target="_blank" rel="noopener noreferrer">Vue.js devtools 网址</a>，安装 Vue.js devtools 开发工具</li>
<li>使用 Edge 打开 <a href="https://microsoftedge.microsoft.com/addons/detail/vuejs-devtools/olofadcdnkkjdfgjcmjaadnlehnnihnl?hl=zh-CN" target="_blank" rel="noopener noreferrer">Vue.js devtools 网址</a>，安装 Vue.js devtools 开发工具</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Vue 单文件组件</title>
      <link>https://leijue222.github.io/tutorial/front-end/vue/core/sfc.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/vue/core/sfc.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Vue 单文件组件</source>
      <description>介绍 Vue 的单文件组件 (即 .vue 文件，简称 *SFC**) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中。下面是一个单文件组件的示例： 如你所见，Vue 的单文件组件是 HTML、CSS 和 JavaScript 三种元素的自然延伸。、`` 和 三个块在同一个文件中封装、组合了组件的视图、逻辑和样式...</description>
      <category>Vue</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 介绍</h2>
<p>Vue 的单文件组件 (即 <code>*.vue</code> 文件，简称 <strong>SFC</strong>) 是一种特殊的文件格式，使我们能够将一个 Vue 组件的模板、逻辑与样式封装在单个文件中。下面是一个单文件组件的示例：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如你所见，Vue 的单文件组件是 HTML、CSS 和 JavaScript 三种元素的自然延伸。<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 三个块在同一个文件中封装、组合了组件的视图、逻辑和样式。</p>
<h2> 总览</h2>
<h2> 总览 {#overview}</h2>
<p>一个 Vue 单文件组件 (SFC)，通常使用 <code>*.vue</code> 作为文件扩展名，它是一种使用了类似 HTML 语法的自定义文件格式，用于定义 Vue 组件。一个 Vue 单文件组件在语法上是兼容 HTML 的。</p>
<p>每一个 <code>*.vue</code> 文件都由三种顶层语块构成：<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code>，以及一些其他的自定义块：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 相应语言块 {#language-blocks}</h2>
<h3> <code>&lt;template&gt;</code> {#template}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件最多可以包含一个顶层 <code>&lt;template&gt;</code> 块。</p>
</li>
<li>
<p>语块包裹的内容将会被提取、传递给 <code>@vue/compiler-dom</code>，预编译为 JavaScript 渲染函数，并附在导出的组件上作为其 <code>render</code> 选项。</p>
</li>
</ul>
<h3> <code>&lt;script&gt;</code> {#script}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件最多可以包含一个 <code>&lt;script&gt;</code> 块。(使用 <a href="/api/sfc-script-setup.html" target="blank"><code>&lt;script setup&gt;</code></a> 的情况除外)</p>
</li>
<li>
<p>这个脚本代码块将作为 ES 模块执行。</p>
</li>
<li>
<p><strong>默认导出</strong>应该是 Vue 的组件选项对象，可以是一个对象字面量或是 <a href="/api/general.html#definecomponent" target="blank">defineComponent</a> 函数的返回值。</p>
</li>
</ul>
<h3> <code>&lt;script setup&gt;</code> {#script-setup}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件最多可以包含一个 <code>&lt;script setup&gt;</code>。(不包括一般的 <code>&lt;script&gt;</code>)</p>
</li>
<li>
<p>这个脚本块将被预处理为组件的 <code>setup()</code> 函数，这意味着它将<strong>为每一个组件实例</strong>都执行。<code>&lt;script setup&gt;</code> 中的顶层绑定都将自动暴露给模板。要了解更多细节，请看 <a href="/api/sfc-script-setup"><code>&lt;script setup&gt;</code> 的专门文档</a>。</p>
</li>
</ul>
<h3> <code>&lt;style&gt;</code> {#style}</h3>
<ul>
<li>
<p>每个 <code>*.vue</code> 文件可以包含多个 <code>&lt;style&gt;</code> 标签。</p>
</li>
<li>
<p>一个 <code>&lt;style&gt;</code> 标签可以使用 <code>scoped</code> 或 <code>module</code> attribute (查看 <a href="/api/sfc-css-features">SFC 样式功能</a>了解更多细节) 来帮助封装当前组件的样式。使用了不同封装模式的多个 <code>&lt;style&gt;</code> 标签可以被混合入同一个组件。</p>
</li>
</ul>
<h3> 自定义块 {#custom-blocks}</h3>
<p>在一个 <code>*.vue</code> 文件中可以为任何项目特定需求使用额外的自定义块。举个例子，一个用作写文档的 <code>&lt;docs&gt;</code> 块。这里是一些自定义块的真实用例：</p>
<ul>
<li><a href="https://gridsome.org/docs/querying-data/" target="_blank" rel="noopener noreferrer">Gridsome：<code>&lt;page-query&gt;</code></a></li>
<li><a href="https://github.com/wheatjs/vite-plugin-vue-gql" target="_blank" rel="noopener noreferrer">vite-plugin-vue-gql：<code>&lt;gql&gt;</code></a></li>
<li><a href="https://github.com/intlify/bundle-tools/tree/main/packages/vite-plugin-vue-i18n#i18n-custom-block" target="_blank" rel="noopener noreferrer">vue-i18n：<code>&lt;i18n&gt;</code></a></li>
</ul>
<p>自定义块的处理需要依赖工具链。如果你想要在构建中集成你的自定义语块，请参见<a href="/guide/scaling-up/tooling.html#sfc-custom-block-integrations" target="blank">相关工具链指南</a>获取更多细节。</p>
<h2> 自动名称推导 {#automatic-name-inference}</h2>
<p>SFC 在以下场景中会根据<strong>文件名</strong>自动推导其组件名：</p>
<ul>
<li>开发警告信息格式</li>
<li>DevTools 审阅</li>
<li>递归组件自引用。例如一个名为 <code>FooBar.vue</code> 的组件可以在模板中通过 <code>&lt;FooBar/&gt;</code> 引用自己。(同名情况下) 这比明确注册/导入的组件优先级低。</li>
</ul>
<h2> 预处理器 {#pre-processors}</h2>
<p>代码块可以使用 <code>lang</code> 这个 attribute 来声明预处理器语言，最常见的用例就是对 <code>&lt;script&gt;</code> 块使用 TypeScript：</p>
<div class="language-vue-html line-numbers-mode" data-ext="vue-html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>lang</code> 在任意块上都能使用，比如我们可以在 <code>&lt;style&gt;</code> 标签上使用 <a href="https://sass-lang.com/" target="_blank" rel="noopener noreferrer">SASS</a> 或是 <code>&lt;template&gt;</code> 上使用 <a href="https://pugjs.org/api/getting-started.html" target="_blank" rel="noopener noreferrer">Pug</a>：</p>
<div class="language-vue-html line-numbers-mode" data-ext="vue-html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意对各种不同的预处理的集成会导致工具链的不同，你应该查看相应的工具链文档了解细节：</p>
<ul>
<li><a href="https://vitejs.dev/guide/features.html#css-pre-processors" target="_blank" rel="noopener noreferrer">Vite</a></li>
<li><a href="https://cli.vuejs.org/guide/css.html#pre-processors" target="_blank" rel="noopener noreferrer">Vue CLI</a></li>
<li><a href="https://vue-loader.vuejs.org/guide/pre-processors.html#using-pre-processors" target="_blank" rel="noopener noreferrer">webpack + vue-loader</a></li>
</ul>
<h2> Src 导入 {#src-imports}</h2>
<p>如果你更喜欢将 <code>*.vue</code> 组件分散到多个文件中，可以为一个语块使用 <code>src</code> 这个 attribute 来导入一个外部文件：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意 <code>src</code> 导入和 Webpack 的模块请求遵循相同的路径解析规则，这意味着：</p>
<ul>
<li>相对路径需要以 <code>./</code> 开头</li>
<li>你也可以从 npm 依赖中导入资源</li>
</ul>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>src</code> 导入对自定义语块也同样适用：</p>
<div class="language-vue line-numbers-mode" data-ext="vue"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 注释 {#comments}</h2>
<p>在每一个语块中你都可以按照相应语言 (HTML、CSS、JavaScript 和 Pug 等等) 的语法书写注释。对于顶层注释，请使用 HTML 的注释语法 <code>&lt;!-- comment contents here --&gt;</code></p>
]]></content:encoded>
    </item>
    <item>
      <title>模板语法</title>
      <link>https://leijue222.github.io/tutorial/front-end/vue/core/template.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/vue/core/template.html</guid>
      <source url="https://leijue222.github.io/rss.xml">模板语法</source>
      <description>Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。 在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的...</description>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。</p>
<p>在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。</p>
<p>如果你对虚拟 DOM 的概念比较熟悉，并且偏好直接使用 JavaScript，你也可以结合可选的 JSX 支持直接手写渲染函数而不采用模板。但请注意，这将不会享受到和模板同等级别的编译时优化。</p>
<h2> 文本插值</h2>
<p>最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 (即双大括号)：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>双大括号标签会被替换为相应组件实例中 <code>msg</code> 属性的值。同时每次 <code>msg</code> 属性更改时它也会同步更新。</p>
<h2> 原始 HTML</h2>
<p>双大括号会将数据解释为纯文本，而不是 HTML。若想插入 HTML，你需要使用 <code>v-html</code> 指令：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Using text interpolation: {{ rawHtml }}</p>
<p>Using v-html directive: <span v-html="rawHtml"></span></p>
<p>这里我们遇到了一个新的概念。这里看到的 <code>v-html</code> attribute 被称为一个指令。指令由 <code>v-</code> 作为前缀，表明它们是一些由 Vue 提供的特殊 attribute，你可能已经猜到了，它们将为渲染的 DOM 应用特殊的响应式行为。这里我们做的事情简单来说就是：在当前组件实例上，将此元素的 innerHTML 与 <code>rawHtml</code> 属性保持同步。</p>
<p><code>span</code> 的内容将会被替换为 <code>rawHtml</code> 属性的值，插值为纯 HTML——数据绑定将会被忽略。</p>
<div class="hint-container note">
<p class="hint-container-title">注</p>
<p>你不能使用 <code>v-html</code> 来拼接组合模板，因为 Vue 不是一个基于字符串的模板引擎。在使用 Vue 时，应当使用组件作为 UI 重用和组合的基本单元。</p>
</div>
<div class="hint-container warning">
<p class="hint-container-title">安全警告</p>
<p>在网站上动态渲染任意 HTML 是非常危险的，因为这非常容易造成 XSS 漏洞。请仅在内容安全可信时再使用 <code>v-html</code>，并且永远不要使用用户提供的 HTML 内容。</p>
</div>
<h2> Attribute 绑定</h2>
<p>双大括号不能在 HTML attributes 中使用。想要响应式地绑定一个 attribute，应该使用 <code>v-bind</code> 指令：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>v-bind</code> 指令指示 Vue 将元素的 <code>id</code> attribute 与组件的 <code>dynamicId</code> 属性保持一致。如果绑定的值是 <code>null</code> 或者 <code>undefined</code>，那么该 attribute 将会从渲染的元素上移除。</p>
<h3> 简写</h3>
<p>因为 <code>v-bind</code> 非常常用，我们提供了特定的简写语法：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开头为 <code>:</code> 的 attribute 可能和一般的 HTML attribute 看起来不太一样，但它的确是合法的 attribute 名称字符，并且所有支持 Vue 的浏览器都能正确解析它。此外，他们不会出现在最终渲染的 DOM 中。简写语法是可选的，但相信在你了解了它更多的用处后，你应该会更喜欢它。</p>
<p>接下来的指引中，我们都将在示例中使用简写语法，因为这是在实际开发中更常见的用法。</p>
<h3> 布尔型 Attribute</h3>
<p>布尔型 attribute 依据 true / false 值来决定 attribute 是否应该存在于该元素上。disabled 就是最常见的例子之一。</p>
<p><code>v-bind</code> 在这种场景下的行为略有不同：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当 <code>isButtonDisabled</code> 为真值或一个空字符串 (即 <code>&lt;button disabled=""&gt;</code>) 时，元素会包含这个 <code>disabled</code> attribute。而当其为其他假值时 attribute 将被忽略。</p>
<h3> 动态绑定多个值</h3>
<p>如果你有像这样的一个包含多个 attribute 的 JavaScript 对象：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过不带参数的 <code>v-bind</code>，你可以将它们绑定到单个元素上：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 使用 JavaScript 表达式</h2>
<p>至此，我们仅在模板中绑定了一些简单的属性名。但是 Vue 实际上在所有的数据绑定中都支持完整的 JavaScript 表达式：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些表达式都会被作为 JavaScript ，以当前组件实例为作用域解析执行。</p>
<p>在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：</p>
<ul>
<li>在文本插值中 (双大括号)</li>
<li>在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中</li>
</ul>
<h3> 仅支持表达式</h3>
<p>每个绑定仅支持单一表达式，也就是一段能够被求值的 JavaScript 代码。一个简单的判断方法是是否可以合法地写在 return 后面。</p>
<p>因此，下面的例子都是无效的：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 调用函数</h3>
<p>可以在绑定的表达式中使用一个组件暴露的方法：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>绑定在表达式中的方法在组件每次更新时都会被重新调用，因此不应该产生任何副作用，比如改变数据或触发异步操作。</p>
</div>
<h3> 受限的全局访问</h3>
<p>模板中的表达式将被沙盒化，仅能够访问到有限的全局对象列表。该列表中会暴露常用的内置全局对象，比如 <code>Math</code> 和 <code>Date</code>。</p>
<p>没有显式包含在列表中的全局对象将不能在模板内表达式中访问，例如用户附加在 window 上的属性。然而，你也可以自行在 <code>app.config.globalProperties</code> 上显式地添加它们，供所有的 Vue 表达式使用。</p>
<h2> 指令 Directives</h2>
<p>指令是带有 <code>v-</code> 前缀的特殊 attribute。Vue 提供了许多内置指令，包括上面我们所介绍的 <code>v-bind</code> 和 <code>v-html</code>。</p>
<p>指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即之后要讨论到的 <code>v-for</code>、<code>v-on</code> 和 <code>v-slot</code>)。一个指令的任务是在其表达式的值变化时响应式地更新 DOM。以 <code>v-if</code> 为例：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这里，v-if 指令会基于表达式 seen 的值的真假来移除/插入该 <code>&lt;p&gt;</code> 元素。</p>
<h3> 参数 Arguments</h3>
<p>某些指令会需要一个“参数”，在指令名后通过一个冒号隔开做标识。例如用 <code>v-bind</code> 指令来响应式地更新一个 HTML attribute：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里 href 就是一个参数，它告诉 <code>v-bind</code> 指令将表达式 url 的值绑定到元素的 <code>href</code> attribute 上。在简写中，参数前的一切 (例如 <code>v-bind:</code>) 都会被缩略为一个 <code>:</code> 字符。</p>
<p>另一个例子是 <code>v-on</code> 指令，它将监听 DOM 事件：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的参数是要监听的事件名称：<code>click</code>。<code>v-on</code> 有一个相应的缩写，即 <code>@</code> 字符。</p>
<h3> 动态参数</h3>
<p>同样在指令参数上也可以使用一个 JavaScript 表达式，需要包含在一对方括号内：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 <code>attributeName</code> 会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。举例来说，如果你的组件实例有一个数据属性 <code>attributeName</code>，其值为 <code>"href"</code>，那么这个绑定就等价于 <code>v-bind:href</code>。</p>
<p>相似地，你还可以将一个函数绑定到动态的事件名称上：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在此示例中，当 <code>eventName</code> 的值是 <code>"focus"</code> 时，<code>v-on:[eventName]</code> 就等价于 <code>v-on:focus</code>。</p>
<h3> 动态参数值的限制</h3>
<p>动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。</p>
<h3> 动态参数语法的限制</h3>
<p>动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。例如下面的示例：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你需要传入一个复杂的动态参数，我们推荐使用计算属性替换复杂的表达式，也是 Vue 最基础的概念之一。</p>
<p>当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母，因为浏览器会强制将其转换为小写：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的例子将会在 DOM 内嵌模板中被转换为 <code>:[someattr]</code>。如果你的组件拥有 “someAttr” 属性而非 “someattr”，这段代码将不会工作。单文件组件内的模板不受此限制。</p>
<h3> 修饰符 Modifiers</h3>
<p>修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。例如 <code>.prevent</code> 修饰符会告知 <code>v-on</code> 指令对触发的事件调用 <code>event.preventDefault()</code>：</p>
<div class="language-template line-numbers-mode" data-ext="template"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Vue Router</title>
      <link>https://leijue222.github.io/tutorial/front-end/vue/router/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/vue/router/</guid>
      <source url="https://leijue222.github.io/rss.xml">Vue Router</source>
      <description>Vue Router 是 Vue 官方出品的路由组件，托管整个 Vue 项目路由。</description>
      <category>Vue</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Vue Router 是 Vue 官方出品的路由组件，托管整个 Vue 项目路由。</p>
<!-- more -->
<h2> 目录</h2>
<ul>
<li><a href="/tutorial/front-end/vue/router/get-started.html" target="blank">快速上手 Vue Router</a></li>
</ul>
<h2> 官方文档</h2>
<ul>
<li>
<p><a href="https://router.vuejs.org/zh/guide/" target="_blank" rel="noopener noreferrer">Vue-Router 指南</a></p>
</li>
<li>
<p><a href="https://router.vuejs.org/zh/api/" target="_blank" rel="noopener noreferrer">Vue-Router API 参考</a></p>
</li>
<li>
<p><a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener noreferrer">官方仓库</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>快速上手</title>
      <link>https://leijue222.github.io/tutorial/front-end/vue/router/get-started.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/vue/router/get-started.html</guid>
      <source url="https://leijue222.github.io/rss.xml">快速上手</source>
      <description>介绍 Vue Router 是 Vue 官方出品的路由组件，托管整个 Vue 项目路由。 Route 属性 在日常开发中，我们主要关注选项中的 routes 属性。routes 属性是一个数组，其每一个元素是一个对象，对象会包含 path，`component 两个必填属性与 meta 和 name 两个可选属性。 path: 填入需要配置的网站页面的...</description>
      <category>Vue</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 介绍</h2>
<p>Vue Router 是 Vue 官方出品的路由组件，托管整个 Vue 项目路由。</p>
<h2> Route 属性</h2>
<p>在日常开发中，我们主要关注选项中的 <code>routes</code> 属性。<code>routes</code> 属性是一个数组，其每一个元素是一个对象，对象会包含 <code>path</code>，<code>component</code> 两个必填属性与 <code>meta</code> 和 <code>name</code> 两个可选属性。</p>
<ul>
<li>
<p><code>path</code>: 填入需要配置的网站页面的 <code>url</code></p>
</li>
<li>
<p><code>conponent</code>: 导入需要显示的 Vue 文件组件</p>
</li>
<li>
<p><code>name</code> (可选): 指定该组件与 <code>url</code> 的别名</p>
</li>
<li>
<p><code>meta</code> (可选): 该属性可以填入该界面的额外信息 (比如 <code>title</code>、<code>author</code> 等)</p>
</li>
</ul>
<p>也就是说，Vue 项目网站能够访问到的地址都能够被 <code>route</code> 数组中的某个元素的 <code>path</code> 值所匹配，此时页面展示的是该元素 <code>component</code> 属性对应的 vue 文件视图。</p>
<p>当希望在 Vue 项目中添加新的界面的时候，只需制作好其组件文件，并在 <code>route</code> 数组中添加新项，指定的带设定 <code>url</code> 路径为响应 vue 文件即可。</p>
<h2> 载入 Router</h2>
<p>通过调用 app.use(router)，我们会触发第一次导航且可以在任意组件中以 this.route 的形式访问当前路由：</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 导航</h2>
<p>使用 Vue Router 进行界面间导航有两种方式。一种是通过在视图层定义，一种在脚本中定义。</p>
<h3> 视图层</h3>
<p>使用 <code>router-link</code> 标签进行导航。</p>
<p><code>router-link</code> 标签可以设置以下几个属性:</p>
<ul>
<li>
<p><code>to</code>: 填入想要导航的地址，可以是绝对路径也可以是相对路径。</p>
</li>
<li>
<p><code>tag</code>(可选): 控制 <code>router-link</code> 最终渲染的标签，默认渲染为 <code>a</code> 标签。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> 函数层</h3>
<ul>
<li>
<p><code>router.push(location)</code>: 直接填入一个地址，将导航到这个新地址中。</p>
<blockquote>
<p>location 接受多种类型的格式:</p>
</blockquote>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><code>router.replace(location)</code>: 直接填入一个地址，将当前界面重定向到这个新地址中。它不会向 <code>history</code> 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 <code>history</code> 记录。</p>
<blockquote>
<p>location 的格式同上</p>
</blockquote>
</li>
<li>
<p><code>router.go(n)</code>: 填入一个整数，如果为正，则前进 <code>n</code> 步，反之后退。</p>
</li>
<li>
<p><code>router.back()</code>: 后退一步</p>
</li>
<li>
<p><code>router.forward()</code>: 前进一步</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>编程式导航对动态导航是十分有用的，比如需要根据不同人的名字导航到不同界面，这个时候就可以动态生成路由，再使用 <code>router.push</code> 函数导航到相应界面。</p>
]]></content:encoded>
    </item>
    <item>
      <title>CSS</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/css/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/css/</guid>
      <source url="https://leijue222.github.io/rss.xml">CSS</source>
      <description>CSS 指层叠样式表 (Cascading Style Sheets)，它负责描述网页元素的具体样式。 CSS3 是最新的 CSS 标准，被拆分为&amp;quot;模块&amp;quot;。模块包括: 选择器、盒模型、背景和边框、文字特效、2D/3D 转换、动画、多列布局、用户界面。</description>
      <category>CSS</category>
      <pubDate>Thu, 05 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>CSS 指层叠样式表 (<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)，它负责描述网页元素的具体样式。</p>
<p>CSS3 是最新的 CSS 标准，被拆分为"模块"。模块包括: 选择器、盒模型、背景和边框、文字特效、2D/3D 转换、动画、多列布局、用户界面。</p>
<!-- more -->
<h2> 目录</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/website/css/guide/" target="blank">快速上手</a></p>
<ul>
<li><a href="/tutorial/front-end/website/css/guide/selector.html" target="blank">CSS 选择器</a></li>
<li><a href="/tutorial/front-end/website/css/guide/declaration.html" target="blank">CSS 声明</a></li>
<li><a href="/tutorial/front-end/website/css/guide/import.html" target="blank">CSS 引入</a></li>
<li><a href="/tutorial/front-end/website/css/guide/common.html" target="blank">CSS 常用属性介绍</a></li>
<li><a href="/tutorial/front-end/website/css/guide/box.html" target="blank">CSS 盒模型</a></li>
</ul>
</li>
<li>
<p><a href="/tutorial/front-end/website/css/layout/" target="blank">CSS 布局介绍</a></p>
<ul>
<li><a href="/tutorial/front-end/website/css/layout/flex.html" target="blank">CSS 弹性模型</a></li>
<li><a href="/tutorial/front-end/website/css/layout/exercise.html" target="blank">CSS 布局实战</a></li>
<li><a href="/tutorial/front-end/website/css/layout/grid.html" target="blank">CSS 网格模型</a></li>
</ul>
</li>
<li>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/First_steps/CSS%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener noreferrer">CSS 工作原理</a></p>
</li>
</ul>
<h2> CSS 参考</h2>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener noreferrer">MDN 教程</a></li>
</ul>
<h2> 其他文档 </h2>
<ul>
<li>
<p>CSS</p>
<ul>
<li><a href="https://www.w3cschool.cn/css/" target="_blank" rel="noopener noreferrer">W3CSchool 教程</a></li>
<li><a href="http://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></li>
<li><a href="https://www.runoob.com/css/css-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></li>
</ul>
</li>
<li>
<p>CSS3</p>
<ul>
<li><a href="https://www.w3cschool.cn/css3/" target="_blank" rel="noopener noreferrer">W3CSchool 教程</a></li>
<li><a href="http://www.w3school.com.cn/css3/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></li>
<li><a href="https://www.runoob.com/css3/css3-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></li>
</ul>
</li>
</ul>
<h2> 在线练习网址</h2>
<ul>
<li><a href="https://c.runoob.com/front-end/61" target="_blank" rel="noopener noreferrer">菜鸟教程在线工具</a></li>
<li><a href="https://jsfiddle.net/" target="_blank" rel="noopener noreferrer">jsfiddle</a></li>
</ul>
<h2> CSS 的超集</h2>
<ul>
<li>
<p>Stylus</p>
<p>带来更简单的写法，支持变量、函数等功能。</p>
<ul>
<li><a href="https://www.zhangxinxu.com/jq/stylus/" target="_blank" rel="noopener noreferrer">中文文档</a></li>
<li><a href="http://stylus-lang.com/" target="_blank" rel="noopener noreferrer">官方文档</a></li>
</ul>
</li>
<li>
<p>Sass</p>
<p>Sass 是世界上最成熟、稳定、强大的专业级 CSS 扩展语言。</p>
<blockquote>
<p>注: 官网说的，不是我说的 😂</p>
</blockquote>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>SCSS 是 Sass3 版本当中引入的新语法特性,完全兼容 CSS3 的同时继承了 Sass 强大的动态功能。</p>
</div>
<ul>
<li><a href="https://sass.bootcss.com/" target="_blank" rel="noopener noreferrer">中文文档</a></li>
<li><a href="https://sass-lang.com/" target="_blank" rel="noopener noreferrer">官方文档</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>定义</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/definition/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/definition/</guid>
      <source url="https://leijue222.github.io/rss.xml">定义</source>
      <description>定义列表 URI 统一资源标识符 (uri.md); URL 统一资源定位符 (url.md); SEO 搜索引擎优化 (seo.md); MIME Type 媒体类型 (mime.md);</description>
      <category>HTML</category>
      <pubDate>Mon, 02 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 定义列表</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/website/definition/uri.html" target="blank">URI 统一资源标识符</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/definition/url.html" target="blank">URL 统一资源定位符</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/definition/seo.html" target="blank">SEO 搜索引擎优化</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/definition/mime.html" target="blank">MIME Type 媒体类型</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Http 与 Https 介绍</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/definition/https.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/definition/https.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Http 与 Https 介绍</source>
      <description>什么是 HTTP 协议 HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。 Http 漫画 HTTP 协议通过 请求/响应 的方式，在客户端和服务端之间进行通信。 Http 漫画 这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: 不够安全。 HT...</description>
      <pubDate>Sun, 03 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是 HTTP 协议</h2>
<p>HTTP 协议全称 Hyper Text Transfer Protocol，翻译过来就是超文本传输协议，位于 TCP/IP 四层模型当中的应用层。</p>
<p></p>
<p>HTTP 协议通过 <strong>请求/响应</strong> 的方式，在客户端和服务端之间进行通信。</p>
<p></p>
<p>这一切看起来很美好，但是 HTTP 协议有一个致命的缺点: <strong>不够安全</strong>。</p>
<p>HTTP 协议的信息传输完全以明文方式，不做任何加密，相当于是在网络上“裸奔”。这样会导致什么问题呢? 让我们打一个比方:</p>
<p>小灰是客户端，小灰的同事小红是服务端，有一天小灰试图给小红发送请求。</p>
<p></p>
<p>但是，由于传输信息是明文，这个信息有可能被某个中间人恶意截获甚至篡改。这种行为叫做<strong>中间人攻击</strong>。</p>
<p></p>
<p></p>
<p></p>
<p>如何进行加密呢?</p>
<p>小灰和小红可以事先约定一种<strong>对称加密</strong>方式，并且约定一个随机生成的密钥。后续的通信中，信息发送方都使用密钥对信息加密，而信息接收方通过同样的密钥对信息解密。</p>
<p></p>
<p></p>
<p>这样做是不是就绝对安全了呢? 并不是。</p>
<p>虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信仍然是明文，如果第一次通信就已经被拦截了，那么密钥就会泄露给中间人，中间人仍然可以解密后续所有的通信内容。</p>
<p></p>
<p>这可怎么办呢? 别担心，我们可以使用<strong>非对称加密</strong>，为密钥的传输做一层额外的保护。</p>
<p>非对称加密的一组秘钥对中，包含一个公钥和一个私钥。明文既可以用公钥加密，用私钥解密；也可以用私钥加密，用公钥解密。</p>
<p>在小灰和小红建立通信的时候，小红首先把自己的公钥 Key1 发给小灰:</p>
<p></p>
<p>收到小红的公钥以后，小灰自己生成一个用于对称加密的密钥 Key2，并且用刚才接收的公钥 Key1 对 Key2 进行加密(这里有点绕)，发送给小红:</p>
<p></p>
<p>小红利用自己非对称加密的私钥，解开了公钥 Key1 的加密，获得了 Key2 的内容。从此以后，两人就可以利用 Key2 进行对称加密的通信了。</p>
<p></p>
<p>在通信过程中，即使中间人在一开始就截获了公钥 Key1，由于不知道私钥是什么，也无从解密。</p>
<p></p>
<p></p>
<p>是什么坏主意呢? 中间人虽然不知道小红的私钥是什么，但是在截获了小红的公钥 Key1 之后，却可以偷天换日，自己另外生成一对公钥私钥，把自己的公钥 Key3 发送给小灰。</p>
<p></p>
<p>小灰不知道公钥被偷偷换过，以为 Key3 就是小红的公钥。于是按照先前的流程，用 Key3 加密了自己生成的对称加密密钥 Key2，发送给小红。</p>
<p>这一次通信再次被中间人截获，中间人先用自己的私钥解开了 Key3 的加密，获得 Key2，然后再用当初小红发来的 Key1 重新加密，再发给小红。</p>
<p></p>
<p>这样一来，两个人后续的通信尽管用 Key2 做了对称加密，但是中间人已经掌握了 Key2，所以可以轻松进行解密。</p>
<p></p>
<p></p>
<p>是什么解决方案呢? 难道再把公钥进行一次加密吗? 这样只会陷入鸡生蛋蛋生鸡，永无止境的困局。</p>
<p>这时候，我们有必要引入第三方，一个权威的证书颁发机构(CA)来解决。</p>
<p>到底什么是证书呢? 证书包含如下信息:</p>
<p></p>
<p>为了便于说明，我们这里做了简化，只列出了一些关键信息。至于这些证书信息的用处，我们看看具体的通信流程就能够弄明白了。</p>
<p>流程如下:</p>
<ol>
<li>
<p>作为服务端的小红，首先把自己的公钥发给证书颁发机构，向证书颁发机构申请证书。</p>
<p></p>
</li>
<li>
<p>证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密 Key1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了服务端小红。</p>
<p></p>
</li>
<li>
<p>当小灰向小红请求通信的时候，小红不再直接返回自己的公钥，而是把自己申请的证书返回给小灰。</p>
<p></p>
</li>
<li>
<p>小灰收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥。所以小灰只需要知道是</p>
<p>哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。</p>
<p>接下来，小灰按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。</p>
<p>验证成功后，小灰就可以放心地再次利用机构公钥，解密出服务端小红的公钥 Key1。</p>
<p></p>
</li>
<li>
<p>像之前一样，小灰生成自己的对称加密密钥 Key2，并且用服务端公钥 Key1 加密 Key2，发送给小红。</p>
<p></p>
</li>
<li>
<p>最后，小红用自己的私钥解开加密，得到对称加密密钥 Key2。于是两人开始用 Key2 进行对称加密的通信。</p>
<p></p>
</li>
</ol>
<p>在这样的流程下，我们不妨想一想，中间人是否还具有使坏的空间呢?</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>最新推出的 TLS 协议，是 SSL 3.0 协议的升级版，和 SSL 协议的大体原理是相同的。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>MIME type</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/definition/mime.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/definition/mime.html</guid>
      <source url="https://leijue222.github.io/rss.xml">MIME type</source>
      <description>MIME type，即媒体类型(media type) (有时是“内容类型(content type)”) 是指示文件类型的字符串，与文件一起发送。 例如，一个声音文件可能被标记为 audio/ogg ，一个图像文件可能是 image/png。 它与传统 Windows 上的文件扩展名有相同目的。</description>
      <category>HTML</category>
      <pubDate>Mon, 02 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>MIME type，即媒体类型(media type) (有时是“内容类型(content type)”) 是指示文件类型的字符串，与文件一起发送。</p>
<p>例如，一个声音文件可能被标记为 <code>audio/ogg</code> ，一个图像文件可能是 <code>image/png</code>。</p>
<p>它与传统 Windows 上的文件扩展名有相同目的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>SEO</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/definition/seo.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/definition/seo.html</guid>
      <source url="https://leijue222.github.io/rss.xml">SEO</source>
      <description>简介 搜索引擎优化 (Search Engine Optimization)，是一种透过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。由于不少研究发现，搜索引擎的用户往往只会留意搜索结果最前面的几个条目，所以不少网站都希望透过各种形式来影响搜索引擎的排序，让自己的网站可以有优秀的搜索排名。 所谓“针对搜索引擎作最优化的处...</description>
      <category>HTML</category>
      <pubDate>Mon, 02 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>搜索引擎优化 (<strong>S</strong>earch <strong>E</strong>ngine <strong>O</strong>ptimization)，是一种透过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。由于不少研究发现，搜索引擎的用户往往只会留意搜索结果最前面的几个条目，所以不少网站都希望透过各种形式来影响搜索引擎的排序，让自己的网站可以有优秀的搜索排名。</p>
<p>所谓“针对搜索引擎作最优化的处理”，是指为了要让网站更容易被搜索引擎接受。搜索引擎会将网站彼此间的内容做一些相关性的资料比对，然后再由浏览器将这些内容以最快速且接近最完整的方式，呈现给搜索者。搜索引擎优化就是通过搜索引擎的规则进行优化，为用户打造更好的用户体验，最终的目的就是做好用户体验。</p>
<h2> 相关文档</h2>
<ul>
<li>
<p><a href="https://schema.org/" target="_blank" rel="noopener noreferrer">Schema Org</a></p>
<ul>
<li>
<p><a href="https://schema.org/docs/gs.html" target="_blank" rel="noopener noreferrer">快速上手</a></p>
</li>
<li>
<p><a href="https://schema.org/docs/full.html" target="_blank" rel="noopener noreferrer">全部的 Schema 列表</a></p>
</li>
</ul>
</li>
<li>
<p><a href="https://ogp.me/" target="_blank" rel="noopener noreferrer">开放内容协议 OGP</a> (<strong>O</strong>pen <strong>G</strong>raph <strong>Pr</strong>otocal)</p>
</li>
<li>
<p><a href="https://developers.google.com/search/docs/" target="_blank" rel="noopener noreferrer">Google 搜索指南</a></p>
<ul>
<li><a href="https://developers.google.com/search/docs/guides/get-started" target="_blank" rel="noopener noreferrer">快速上手</a></li>
</ul>
</li>
</ul>
<h2> 相关工具</h2>
<ul>
<li>
<p><a href="https://developers.google.com/search" target="_blank" rel="noopener noreferrer">Google 搜索中心</a></p>
</li>
<li>
<p><a href="https://search.google.com/search-console/" target="_blank" rel="noopener noreferrer">Google Search Console</a></p>
<p>Search Console 是 Google 推出的一款免费工具，可帮助开发者、网站所有者和搜索引擎优化专家了解其网站在 Google 搜索上的表现。</p>
</li>
<li>
<p><a href="https://search.google.com/test/rich-results" target="_blank" rel="noopener noreferrer">Google 富媒体测试工具</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>URI</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/definition/uri.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/definition/uri.html</guid>
      <source url="https://leijue222.github.io/rss.xml">URI</source>
      <description>简介 统一资源标识符(英语: Uniform Resource Identifier，缩写: URI)在电脑术语中是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中(一般指万维网)的资源通过特定的协议进行交互操作。URI 的最常见的形式是统一资源定位符(URL)，经常指定为非正式的网址。更罕见的用法是统一资源名称(URN)，其目的是通...</description>
      <category>HTML</category>
      <pubDate>Mon, 02 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p><strong>统一资源标识符</strong>(英语: Uniform Resource Identifier，缩写: URI)在电脑术语中是一个用于标识某一互联网资源名称的字符串。</p>
<p>该种标识允许用户对网络中(一般指万维网)的资源通过特定的协议进行交互操作。URI 的最常见的形式是统一资源定位符(URL)，经常指定为非正式的网址。更罕见的用法是统一资源名称(URN)，其目的是通过提供一种途径。用于在特定的名字空间资源的标识，以补充网址。</p>
<h2> 与 URL 和 URN 的关系</h2>
<h3> URN</h3>
<p><strong>统一资源名称</strong>(英语: Uniform Resource Name，缩写: URN)是统一资源标识(URI)的历史名字，它使用 <code>urn:</code> 作为 URI scheme。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>更多详情请见 <a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%90%8D" target="_blank" rel="noopener noreferrer">维基百科</a></p>
</div>
<h3> URL</h3>
<p><strong>统一资源定位符</strong>(英语: Uniform Resource Locator，缩写: URL；或称统一资源定位器、定位地址、URL 地址，俗称网页地址或简称网址)是因特网上标准的资源的地址(Address)，如同在网络上的门牌。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>更多详情请见 <a href="/tutorial/front-end/website/definition/url.html" target="blank">URL</a></p>
</div>
<h3> 关系</h3>
<p></p>
<p>URL(定位符)和 URN(名称)方案属于 URI 的子类，URI 可以为 URL 或 URN 两者之一或同时是 URI 和 URN。技术上讲，URL 和 URN 属于资源 ID；但是，人们往往无法将某种方案归类于两者中的某一个: 所有的 URI 都可被作为名称看待，而某些方案同时体现了两者中的不同部分。
URI 可被视为定位符(URL)，名称(URN)或两者兼备。统一资源名(URN)如同一个人的名称，而统一资源定位符(URL)代表一个人的住址。换言之，URN 定义某事物的身份，而 URL 提供查找该事物的方法。</p>
<div class="hint-container tip">
<p class="hint-container-title">例子</p>
<p>用于标识唯一书目的 ISBN 系统是一个典型的 URN 使用范例。例如，ISBN <code>0-486-27557-4</code> 无二义性地标识出莎士比亚的戏剧《罗密欧与朱丽叶》的某一特定版本。为获得该资源并阅读该书，人们需要它的位置，也就是一个 URL 地址。在类 Unix 操作系统中，一个典型的 URL 地址可能是一个文件目录，例如 <code>file:///home/username/RomeoAndJuliet.pdf</code>。该 URL 标识出存储于本地硬盘中的电子书文件。因此，URL 和 URN 有着互补的作用。</p>
</div>
<h3> 技术观点</h3>
<p>URL 是一种 URI，它标识一个互联网资源，并指定对其进行操作或获取该资源的方法。可能通过对主要访问手段的描述，也可能通过网络“位置”进行标识。例如，<a href="http://www.wikipedia.org/" target="_blank" rel="noopener noreferrer">http://www.wikipedia.org/</a> 这个 URL，标识一个特定资源(首页)并表示该资源的某种形式(例如以编码字符表示的，首页的 HTML 代码)是可以通过 HTTP 协议从 <code>www.wikipedia.org</code> 这个网络主机获得的。URN 是基于某名字空间通过名称指定资源的 URI。人们可以通过 URN 来指出某个资源，而无需指出其位置和获得方式。资源无需是基于互联网的。例如，URN <code>urn:ISBN 0-395-36341-1</code> 指定标识系统(即国际标准书号 ISBN)和某资源在该系统中的唯一表示的 URI。它可以允许人们在不指出其位置和获得方式的情况下谈论这本书。</p>
<p>技术刊物，特别是 IETF 和 W3C 发布的标准中，通常不再使用“URL”这一术语，因为很少需要区别 URL 和 URI。但是，在非技术文献和万维网软件中，URL 这一术语仍被广泛使用。此外，术语“网址”(没有正式定义)在非技术文献中时常作为 URL 或 URI 的同义词出现，虽然往往其指代的只是“http”和“https”协议。</p>
<h2> 文法格式</h2>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>URL</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/definition/url.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/definition/url.html</guid>
      <source url="https://leijue222.github.io/rss.xml">URL</source>
      <description>简介 统一资源定位符(英语: Uniform Resource Locator，缩写: URL；或称统一资源定位器、定位地址、URL 地址，俗称网页地址或简称网址)是因特网上标准的资源的地址(Address)，如同在网络上的门牌。 统一资源定位符的标准格式如下: 统一资源定位符的完整格式如下: 更多详情请见 维基百科 (https://zh.wikip...</description>
      <category>HTML</category>
      <pubDate>Mon, 02 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p><strong>统一资源定位符</strong>(英语: Uniform Resource Locator，缩写: URL；或称统一资源定位器、定位地址、URL 地址，俗称网页地址或简称网址)是因特网上标准的资源的地址(Address)，如同在网络上的门牌。</p>
<p>统一资源定位符的标准格式如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>统一资源定位符的完整格式如下:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>更多详情请见 <a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E5%AE%9A%E4%BD%8D%E7%AC%A6" target="_blank" rel="noopener noreferrer">维基百科</a></p>
</div>
<h2> 绝对 URL 和相对 URL</h2>
<p>您可能会在网络上遇到两个术语，绝对 URL 和相对 URL(或者称为，绝对链接和相对链接):</p>
<h3> 绝对 URL</h3>
<p>指向由其在 Web 上的绝对位置定义的位置，包括 protocol(协议) 和 domain name(域名)。</p>
<div class="hint-container tip">
<p class="hint-container-title">例子</p>
<p>如果 index.html 页面上传到 projects 这一个目录。并且 projects 目录位于 web 服务站点的根目录，web 站点的域名为 <code>http://www.example.com</code>，那么这个页面就可以通过 <code>http://www.example.com/projects/index.html</code> 访问(或者通过 <code>http://www.example.com/projects/</code> 来访问，因为在没有指定特定的 URL 的情况下，大多数 web 服务会默认访问加载 <code>index.html</code> 这类页面)</p>
</div>
<p>不管绝对 URL 在哪里使用，它总是指向确定的相同位置。</p>
<h3> 相对 URL</h3>
<p>指向与您链接的文件相关的位置，更像我们在前面一节中所看到的位置。例如，如果我们想从示例文件链接 <code>http://www.example.com/projects/index.html</code> 转到相同目录下的一个 PDF 文件，URL 就是文件名 URL(如: <code>project-brief.pdf</code>)。如果 PDF 文件能够在 projects 的子目录 pdfs 中访问到，相对路径就是 <code>pdfs/project-brief.pdf</code>(对应的绝对 URL 是 <code>http://www.example.com/projects/pdfs/project-brief.pdf</code>)</p>
<p>一个相对 URL 将指向不同的位置，这取决于它所在的文件所在的位置——例如，如果我们把 index.html 文件从 projects 目录移动到 Web 站点的根目录(最高级别，而不是任何目录中)，里面的 <code>pdfs/project-brief.pdf</code> 相对 URL 将会指向 <code>http://www.example.com/pdfs/project-brief.pdf</code>，而不是 <code>http://www.example.com/projects/pdfs/project-brief.pdf</code></p>
<p>当然，project-brief.pdf 文件和 pdfs 文件夹的位置不会因为您移动了 <code>index.html</code> 文件而突然发生变化——这将使您的链接指向错误的位置，因此如果单击它，它将无法工作。您得小心点!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Emmet 语法</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/emmet/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/emmet/</guid>
      <source url="https://leijue222.github.io/rss.xml">Emmet 语法</source>
      <description>简介 所有操作按下 “tab” 键即可瞬间完成 Emmet 是一个快速创建 HTML 和 CSS 的方式，如果您想要成为一个高级 Web 开发者，为了工作效率，您应该掌握 Emmet 语法。</description>
      <category>Emmet</category>
      <pubDate>Tue, 03 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">简介</p>
<p>所有操作按下 “tab” 键即可瞬间完成</p>
</div>
<p>Emmet 是一个快速创建 HTML 和 CSS 的方式，如果您想要成为一个高级 Web 开发者，为了工作效率，您应该掌握 Emmet 语法。</p>
<!-- more -->
<h2> HTML</h2>
<ul>
<li><a href="/tutorial/front-end/website/emmet/html.html" target="blank">HTML Emmet 语法</a></li>
</ul>
<h2> CSS</h2>
<ul>
<li><a href="/tutorial/front-end/website/emmet/css.html" target="blank">CSS Emmet 语法</a></li>
</ul>
<h2> 其他功能</h2>
<p>Emmet 还提供了很多内置功能，在 VS Code 中，您可以按下 <code>F1</code> 并输入 <code>emmet</code> 来查看功能列表。详细的功能列表说明请见 <a href="https://docs.emmet.io/actions/" target="_blank" rel="noopener noreferrer">Emmet 文档</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>CSS Emmet</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/emmet/css.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/emmet/css.html</guid>
      <source url="https://leijue222.github.io/rss.xml">CSS Emmet</source>
      <description>对于 CSS 语法，Emmet 为属性提供了许多预定义的代码段。 添加属性 您可以使用缩写来生成 CSS 属性。如 m 会生成 margin: ;，同时光标会自动置于值处。 同时添加属性与值值 您可以将值直接输入缩写的后面，如果有多个值，您需要用 - 将它们分开，多余的 - 将会被理解为负值。 案例 m10: margin: 10px;; m10-20...</description>
      <category>Emmet</category>
      <pubDate>Tue, 03 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>对于 CSS 语法，Emmet 为属性提供了许多预定义的代码段。</p>
<h2> 添加属性</h2>
<p>您可以使用缩写来生成 CSS 属性。如 <code>m</code> 会生成 <code>margin: ;</code>，同时光标会自动置于值处。</p>
<h2> 同时添加属性与值值</h2>
<p>您可以将值直接输入缩写的后面，如果有多个值，您需要用 <code>-</code> 将它们分开，多余的 <code>-</code> 将会被理解为负值。</p>
<div class="hint-container tip">
<p class="hint-container-title">案例</p>
<ul>
<li><code>m10</code>: <code>margin: 10px;</code></li>
<li><code>m10-20</code>: <code>margin: 10px 20px;</code></li>
<li><code>m-10--20</code>: <code>margin: -10px -20px;</code></li>
</ul>
</div>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>请只有在必要(不添加会产生歧义)的情况下添加 <code>-</code> 分隔符，否则 Emmet 可能会错误的理解它。</p>
</div>
<h2> 值的单位</h2>
<p>使用整数值扩展缩写时，Emmet 会以 px 单位输出: <code>m10</code> → <code>margin: 10px;</code>。</p>
<p>使用浮点值扩展缩写时，会以 em 单位输出: <code>m1.5</code> → <code>margin: 1.5em;</code>。</p>
<p>您也可以在值后面紧跟任何字母字符，来显式提供单位名称: <code>m1.5ex</code> → <code>margin: 1.5ex;</code>，<code>m10foo</code> → <code>margin: 10foo;</code>。</p>
<p>明确定义单位后，不再需要使用连字符来分隔值: <code>m10ex20em</code> → <code>margin: 10ex 20em;</code>，<code>m10ex-5</code> → <code>margin: 10ex -5px;</code>。</p>
<h2> 值别名</h2>
<p>Emmet 具有一些常用值的别名:</p>
<ul>
<li><code>p</code> → <code>%</code></li>
<li><code>e</code> → <code>em</code></li>
<li><code>x</code> → <code>ex</code></li>
</ul>
<p>您可以使用别名代替完整的单位:</p>
<ul>
<li><code>w100p</code> → <code>width: 100%</code></li>
<li><code>m10p30e5x</code> → <code>margin: 10% 30em 5ex</code></li>
</ul>
<h2> 颜色值</h2>
<p>Emmet 支持十六进制颜色值。<code>#</code> 将自动作为分隔符，所以针对颜色变量，将不再需要 <code>-</code>。</p>
<ul>
<li><code>c#3</code> → <code>color: #333;</code></li>
<li><code>bd5#0s</code> → <code>border: 5px #000 solid</code>。(<code>#</code> 符号可将颜色与 <code>5</code> 分隔开，并且 <code>s</code>(别名为 <code>solid</code>)不是十六进制字符，因此省略了 <code>-</code>。</li>
</ul>
<p>颜色变量支持 1-3 位的缩写，表现如下:</p>
<ul>
<li><code>#1</code> → <code>#111111</code></li>
<li><code>#e0</code> → <code>#e0e0e0</code></li>
<li><code>#fc0</code> → <code>#ffcc00</code></li>
</ul>
<h2> 无单元属性</h2>
<p>一些 CSS 属性默认为无单位输出:</p>
<ul>
<li><code>lh2</code>→ <code>line-height: 2;</code></li>
<li><code>fw400</code>→ <code>font-weight: 400</code>。</li>
</ul>
<p>这些值是: <code>z-index</code>，<code>line-height</code>，<code>opacity</code> 和 <code>font-weight</code></p>
<h2> 重要修饰符</h2>
<p>您可以在任何 CSS 缩写的末尾添加 <code>!</code> 后缀来添加 <code>!important</code></p>
<p><code>p!+m10e!</code>:</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 输出多个属性</h2>
<p>正如上方演示，您可以利用 <code>+</code> 同时输出多个 CSS 属性。</p>
<div class="hint-container info">
<p class="hint-container-title">Snippets</p>
<p>完整的 CSS snippets 请见 <a href="https://github.com/emmetio/emmet/blob/master/snippets/css.json" target="_blank" rel="noopener noreferrer">Emmet Repo</a></p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>HTML Emmet</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/emmet/html.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/emmet/html.html</guid>
      <source url="https://leijue222.github.io/rss.xml">HTML Emmet</source>
      <description>元素创建 1. 在编辑器中输入元素名称之后按下 tab 即可自动补全生成 HTML 标签，即使不是标准的 HTML 标签。 创建文档 输入: ! 或者 html:5 将创建 HTML 基本结构。 结构操作 子元素 使用 &amp;gt; 生成子元素 案例 div&amp;gt;ul&amp;gt;li: 兄弟元素 使用 + 生成兄弟元素 案例 div+p+bq: 上移 使用 ^ 上移一级 案例...</description>
      <category>Emmet</category>
      <pubDate>Tue, 03 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 元素创建</h2>
<ol>
<li>在编辑器中输入元素名称之后按下 tab 即可自动补全生成 HTML 标签，即使不是标准的 HTML 标签。</li>
</ol>
<div class="hint-container tip">
<p class="hint-container-title">创建文档</p>
<p>输入: <code>!</code> 或者 <code>html:5</code> 将创建 HTML 基本结构。</p>
</div>
<h2> 结构操作</h2>
<h3> 子元素</h3>
<p>使用 <code>&gt;</code> 生成子元素</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>div&gt;ul&gt;li</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> 兄弟元素</h3>
<p>使用 <code>+</code> 生成兄弟元素</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>div+p+bq</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> 上移</h3>
<p>使用 <code>^</code> 上移一级</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>div+div&gt;p&gt;span+em^bq</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> 重复</h3>
<p>使用 <code>*</code> 生成多个相同元素。</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>div&gt;ul&gt;li*5</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> 分组</h3>
<p>使用 <code>()</code> 将元素分组</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>+</code> 后面的元素与括号中的第一个元素属于兄弟关系</p>
<p><code>div&gt;(header&gt;ul&gt;li*2)+footer&gt;p</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h2> 属性操作</h2>
<h3> ID 与 class</h3>
<p>元素与 <code>id</code> 属性值之间用 <code>#</code> 分隔，与 <code>class</code> 属性值之间用 <code>.</code> 分隔</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>div#header+div.page+div#footer.class1.class2.class3</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> 自定义属性</h3>
<p>在 Emmet 中，使用 <code>[]</code> 标记其他属性。</p>
<p>您无需输入引号，直接使用 <code>[属性1=值1 属性2=值2 ... ]</code> 即可。</p>
<ul>
<li>
<p>您可以在方括号内放置任意数量的属性。</p>
</li>
<li>
<p>您不必指定属性值: <code>td[colspan title]</code> 会生成 <code>&lt;td colspan="" title=""&gt;</code>。</p>
<p>接下来您可以通过按下 tab 将光标顺序移动至每个空属性内，这会让您很方便的输入内容。</p>
</li>
<li>
<p>您可以使用单引号或双引号来引用属性值。如果值不包含空格，则无需引用它们。如: <code>td[title=hello colspan=3]</code></p>
</li>
</ul>
<details class="hint-container details"><summary>案例</summary>
<p><code>td[title="Hello world!" colspan=3]</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details>
<h3> 项目编号</h3>
<p>用 <code>$</code> 符号实现 <code>1</code> 到 <code>n</code> 的自动编号 (<code>*</code> 实现多个元素)</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>li.item$*3</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<p>可在 <code>$</code> 后添加 <code>@n</code> 修改编号的起始值为 <code>n</code>。</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>li.item$@3*3</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<p>可在 “<code>$</code>” 后添加 “<code>@-</code>” 修改编号的方向。</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>li.item$@-3*3</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<p>您可以连续使用多个 <code>$</code> 以零填充数字。</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>ul&gt;li.item$$$*5</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h3> 文本</h3>
<p>使用 <code>{}</code> 添加文本内容</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>a[href=me.html]{click me}</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></details>
<div class="hint-container warning">
<p class="hint-container-title">注意</p>
<p>请注意，<code>{text}</code> 是作为一个单独的元素使用和解析的。</p>
<p>请理解以下案例:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></div>
<h2> 隐式标签名称</h2>
<p>即使使用功能强大的缩写引擎(可以从短缩写扩展大型 HTML 结构)，编写标签名称也可能非常繁琐。</p>
<p>在许多情况下，您可以跳过键入标签名称的操作，而 Emmet 会自动为您生成一个。例如，您可以简单地将 <code>div.content</code> 写为 <code>.content</code>，Emmet 将自动扩展为 <code>&lt;div class="content"&gt;&lt;/div&gt;</code>。</p>
<h3> 工作原理</h3>
<p>扩展缩写词时，Emmet 会尝试在其内部扩展缩写词的地方获取上下文进行推断。如果成功捕获了上下文，Emmet 将使用其名称来解析隐式名称。</p>
<details class="hint-container details"><summary>案例</summary>
<table>
<thead>
<tr>
<th>Emmet 缩写</th>
<th>Emmet 实际输出</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.wrap&gt;.content</code></td>
<td><code>div.wrap&gt;div.content</code></td>
</tr>
<tr>
<td><code>em&gt;.info</code></td>
<td><code>em&gt;span.info</code></td>
</tr>
<tr>
<td><code>ul&gt;.item*3</code></td>
<td><code>ul&gt;li.item*3</code></td>
</tr>
<tr>
<td><code>table&gt;#row$*4&gt;[colspan=2]</code></td>
<td><code>table&gt;tr#row$*4&gt;td[colspan=2]</code></td>
</tr>
</tbody>
</table>
</details>
<h2> Lorem Ipsum 生成</h2>
<p><code>lorem</code> 是一个示例词的生成器，您可以很方便的生成一些预设文字查看效果。它会自动根据标签调整文字数量，并在重复时轮换输出。</p>
<details class="hint-container details"><summary>案例</summary>
<p><code>p*4&gt;lorem</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>ul.generic-list&gt;lorem10.item*4</code>:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details>
<h2> 其他内容</h2>
<p>某些元素(例如 a 或)img 会转换为具有预定义属性的元素: <code>&lt;a href=""&gt;&lt;/a&gt;</code> 和 <code>&lt;img src="" alt="" /&gt;</code>。</p>
<p>同时 emmet 还包含了一些常用缩写，如 <code>bq</code> 会输出 <code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>。</p>
<p>这些功能是通过预置的 snippets 实现的。</p>
<div class="hint-container info">
<p class="hint-container-title">相关信息</p>
<p>部分 snippets 内容:</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完整的 HTML snippets 请见 <a href="https://github.com/emmetio/emmet/blob/master/snippets/html.json" target="_blank" rel="noopener noreferrer">Emmet Repo</a></p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>HTML</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/html/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/html/</guid>
      <source url="https://leijue222.github.io/rss.xml">HTML</source>
      <description>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，它不是一种编程语言，而是一种标记语言 (markup language)，它使用标记标签来描述网页。HTML5 是 HTML 最新的修订版本。</description>
      <category>HTML</category>
      <pubDate>Sun, 01 Sep 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>HTML 指的是超文本标记语言 (Hyper Text Markup Language)，它不是一种编程语言，而是一种标记语言 (markup language)，它使用标记标签来描述网页。HTML5 是 HTML 最新的修订版本。</p>
<!-- more -->
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>在网页的前端开发中，它描绘了视图层的具体结构。</p>
</div>
<h2> 初学者教程</h2>
<ul>
<li><a href="/tutorial/front-end/website/html/guide/" target="blank">HTML 快速入门</a></li>
<li><a href="/tutorial/front-end/website/html/guide/tag.html" target="blank">HTML 常用标签</a></li>
</ul>
<h2> HTML 教程</h2>
<ul>
<li><a href="/tutorial/front-end/website/html/intro/history.html" target="blank">历史</a></li>
<li><a href="/tutorial/front-end/website/html/intro/head.html" target="blank">Head 标签</a></li>
<li><a href="/tutorial/front-end/website/html/intro/basic.html" target="blank">基本标签</a></li>
<li><a href="/tutorial/front-end/website/html/intro/link.html" target="blank">链接</a></li>
<li><a href="/tutorial/front-end/website/html/intro/image.html" target="blank">图片</a></li>
<li><a href="/tutorial/front-end/website/html/intro/svg.html" target="blank">矢量图形</a></li>
<li><a href="/tutorial/front-end/website/html/intro/media.html" target="blank">视频与音频</a></li>
<li><a href="/tutorial/front-end/website/html/intro/table.html" target="blank">表格</a></li>
<li><a href="/tutorial/front-end/website/html/intro/embed.html" target="blank">嵌入</a></li>
<li><a href="/tutorial/front-end/website/html/intro/format.html" target="blank">格式化文档</a></li>
<li><a href="/tutorial/front-end/website/html/intro/layout.html" target="blank">网站布局</a></li>
</ul>
<h2> HTML 参考</h2>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/learn/HTML" target="_blank" rel="noopener noreferrer">MDN 教程</a></li>
</ul>
<h2> HTML5</h2>
<p>HTML5 是 HTML 现行的最新修订版本，主要的新特性包括:</p>
<ul>
<li>用于绘画的 <code>&lt;canvas /&gt;</code> 元素</li>
<li>用于媒体播放的 <code>&lt;video /&gt;</code> 和 <code>&lt;audio /&gt;</code> 元素</li>
<li>更好地支持本地离线存储</li>
<li>新的特殊内容元素，比如 <code>&lt;article /&gt;</code>、<code>&lt;footer /&gt;</code>、<code>&lt;header /&gt;</code>、<code>&lt;nav /&gt;</code>、<code>&lt;section /&gt;</code></li>
<li>新的表单控件，比如 calendar、date、time、email、url、search</li>
</ul>
<h2> 其他文档 </h2>
<ul>
<li>
<p>HTML</p>
<ul>
<li><a href="https://www.w3cschool.cn/html/" target="_blank" rel="noopener noreferrer">W3CSchool 教程</a></li>
<li><a href="https://www.runoob.com/html/html-tutorial.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></li>
<li><a href="http://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></li>
</ul>
</li>
<li>
<p>HTML5</p>
<ul>
<li><a href="https://www.w3cschool.cn/html5/" target="_blank" rel="noopener noreferrer">W3CSchool 教程</a></li>
<li><a href="https://www.runoob.com/html/html5-intro.html" target="_blank" rel="noopener noreferrer">菜鸟教程</a></li>
<li><a href="http://www.w3school.com.cn/html5/index.asp" target="_blank" rel="noopener noreferrer">W3School 教程</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>jQuery</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/jQuery/</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/jQuery/</guid>
      <source url="https://leijue222.github.io/rss.xml">jQuery</source>
      <description>jQuery 是一款能够方便快捷的操作 DOM，并兼容所有主流浏览器的框架，目前最新版本是 3.5.1。 提示 由于目前前端应用的愈加复杂，前端开发者大多数转向 MVVM 框架，目前世界比较流行的三大 MVVM 框架是 Vue React Angular。可以说，在 2023 年，jQuery 已经过时了! 不过 jQuery 无论说从代码实现还是从写法上，到今天都是值得借鉴的。 所以如果您只想简单了解并掌握前端开发，而不是深入地从事相关行业，您可以直接 跳过本章节。 本章节应以理解写法与思路为主，无需刻意记忆。</description>
      <category>jQuery</category>
      <pubDate>Sat, 02 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>jQuery 是一款能够方便快捷的操作 DOM，并兼容所有主流浏览器的框架，目前最新版本是 3.5.1。</p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>由于目前前端应用的愈加复杂，前端开发者大多数转向 MVVM 框架，目前世界比较流行的三大 MVVM 框架是 Vue React Angular。可以说，在 2023 年，<strong>jQuery 已经过时了</strong>!</p>
<p>不过 jQuery 无论说从代码实现还是从写法上，到今天都是值得借鉴的。</p>
<p>所以如果您只想简单了解并掌握前端开发，而不是深入地从事相关行业，您可以直接 <a href="/tutorial/front-end/vue/" target="blank">跳过本章节</a>。</p>
<p>本章节应以理解写法与思路为主，无需刻意记忆。</p>
</div>
<!-- more -->
<h2> 教程目录</h2>
<ul>
<li>
<p><a href="/tutorial/front-end/website/jQuery/intro.html" target="blank">jQuery 简介</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/jQuery/selector.html" target="blank">选择器</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/jQuery/operate-dom.html" target="blank">操作 DOM</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/jQuery/modify-dom.html" target="blank">修改 DOM 结构</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/jQuery/event.html" target="blank">事件</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/jQuery/animation.html" target="blank">动画</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/jQuery/ajax.html" target="blank">Ajax</a></p>
</li>
<li>
<p><a href="/tutorial/front-end/website/jQuery/extend.html" target="blank">扩展</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>AJAX</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/jQuery/ajax.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/jQuery/ajax.html</guid>
      <source url="https://leijue222.github.io/rss.xml">AJAX</source>
      <description>章节过时 目前，一套代码已经可以在多个浏览器上运行良好了，所以 jQuery 的意义并不大。在 Node.js 中，我们使用 axios 来进行请求。</description>
      <category>jQuery</category>
      <pubDate>Tue, 05 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">章节过时</p>
<p>目前，一套代码已经可以在多个浏览器上运行良好了，所以 jQuery 的意义并不大。在 Node.js 中，我们使用 <a href="/tutorial/front-end/node-js/package/axois.html" target="blank">axios</a> 来进行请求。</p>
</div>
<!-- more -->
<p>用 JavaScript 写 Ajax 前面已经介绍过了，主要问题就是不同浏览器需要写不同代码，并且状态和错误处理写起来很麻烦。</p>
<p>用 jQuery 的相关对象来处理 AJAX，不但不需要考虑浏览器问题，代码也能大大简化。</p>
<h2> Ajax</h2>
<p>jQuery 在全局对象 jQuery (也就是 <code>$</code>) 绑定了 <code>ajax()</code> 函数，可以处理 Ajax 请求。<code>ajax(url, settings)</code> 函数需要接收一个 URL 和一个可选的 settings 对象，常用的选项如下:</p>
<ul>
<li>
<p>async: 是否异步执行 Ajax 请求，默认为 <code>true</code>；</p>
</li>
<li>
<p>method: 发送的 Method，缺省为 <code>'GET'</code>，可指定为 <code>'POST'</code> 、<code>'PUT'</code> 等；</p>
</li>
<li>
<p>contentType: 发送 POST 请求的格式，默认值为 <code>'application/x-www-form-urlencoded; charset=UTF-8'</code>，也可以指定为 <code>text/plain</code>、<code>application/json</code>；</p>
</li>
<li>
<p>data: 发送的数据，可以是字符串、数组或 object。如果是 <code>GET</code> 请求，data 将被转换成 <code>query</code> 附加到 URL 上，如果是 <code>POST</code> 请求，根据 <code>contentType</code> 把 <code>data</code> 序列化成合适的格式；</p>
</li>
<li>
<p>headers: 发送的额外的 HTTP 头，必须是一个 object；</p>
</li>
<li>
<p>dataType: 接收的数据格式，可以指定为 <code>'html'</code>、<code>'xml'</code>、<code>'json'</code>、<code>'text'</code> 等，缺省情况下根据响应的 <code>Content-Type</code> 猜测。</p>
</li>
</ul>
<p>下面的例子发送一个 <code>GET</code> 请求，并返回一个 JSON 格式的数据:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，如何用回调函数处理返回的数据和出错时的响应呢?</p>
<p>还记得 Promise 对象吗? jQuery 的 <code>jqXHR</code> 对象类似一个 Promise 对象，我们可以用链式写法来处理各种回调:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> get</h2>
<p>对常用的 Ajax 操作，jQuery 提供了一些辅助方法。由于 GET 请求最常见，所以 jQuery 提供了 <code>get()</code> 方法，可以这么写:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二个参数如果是 object，jQuery 自动把它变成 <code>query string</code> 然后加到 URL 后面，实际的 URL 是:</p>
<p><code>/path/to/resource?name=Bob%20Lee&amp;check=1</code></p>
<p>这样我们就不用关心如何用 URL 编码并构造一个 <code>query string</code> 了。</p>
<h2> post</h2>
<p><code>post()</code> 和 <code>get()</code> 类似，但是传入的第二个参数默认被序列化为 <code>application/x-www-form-urlencoded</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际构造的数据 <code>name=Bob%20Lee&amp;check=1</code> 作为 POST 的 body 被发送。</p>
<h2> getJSON</h2>
<p>由于 JSON 用得越来越普遍，所以 jQuery 也提供了 <code>getJSON()</code> 方法来快速通过 GET 获取一个 JSON 对象:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 安全限制</h2>
<p>jQuery 的 Ajax 完全封装的是 JavaScript 的 Ajax 操作，所以它的安全限制和前面讲的用 JavaScript 写 Ajax 完全一样。</p>
<p>如果需要使用 JSONP，可以在 <code>ajax()</code> 中设置 <code>jsonp: 'callback'</code>，让 jQuery 实现 JSONP 跨域加载数据。</p>
<p>关于跨域的设置请参考浏览器 Ajax 一节中 CORS 的设置。</p>
]]></content:encoded>
    </item>
    <item>
      <title>动画</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/jQuery/animation.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/jQuery/animation.html</guid>
      <source url="https://leijue222.github.io/rss.xml">动画</source>
      <description>章节过时 大部分动画都能够通过 CSS3 的 transition 实现，且 CSS3 开销更小。在复杂动画下，jQuery 更容易触发性能瓶颈。 2023 年浏览器对 CSS3 已经支持的特别良好，所以目前大多数的动画都直接使用 CSS3 的动画库。本章以学习思路为主即可。</description>
      <category>jQuery</category>
      <pubDate>Mon, 04 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">章节过时</p>
<p>大部分动画都能够通过 CSS3 的 transition 实现，且 CSS3 开销更小。在复杂动画下，jQuery 更容易触发性能瓶颈。</p>
<p>2023 年浏览器对 CSS3 已经支持的特别良好，所以目前大多数的动画都直接使用 CSS3 的动画库。本章以学习思路为主即可。</p>
</div>
<!-- more -->
<p>用 JavaScript 实现动画，原理非常简单: 我们只需要以固定的时间间隔(例如，0.1 秒)，每次把 DOM 元素的 CSS 样式修改一点(例如，高宽各增加 10%)，看起来就像动画了。</p>
<p>但是要用 JavaScript 手动实现动画效果，需要编写非常复杂的代码。如果想要把动画效果用函数封装起来便于复用，那考虑的事情就更多了。</p>
<p>使用 jQuery 实现动画，代码已经简单得不能再简化了: 只需要一行代码!</p>
<p>让我们先来看看 jQuery 内置的几种动画样式:</p>
<h2> show / hide</h2>
<p>直接以无参数形式调用 <code>show()</code> 和 <code>hide()</code>，会显示和隐藏 DOM 元素。但是，只要传递一个时间参数进去，就变成了动画:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间以毫秒为单位，但也可以是 <code>'slow'</code>，<code>'fast'</code> 这些字符串:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>toggle()</code> 方法则根据当前状态决定是 <code>show()</code> 还是 <code>hide()</code>。</p>
<h2> slideUp / slideDown</h2>
<p>您可能已经看出来了，<code>show()</code> 和 <code>hide()</code> 是从左上角逐渐展开或收缩的，而 <code>slideUp()</code> 和 <code>slideDown()</code> 则是在垂直方向逐渐展开或收缩的。</p>
<p><code>slideUp()</code> 把一个可见的 DOM 元素收起来，效果跟拉上窗帘似的，<code>slideDown()</code> 相反，而 <code>slideToggle()</code> 则根据元素是否可见来决定下一步动作:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> fadeIn / fadeOut</h2>
<p><code>fadeIn()</code> 和 <code>fadeOut()</code> 的动画效果是淡入淡出，也就是通过不断设置 DOM 元素的 <code>opacity</code> 属性来实现，而 <code>fadeToggle()</code> 则根据元素是否可见来决定下一步动作:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 自定义动画</h2>
<p>如果上述动画效果还不能满足您的要求，那就祭出最后大招: <code>animate()</code>，它可以实现任意动画效果，我们需要传入的参数就是 DOM 元素最终的 CSS 状态和时间，jQuery 在时间段内不断调整 CSS 直到达到我们设定的值:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>animate()</code> 还可以再传入一个函数，当动画结束时，该函数将被调用:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上这个回调函数参数对于基本动画也是适用的。</p>
<p>有了 <code>animate()</code>，您就可以实现各种自定义动画效果了:</p>
<h2> 串行动画</h2>
<p>jQuery 的动画效果还可以串行执行，通过 <code>delay()</code> 方法还可以实现暂停，这样，我们可以实现更复杂的动画效果，而代码却相当简单:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为动画需要执行一段时间，所以 jQuery 必须不断返回新的 Promise 对象才能后续执行操作。简单地把动画封装在函数中是不够的。</p>
<h2> 为什么有的动画没有效果</h2>
<p>您可能会遇到，有的动画如 <code>slideUp()</code> 根本没有效果。这是因为 jQuery 动画的原理是逐渐改变 CSS 的值，如 <code>height</code> 从 <code>100px</code> 逐渐变为 <code>0</code>。但是很多不是 block 性质的 DOM 元素，对它们设置 <code>height</code> 根本就不起作用，所以动画也就没有效果。</p>
<p>此外，jQuery 也没有实现对 <code>background-color</code> 的动画效果，用 <code>animate()</code> 设置 <code>background-color</code> 也没有效果。这种情况下可以使用 CSS3 的 <code>transition</code> 实现动画效果。</p>
]]></content:encoded>
    </item>
    <item>
      <title>事件</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/jQuery/event.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/jQuery/event.html</guid>
      <source url="https://leijue222.github.io/rss.xml">事件</source>
      <description>章节过时 由于目前各浏览器 API 已经基本统一，无需使用 jQuery 绑定事件了。</description>
      <category>jQuery</category>
      <pubDate>Mon, 04 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">章节过时</p>
<p>由于目前各浏览器 API 已经基本统一，无需使用 jQuery 绑定事件了。</p>
</div>
<!-- more -->
<p>因为 JavaScript 在浏览器中以单线程模式运行，页面加载后，一旦页面上所有的 JavaScript 代码被执行完后，就只能依赖触发事件来执行 JavaScript 代码。</p>
<p>浏览器在接收到用户的鼠标或键盘输入后，会自动在对应的 DOM 节点上触发相应的事件。如果该节点已经绑定了对应的 JavaScript 处理函数，该函数就会自动调用。</p>
<p>由于不同的浏览器绑定事件的代码都不太一样，所以用 jQuery 来写代码，就屏蔽了不同浏览器的差异，我们总是编写相同的代码。</p>
<p>举个例子，假设要在用户点击了超链接时弹出提示框，我们用 jQuery 这样绑定一个 <code>click</code> 事件:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>on</code> 方法用来绑定一个事件，我们需要传入事件名称和对应的处理函数。</p>
<p>另一种更简化的写法是直接调用 <code>click()</code> 方法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两者完全等价。我们通常用后面的写法。</p>
<p>jQuery 能够绑定的事件主要包括:</p>
<h2> 鼠标事件</h2>
<ul>
<li><code>click</code>: 鼠标单击时触发；</li>
<li><code>dblclick</code>: 鼠标双击时触发；</li>
<li><code>mouseenter</code>: 鼠标进入时触发；</li>
<li><code>mouseleave</code>: 鼠标移出时触发；</li>
<li><code>mousemove</code>: 鼠标在 DOM 内部移动时触发；</li>
<li><code>hover</code>: 鼠标进入和退出时触发两个函数，相当于 <code>mouseenter</code> 加上 <code>mouseleave</code>。</li>
</ul>
<h2> 键盘事件</h2>
<p>键盘事件仅作用在当前焦点的 DOM 上，通常是 <code>&lt;input&gt;</code> 和 <code>&lt;textarea&gt;</code>。</p>
<ul>
<li><code>keydown</code>: 键盘按下时触发；</li>
<li><code>keyup</code>: 键盘松开时触发；</li>
<li><code>keypress</code>: 按一次键后触发。</li>
</ul>
<h2> 其他事件</h2>
<ul>
<li><code>focus</code>: 当 DOM 获得焦点时触发；</li>
<li><code>blur</code>: 当 DOM 失去焦点时触发；</li>
<li><code>change</code>: 当 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 或 <code>&lt;textarea&gt;</code> 的内容改变时触发；</li>
<li><code>submit</code>: 当 <code>&lt;form&gt;</code> 提交时触发；</li>
<li><code>ready</code>: 当页面被载入并且 DOM 树完成初始化后触发。</li>
</ul>
<p>其中，<code>ready</code> 仅作用于 document 对象。由于 ready 事件在 DOM 完成初始化后触发，且只触发一次，所以非常适合用来写其他的初始化代码。假设我们想给一个 <code>&lt;form&gt;</code> 表单绑定 submit 事件，下面的代码没有预期的效果:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 JavaScript 在此执行的时候，<code>&lt;form&gt;</code> 尚未载入浏览器，所以 <code>$('#testForm)</code> 返回 <code>[]</code>，并没有绑定事件到任何 DOM 上。</p>
<p>所以我们自己的初始化代码必须放到 document 对象的 <code>ready</code> 事件中，保证 DOM 已完成初始化:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样写就没有问题了。因为相关代码会在 DOM 树初始化后再执行。</p>
<p>由于 <code>ready</code> 事件使用非常普遍，所以可以这样简化:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>甚至还可以再简化为:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的这种写法最为常见。如果您遇到 <code>$(function () {...})</code> 的形式，牢记这是 document 对象的 <code>ready</code> 事件处理函数。</p>
<p>完全可以反复绑定事件处理函数，它们会依次执行:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 事件参数</h2>
<p>有些事件，如 <code>mousemove</code> 和 <code>keypress</code>，我们需要获取鼠标位置和按键的值，否则监听这些事件就没什么意义了。所有事件都会传入 Event 对象作为参数，可以从 Event 对象上获取到更多的信息:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 取消绑定</h2>
<p>一个已被绑定的事件可以解除绑定，通过 <code>off('click', function)</code> 实现:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这是因为两个匿名函数虽然长得一模一样，但是它们是两个不同的函数对象，<code>off('click', function () {...})</code> 无法移除已绑定的第一个匿名函数。</p>
<p>为了实现移除效果，可以使用 <code>off('click')</code> 一次性移除已绑定的 click 事件的所有处理函数。</p>
<p>同理，无参数调用 <code>off()</code> 一次性移除已绑定的所有类型的事件处理函数。</p>
<h2> 事件触发条件</h2>
<p>一个需要注意的问题是，事件的触发总是由用户操作引发的。例如，我们监控文本框的内容改动:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当用户在文本框中输入时，就会触发 <code>change</code> 事件。但是，如果用 JavaScript 代码去改动文本框的值，将不会触发 <code>change</code> 事件:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有些时候，我们希望用代码触发 <code>change</code> 事件，可以直接调用无参数的 <code>change()</code> 方法来触发该事件:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>input.change()</code> 相当于 <code>input.trigger('change')</code>，它是 <code>trigger()</code> 方法的简写。</p>
<p>为什么我们希望手动触发一个事件呢? 如果不这么做，很多时候，我们就得写两份一模一样的代码。</p>
<h2> 浏览器安全限制</h2>
<p>在浏览器中，有些 JavaScript 代码只有在用户触发下才能执行，例如，<code>window.open()</code> 函数:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些 “敏感代码” 只能由用户操作来触发:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当用户点击 button1 时，<code>click</code> 事件被触发，由于 <code>popupTestWindow()</code> 在 <code>click</code> 事件处理函数内执行，这是浏览器允许的，而 button2 的 <code>click</code> 事件并未立刻执行 <code>popupTestWindow()</code>，延迟执行的 <code>popupTestWindow()</code> 将被浏览器拦截。</p>
]]></content:encoded>
    </item>
    <item>
      <title>扩展</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/jQuery/extend.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/jQuery/extend.html</guid>
      <source url="https://leijue222.github.io/rss.xml">扩展</source>
      <description>当我们使用 jQuery 对象的方法时，由于 jQuery 对象可以操作一组 DOM，而且支持链式操作，所以用起来非常方便。 但是 jQuery 内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些 DOM 元素，用 jQuery 可以这么实现: 总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个 highlight(...</description>
      <category>jQuery</category>
      <pubDate>Tue, 05 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>当我们使用 jQuery 对象的方法时，由于 jQuery 对象可以操作一组 DOM，而且支持链式操作，所以用起来非常方便。</p>
<p>但是 jQuery 内置的方法永远不可能满足所有的需求。比如，我们想要高亮显示某些 DOM 元素，用 jQuery 可以这么实现:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总是写重复代码可不好，万一以后还要修改字体就更麻烦了，能不能统一起来，写个 <code>highlight()</code> 方法?</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>答案是肯定的。我们可以扩展 jQuery 来实现自定义方法。将来如果要修改高亮的逻辑，只需修改一处扩展代码。这种方式也称为编写 jQuery 插件。</p>
<h2> 编写 jQuery 插件</h2>
<p>给 jQuery 对象绑定一个新方法是通过扩展 <code>$.fn</code> 对象实现的。让我们来编写第一个扩展—— <code>highlight1()</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意到函数内部的 <code>this</code> 在调用时被绑定为 jQuery 对象，所以函数内部代码可以正常调用所有 jQuery 对象的方法。</p>
<p>对于如下的 HTML 结构:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>来测试一下 <code>highlight1()</code> 的效果:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>细心的您可能发现了，为什么最后要 <code>return this</code> ;? 因为 jQuery 对象支持链式操作，我们自己写的扩展方法也要能继续链式下去:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不然，用户调用的时候，就不得不把上面的代码拆成两行。</p>
<p>但是这个版本并不完美。有的用户希望高亮的颜色能自己来指定，怎么办?</p>
<p>我们可以给方法加个参数，让用户自己把参数用对象传进去。于是我们有了第二个版本的 <code>highlight2()</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于如下 HTML 结构:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>来实测一下带参数的 <code>highlight2()</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于默认值的处理，我们用了一个简单的 <code>&amp;&amp;</code> 和 <code>||</code> 短路操作符，总能得到一个有效的值。</p>
<p>另一种方法是使用 jQuery 提供的辅助方法 <code>$.extend(target, obj1, obj2, ...)</code>，它把多个 object 对象的属性合并到第一个 target 对象中，遇到同名属性，总是使用靠后的对象的值，也就是越往后优先级越高:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>紧接着用户对 <code>highlight2()</code> 提出了意见: 每次调用都需要传入自定义的设置，能不能让我自己设定一个缺省值，以后的调用统一使用无参数的 <code>highlight2()</code>?</p>
<p>也就是说，我们设定的默认值应该能允许用户修改。</p>
<p>那默认值放哪比较合适? 放全局变量肯定不合适，最佳地点是 <code>$.fn.highlight2</code> 这个函数对象本身。</p>
<p>于是最终版的 <code>highlight()</code> 终于诞生了:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这次用户终于满意了。用户使用时，只需一次性设定默认值:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然后就可以非常简单地调用 <code>highlight()</code> 了。</p>
<p>对如下的 HTML 结构:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实测一下修改默认值的效果:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终，我们得出编写一个 jQuery 插件的原则:</p>
<ul>
<li>给 <code>$.fn</code> 绑定函数，实现插件的代码逻辑；</li>
<li>插件函数最后要 <code>return this</code> ;以支持链式调用；</li>
<li>插件函数要有默认值，绑定在 <code>$.fn.&lt;pluginName&gt;.defaults</code> 上；</li>
<li>用户在调用时可传入设定值以便覆盖默认值。</li>
</ul>
<h2> 针对特定元素的扩展</h2>
<p>我们知道 jQuery 对象的有些方法只能作用在特定 DOM 元素上，比如 <code>submit()</code> 方法只能针对 form。如果我们编写的扩展只能针对某些类型的 DOM 元素，应该怎么写?</p>
<p>还记得 jQuery 的选择器支持 <code>filter()</code> 方法来过滤吗? 我们可以借助这个方法来实现针对特定元素的扩展。</p>
<p>举个例子，现在我们要给所有指向外链的超链接加上跳转提示，怎么做?</p>
<p>先写出用户调用的代码:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后按照上面的方法编写一个 <code>external</code> 扩展:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对如下的 HTML 结构:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实测外链效果:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 小结</h2>
<p>扩展 jQuery 对象的功能十分简单，但是我们要遵循 jQuery 的原则，编写的扩展方法能支持链式调用、具备默认值和过滤特定元素，使得扩展方法看上去和 jQuery 本身的方法没有什么区别。</p>
]]></content:encoded>
    </item>
    <item>
      <title>jQuery 介绍</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/jQuery/intro.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/jQuery/intro.html</guid>
      <source url="https://leijue222.github.io/rss.xml">jQuery 介绍</source>
      <description>jQuery 是 JavaScript 世界中使用最广泛的一个库。鼎盛时期全世界大约有 80~90%的网站直接或间接地使用了 jQuery。 jQuery 能帮我们干这些事情: 消除浏览器差异: 您不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写 Ajax 等代码； 简洁的操作 DOM 的方法: 写 $(&amp;apos;#test&amp;apos;) 肯定比 document.getElementById(&amp;apos;test&amp;apos;) 来得简洁； 轻松实现动画、修改 CSS 等各种操作。 jQuery 的理念 “Write Less, Do More“，让您写更少的代码，完成更多的工作!</description>
      <category>jQuery</category>
      <pubDate>Sat, 02 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>jQuery 是 JavaScript 世界中使用最广泛的一个库。鼎盛时期全世界大约有 80~90%的网站直接或间接地使用了 jQuery。</p>
<p>jQuery 能帮我们干这些事情:</p>
<ul>
<li>消除浏览器差异: 您不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写 Ajax 等代码；</li>
<li>简洁的操作 DOM 的方法: 写 <code>$('#test')</code> 肯定比 <code>document.getElementById('test')</code> 来得简洁；</li>
<li>轻松实现动画、修改 CSS 等各种操作。</li>
<li>jQuery 的理念 “Write Less, Do More“，让您写更少的代码，完成更多的工作!</li>
</ul>
<!-- more -->
<h2> jQuery 版本</h2>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>jQuery 的 <code>1.x</code> 版本 兼容 ie678，<code>2.x</code> 为了精简代码体积移除了 ie678 的兼容。<code>3.x</code> 只兼容最新的一批浏览器，是官方还在更新维护的把呢不能</p>
<p>由于已经 2023 年了，直接选用 jQuery<code>3.x</code> 版本即可。</p>
</div>
<p>从 jQuery 官网可以下载最新版本。jQuery 只是一个 jquery-xxx.js 文件，但您会看到有 compressed(已压缩)和 uncompressed(未压缩)两种版本，使用时完全一样，但如果您想深入研究 jQuery 源码，那就用 uncompressed 版本。</p>
<h2> 使用 jQuery</h2>
<p>使用 jQuery 只需要在页面的 <code>&lt;head&gt;</code> 引入 jQuery 文件即可:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> $ 符号</h2>
<p><code>$</code> 是著名的 jQuery 符号。实际上，jQuery 把所有功能全部封装在一个全局变量 jQuery 中，而 <code>$</code> 也是一个合法的变量名，它是变量 jQuery 的别名:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>$</code> 本质上就是一个函数，但是函数也是对象，于是 <code>$</code> 除了可以直接调用外，也可以有很多其他属性。</p>
<p>注意，您看到的 <code>$</code> 函数名可能不是 <code>jQuery(selector, context)</code>，因为很多 JavaScript 压缩工具可以对函数名和参数改名，所以压缩过的 jQuery 源码 <code>$</code> 函数可能变成 <code>a(b, c)</code>。</p>
<p>绝大多数时候，我们都直接用 <code>$</code> (因为写起来更简单嘛)。但是，如果 <code>$</code> 这个变量不幸地被占用了，而且还不能改，那我们就只能让 jQuery 把 <code>$</code> 变量交出来，然后就只能使用 <code>jQuery</code> 这个变量:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种黑魔法的原理是 jQuery 在占用<code>$</code>之前，先在内部保存了原来的<code>$</code>,调用 <code>jQuery.noConflict()</code> 时会把原来保存的变量还原。</p>
]]></content:encoded>
    </item>
    <item>
      <title>修改 DOM 结构</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/jQuery/modify-dom.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/jQuery/modify-dom.html</guid>
      <source url="https://leijue222.github.io/rss.xml">修改 DOM 结构</source>
      <description>章节过时 而且目前浏览器 API 已经基本统一，除非兼容旧版本 IE，否则无需针对不同浏览器写不同的代码。</description>
      <category>jQuery</category>
      <pubDate>Sun, 03 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">章节过时</p>
<p>而且目前浏览器 API 已经基本统一，除非兼容旧版本 IE，否则无需针对不同浏览器写不同的代码。</p>
</div>
<!-- more -->
<p>直接使用浏览器提供的 API 对 DOM 结构进行修改，不但代码复杂，而且要针对浏览器写不同的代码。</p>
<p>有了 jQuery，我们就专注于操作 jQuery 对象本身，底层的 DOM 操作由 jQuery 完成就可以了，这样一来，修改 DOM 也大大简化了。</p>
<h2> 添加 DOM</h2>
<p>要添加新的 DOM 节点，除了通过 jQuery 的 <code>html()</code> 这种暴力方法外，还可以用 <code>append()</code> 方法，例如:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何向列表新增一个语言? 首先要拿到 <code>&lt;ul&gt;</code> 节点:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后，调用 <code>append()</code> 传入 HTML 片段:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了接受字符串，<code>append()</code> 还可以传入原始的 DOM 对象，jQuery 对象和函数对象:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>传入函数时，要求返回一个字符串、DOM 对象或者 jQuery 对象。因为 jQuery 的 <code>append()</code> 可能作用于一组 DOM 节点，只有传入函数才能针对每个 DOM 生成不同的子节点。</p>
<p><code>append()</code> 把 DOM 添加到最后，<code>prepend()</code> 则把 DOM 添加到最前。</p>
<p>另外注意，如果要添加的 DOM 节点已经存在于 HTML 文档中，它会首先从文档移除，然后再添加，也就是说，用 <code>append()</code>，您可以移动一个 DOM 节点。</p>
<p>如果要把新节点插入到指定位置，例如，JavaScript 和 Python 之间，那么，可以先定位到 JavaScript，然后用 <code>after()</code> 方法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>也就是说，同级节点可以用 <code>after()</code> 或者 <code>before()</code> 方法。</p>
<h2> 删除节点</h2>
<p>要删除 DOM 节点，拿到 jQuery 对象后直接调用 <code>remove()</code> 方法就可以了。如果 jQuery 对象包含若干 DOM 节点，实际上可以一次删除多个 DOM 节点:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>操作 DOM</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/jQuery/operate-dom.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/jQuery/operate-dom.html</guid>
      <source url="https://leijue222.github.io/rss.xml">操作 DOM</source>
      <description>章节过时 目前，新型的框架大多遵循 MVVM 逻辑，及把逻辑层的数据绑定到视图层去显示。这种思路下，无需也不应操作 DOM。</description>
      <category>jQuery</category>
      <pubDate>Sun, 03 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">章节过时</p>
<p>目前，新型的框架大多遵循 MVVM 逻辑，及把逻辑层的数据绑定到视图层去显示。这种思路下，无需也不应操作 DOM。</p>
</div>
<!-- more -->
<p>jQuery 的选择器很强大，用起来又简单又灵活，但是搞了这么久，我拿到了 jQuery 对象，到底要干什么?</p>
<p>答案当然是操作对应的 DOM 节点啦!</p>
<p>回顾一下修改 DOM 的 CSS、文本、设置 HTML 有多么麻烦，而且有的浏览器只有 innerHTML，有的浏览器支持 innerText，有了 jQuery 对象，不需要考虑浏览器差异了，全部统一操作!</p>
<h2> 修改 Text 和 HTML</h2>
<p>jQuery 对象的 <code>text()</code> 和 <code>html()</code> 方法分别获取节点的文本和原始 HTML 文本，例如，如下的 HTML 结构:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分别获取文本和 HTML:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如何设置文本或 HTML ? jQuery 的 API 设计非常巧妙: 无参数调用 <code>text()</code> 是获取文本，传入参数就变成设置文本，HTML 也是类似操作，自己动手试试:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一个 jQuery 对象可以包含 0 个或任意个 DOM 对象，它的方法实际上会作用在对应的每个 DOM 节点上。在上面的例子中试试:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>所以 jQuery 对象的另一个好处是我们可以执行一个操作，作用在对应的一组 DOM 节点上。即使选择器没有返回任何 DOM 节点，调用 jQuery 对象的方法仍然不会报错:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这意味着 jQuery 帮您免去了许多 if 语句。</p>
<h2> 修改 CSS</h2>
<p>jQuery 对象有“批量操作”的特点，这用于修改 CSS 实在是太方便了。考虑下面的 HTML 结构:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要高亮显示动态语言，调用 jQuery 对象的 <code>css('name', 'value')</code> 方法，我们用一行语句实现:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，jQuery 对象的所有方法都返回一个 jQuery 对象(可能是新的也可能是自身)，这样我们可以进行链式调用，非常方便。</p>
<p>jQuery 对象的 <code>css()</code> 方法可以这么用:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了和 JavaScript 保持一致，CSS 属性可以用 <code>'background-color'</code> 和 <code>'backgroundColor'</code> 两种格式。</p>
<p><code>css()</code> 方法将作用于 DOM 节点的 style 属性，具有最高优先级。如果要修改 class 属性，可以用 jQuery 提供的下列方法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 显示和隐藏 DOM</h2>
<p>要隐藏一个 DOM，我们可以设置 CSS 的 <code>display</code> 属性为 <code>none</code>，利用 <code>css()</code> 方法就可以实现。不过，要显示这个 DOM 就需要恢复原有的 <code>display</code> 属性，这就得先记下来原有的 <code>display</code> 属性到底是 <code>block</code> 还是 <code>inline</code> 还是别的值。</p>
<p>考虑到显示和隐藏 DOM 元素使用非常普遍，jQuery 直接提供 <code>show()</code> 和 <code>hide()</code> 方法，我们不用关心它是如何修改 display 属性的，总之它能正常工作:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，隐藏 DOM 节点并未改变 DOM 树的结构，它只影响 DOM 节点的显示。这和删除 DOM 节点是不同的。</p>
<h2> 获取 DOM 信息</h2>
<p>利用 jQuery 对象的若干方法，我们直接可以获取 DOM 的高宽等信息，而无需针对不同浏览器编写特定代码:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>attr()</code> 和 <code>removeAttr()</code> 方法用于操作 DOM 节点的属性:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>prop()</code> 方法和 <code>attr()</code> 类似，但是 HTML5 规定有一种属性在 DOM 节点中可以没有值，只有出现与不出现两种，例如:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>等价于:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>attr()</code> 和 <code>prop()</code> 对于属性 <code>checked</code> 处理有所不同:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>prop()</code> 返回值更合理一些。不过，用 <code>is()</code> 方法判断更好:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>类似的属性还有 <code>selected</code>，处理时最好用 <code>is(':selected')</code>。</p>
<h2> 操作表单</h2>
<p>对于表单元素，jQuery 对象统一提供 <code>val()</code> 方法获取和设置对应的 <code>value</code> 属性:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可见，一个 <code>val()</code> 就统一了各种输入框的取值和赋值的问题。</p>
]]></content:encoded>
    </item>
    <item>
      <title>选择器</title>
      <link>https://leijue222.github.io/tutorial/front-end/website/jQuery/selector.html</link>
      <guid>https://leijue222.github.io/tutorial/front-end/website/jQuery/selector.html</guid>
      <source url="https://leijue222.github.io/rss.xml">选择器</source>
      <description>选择器是 jQuery 的核心。一个选择器写出来类似 $(&amp;apos;#dom-id&amp;apos;)。</description>
      <category>jQuery</category>
      <pubDate>Sun, 03 Nov 2019 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>选择器是 jQuery 的核心。一个选择器写出来类似 <code>$('#dom-id')</code>。</p>
<!-- more -->
<p>为什么 jQuery 要发明选择器? 回顾一下 DOM 操作中我们经常使用的代码:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些代码实在太繁琐了，并且，在层级关系中，例如，查找 <code>&lt;table class="green"&gt;</code> 里面的所有 <code>&lt;tr&gt;</code>，一层循环实际上是错的，因为 <code>&lt;table&gt;</code> 的标准写法是:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>很多时候，需要递归查找所有子节点。</p>
<p>jQuery 的选择器就是帮助我们快速定位到一个或多个 DOM 节点。</p>
<h2> 简单选择器</h2>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>jQuery 的选择器特别像 CSS 的选择器</p>
</div>
<h3> 按 ID 查找</h3>
<p>如果某个 DOM 节点有 id 属性，利用 jQuery 查找如下:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，<code>#abc</code> 以 <code>#</code> 开头。返回的对象是 jQuery 对象。</p>
<p>什么是 jQuery 对象? jQuery 对象类似数组，它的每个元素都是一个引用了 DOM 节点的对象。</p>
<p>以上面的查找为例，如果 id 为 <code>abc</code> 的 <code>&lt;div&gt;</code> 存在，返回的 jQuery 对象如下:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 id 为 abc 的 <code>&lt;div&gt;</code> 不存在，返回的 jQuery 对象如下:</p>
<p><code>[]</code></p>
<p>总之 jQuery 的选择器不会返回 <code>undefined</code> 或者 <code>null</code>，这样的好处是您不必在下一行判断 <code>if (div === undefined)</code>。</p>
<p>jQuery 对象和 DOM 对象之间可以互相转化:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常情况下您不需要获取 DOM 对象，直接使用 jQuery 对象更加方便。如果您拿到了一个 DOM 对象，那可以简单地调用 <code>$(aDomObject)</code> 把它变成 jQuery 对象，这样就可以方便地使用 jQuery 的 API 了。</p>
<h3> 按 tag 查找</h3>
<p>按 tag 查找只需要写上 tag 名称就可以了:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 按 class 查找</h3>
<p>按 class 查找注意在 class 名称前加一个 <code>.</code>:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常很多节点有多个 <strong>class</strong>，我们可以查找同时包含 <code>red</code> 和 <code>green</code> 的节点:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 按属性查找</h3>
<p>一个 DOM 节点除了 id 和 class 外还可以有很多属性，很多时候按属性查找会非常方便，比如在一个表单中按属性来查找:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当属性的值包含空格等特殊字符时，需要用双引号括起来。</p>
<p>按属性查找还可以使用前缀查找或者后缀查找:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法尤其适合通过 class 属性查找，且不受 class 包含多个名称的影响:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 组合查找</h3>
<p>组合查找就是把上述简单选择器组合起来使用。如果我们查找 <code>$('[name=email]')</code>，很可能把表单外的 <code>&lt;div name="email"&gt;</code> 也找出来，但我们只希望查找 <code>&lt;input&gt;</code>，就可以这么写:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>同样的，根据 tag 和 class 来组合查找也很常见:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 多项选择器</h2>
<p>多项选择器就是把多个选择器用，组合起来一块选:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>要注意的是，选出来的元素是按照它们在 HTML 中出现的顺序排列的，而且不会有重复元素。例如，<code>&lt;p class="red green"&gt;</code> 不会被上面的 <code>$('p.red,p.green')</code> 选择两次。</p>
<h2> 层级选择器</h2>
<p>除了基本的选择器外，jQuery 的层级选择器更加灵活，也更强大。</p>
<p>因为 DOM 的结构就是层级结构，所以我们经常要根据层级关系进行选择。</p>
<h3> 层级选择器 (Descendant Selector)</h3>
<p>如果两个 DOM 元素具有层级关系，就可以用 <code>$('ancestor descendant')</code> 来选择，层级之间用空格隔开。例如:</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>要选出 JavaScript，可以用层级选择器:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>因为 <code>&lt;div&gt;</code> 和 <code>&lt;ul&gt;</code> 都是 <code>&lt;li&gt;</code> 的祖先节点，所以上面两种方式都可以选出相应的 <code>&lt;li&gt;</code> 节点。</p>
<p>要选择所有的 <code>&lt;li&gt;</code> 节点，用:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这种层级选择器相比单个的选择器好处在于，它缩小了选择范围，因为首先要定位父节点，才能选择相应的子节点，这样避免了页面其他不相关的元素。</p>
<p>例如:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>就把选择范围限定在 <code>name</code> 属性为 <code>upload</code> 的表单里。如果页面有很多表单，其他表单的 <code>&lt;input&gt;</code> 不会被选择。</p>
<p>多层选择也是允许的:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 子选择器(Child Selector)</h2>
<p>子选择器 <code>$('parent&gt;child')</code> 类似层级选择器，但是限定了层级关系必须是父子关系，就是 <code>&lt;child&gt;</code> 节点必须是 <code>&lt;parent&gt;</code> 节点的直属子节点。还是以上面的例子:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 过滤器(Filter)</h2>
<p>过滤器一般不单独使用，它通常附加在选择器上，帮助我们更精确地定位元素。观察过滤器的效果:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 表单相关</h2>
<p>针对表单元素，jQuery 还有一组特殊的选择器:</p>
<ul>
<li>
<p><code>:input</code>: 可以选择 <code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>，<code>&lt;select&gt;</code> 和 <code>&lt;button&gt;</code>；</p>
</li>
<li>
<p><code>:file</code>: 可以选择 <code>&lt;input type="file"&gt;</code>，和 <code>input[type=file]</code> 一样；</p>
</li>
<li>
<p><code>:checkbox</code>: 可以选择复选框，和 <code>input[type=checkbox]</code> 一样；</p>
</li>
<li>
<p><code>:radio</code>: 可以选择单选框，和 <code>input[type=radio]</code> 一样；</p>
</li>
<li>
<p><code>:focus</code>: 可以选择当前输入焦点的元素，例如把光标放到一个 <code>&lt;input&gt;</code> 上，用<code>$('input:focus')</code> 就可以选出；</p>
</li>
<li>
<p><code>:checked</code>: 选择当前勾上的单选框和复选框，用这个选择器可以立刻获得用户选择的项目，如<code>$('input[type=radio]:checked')</code>；</p>
</li>
<li>
<p><code>:enabled</code>: 可以选择可以正常输入的 <code>&lt;input&gt;</code>、<code>&lt;select&gt;</code> 等，也就是没有灰掉的输入；</p>
</li>
<li>
<p><code>:disabled</code>: 和 <code>:enabled</code> 正好相反，选择那些不能输入的。</p>
</li>
</ul>
<p>此外，jQuery 还有很多有用的选择器，例如，选出可见的或隐藏的元素:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 查找和过滤</h2>
<p>通常情况下选择器可以直接定位到我们想要的元素，但是，当我们拿到一个 jQuery 对象后，还可以以这个对象为基准，进行查找和过滤。</p>
<h3> 查找</h3>
<p>最常见的查找是在某个节点的所有子节点中查找，使用 <code>find()</code> 方法，它本身又接收一个任意的选择器。例如如下的 HTML 结构:</p>
<div class="language-markdown line-numbers-mode" data-ext="md"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>用 <code>find()</code> 查找:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要从当前节点开始向上查找，使用 <code>parent()</code> 方法:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于位于同一层级的节点，可以通过 <code>next()</code> 和 <code>prev()</code> 方法，例如:</p>
<p>当我们已经拿到 Swift 节点后:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 过滤</h3>
<p>和函数式编程的 <code>map</code>、<code>filter</code> 类似，jQuery 对象也有类似的方法。</p>
<p><code>filter()</code> 方法可以过滤掉不符合选择器条件的节点:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>或者传入一个函数，要特别注意函数内部的 <code>this</code> 被绑定为 DOM 对象，不是 jQuery 对象:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>map()</code> 方法把一个 jQuery 对象包含的若干 DOM 节点转化为其他对象:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，一个 jQuery 对象如果包含了不止一个 DOM 节点，<code>first()</code>、<code>last()</code> 和 <code>slice()</code> 方法可以返回一个新的 jQuery 对象，把不需要的 DOM 节点去掉:</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Bash 教程</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/</guid>
      <source url="https://leijue222.github.io/rss.xml">Bash 教程</source>
      <description>目录 简介 (intro.md); 基本语法 (grammar.md); 模式扩展 (expansion.md); 引号和转义 (quotation.md); 变量 (variable.md); 字符串操作 (string.md); 算术运算 (arithmetic.md); 行操作 (readline.md); 目录堆栈 (stack.md); 脚本...</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 目录</h2>
<ul>
<li>
<p><a href="/tutorial/ops/linux/bash/intro.html" target="blank">简介</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/grammar.html" target="blank">基本语法</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/expansion.html" target="blank">模式扩展</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/quotation.html" target="blank">引号和转义</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/variable.html" target="blank">变量</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/string.html" target="blank">字符串操作</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/arithmetic.html" target="blank">算术运算</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/readline.html" target="blank">行操作</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/stack.html" target="blank">目录堆栈</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/script.html" target="blank">脚本入门</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/read.html" target="blank">read 命令</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/condition.html" target="blank">条件判断</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/loop.html" target="blank">循环</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/function.html" target="blank">函数</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/array.html" target="blank">数组</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/set.html" target="blank">set 命令</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/debug.html" target="blank">脚本除错</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/mktemp.html" target="blank">mktemp 命令，trap 命令</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/startup.html" target="blank">启动环境</a></p>
</li>
<li>
<p><a href="/tutorial/ops/linux/bash/prompt.html" target="blank">命令提示符</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的算术运算</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/arithmetic.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/arithmetic.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Bash 的算术运算</source>
      <description>算术表达式 ((...)) 语法可以进行整数的算术运算。 ((...)) 会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。 这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 0，命令就算执行成功。 上面例子中，3 + 2 的结果是 5，命令就算执行成功，环境变量 $? 为 0。 如果算术结果为 0，命令就算执行失败。...</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 算术表达式</h2>
<p><code>((...))</code> 语法可以进行整数的算术运算。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>((...))</code> 会自动忽略内部的空格，所以下面的写法都正确，得到同样的结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个语法不返回值，命令执行的结果根据算术运算的结果而定。只要算术结果不是 <code>0</code>，命令就算执行成功。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>3 + 2</code> 的结果是 5，命令就算执行成功，环境变量 <code>$?</code> 为 <code>0</code>。</p>
<p>如果算术结果为 <code>0</code>，命令就算执行失败。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>3 - 3</code> 的结果是 <code>0</code>，环境变量 <code>$?</code> 为 <code>1</code>，表示命令执行失败。</p>
<p>如果要读取算术运算的结果，需要在 <code>((...))</code> 前面加上美元符号 <code>$((...))</code>，使其变成算术表达式，返回算术运算的值。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>((...))</code> 语法支持的算术运算符如下。</p>
<ul>
<li><code>+</code>: 加法</li>
<li><code>-</code>: 减法</li>
<li><code>*</code>: 乘法</li>
<li><code>/</code>: 除法(整除)</li>
<li><code>%</code>: 余数</li>
<li><code>**</code>: 指数</li>
<li><code>++</code>: 自增运算(前缀或后缀)</li>
<li><code>--</code>: 自减运算(前缀或后缀)</li>
</ul>
<p>注意，除法运算符的返回结果总是整数，比如 <code>5</code> 除以 <code>2</code>，得到的结果是 <code>2</code>，而不是 <code>2.5</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>++</code> 和 <code>--</code> 这两个运算符有前缀和后缀的区别。作为前缀是先运算后返回值，作为后缀是先返回值后运算。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>++</code> 作为后缀是先返回值，执行 <code>echo</code> 命令，再进行自增运算；作为前缀则是先进行自增运算，再返回值执行 <code>echo</code> 命令。</p>
<p><code>$((...))</code> 内部可以用圆括号改变运算顺序。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，内部的圆括号让加法先于乘法执行。</p>
<p><code>$((...))</code> 结构可以嵌套。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个语法只能计算整数，否则会报错。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>$((...))</code> 的圆括号之中，不需要在变量名之前加上 <code>$</code>，不过加上也不报错。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，变量 <code>number</code> 前面有没有美元符号，结果都是一样的。</p>
<p>如果在 <code>$((...))</code> 里面使用字符串，Bash 会认为那是一个变量名。如果不存在同名变量，Bash 就会将其作为空值，因此不会报错。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>"hello"</code> 会被当作变量名，返回空值，而 <code>$((...))</code> 会将空值当作 <code>0</code>，所以乘法的运算结果就是 <code>0</code>。同理，如果 <code>$((...))</code> 里面使用不存在的变量，也会当作 <code>0</code> 处理。</p>
<p>如果一个变量的值为字符串，跟上面的处理逻辑是一样的。即该字符串如果不对应已存在的变量，在 <code>$((...))</code> 里面会被当作空值。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，变量 <code>foo</code> 的值是 <code>hello</code>，而 <code>hello</code> 也会被看作变量名。这使得有可能写出动态替换的代码。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>foo + 2</code> 取决于变量 <code>hello</code> 的值。</p>
<p>最后，<code>$[...]</code> 是以前的语法，也可以做整数运算，不建议使用。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 数值的进制</h2>
<p>Bash 的数值默认都是十进制，但是在算术表达式中，也可以使用其他进制。</p>
<ul>
<li><code>number</code>: 没有任何特殊表示法的数字是十进制数(以 10 为底)。</li>
<li><code>0number</code>: 八进制数。</li>
<li><code>0xnumber</code>: 十六进制数。</li>
<li><code>base#number</code>: <code>base</code> 进制的数。</li>
</ul>
<p>下面是一些例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>0xff</code> 是十六进制数，<code>2#11111111</code> 是二进制数。</p>
<h2> 位运算</h2>
<p><code>$((...))</code> 支持以下的二进制位运算符。</p>
<ul>
<li><code>&lt;&lt;</code>: 位左移运算，把一个数字的所有位向左移动指定的位。</li>
<li><code>&gt;&gt;</code>: 位右移运算，把一个数字的所有位向右移动指定的位。</li>
<li><code>&amp;</code>: 位的“与”运算，对两个数字的所有位执行一个 <code>AND</code> 操作。</li>
<li><code>|</code>: 位的“或”运算，对两个数字的所有位执行一个 <code>OR</code> 操作。</li>
<li><code>~</code>: 位的“否”运算，对一个数字的所有位取反。</li>
<li><code>^</code>: 位的异或运算(exclusive or)，对两个数字的所有位执行一个异或操作。</li>
</ul>
<p>下面是右移运算符 <code>&gt;&gt;</code> 的例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是左移运算符 <code>&lt;&lt;</code> 的例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是 <code>17</code> (二进制 <code>10001</code>)和 <code>3</code> (二进制 <code>11</code>)的各种二进制运算的结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 逻辑运算</h2>
<p><code>$((...))</code> 支持以下的逻辑运算符。</p>
<ul>
<li><code>&lt;</code>: 小于</li>
<li><code>&gt;</code>: 大于</li>
<li><code>&lt;=</code>: 小于或相等</li>
<li><code>&gt;=</code>: 大于或相等</li>
<li><code>==</code>: 相等</li>
<li><code>!=</code>: 不相等</li>
<li><code>&amp;&amp;</code>: 逻辑与</li>
<li><code>||</code>: 逻辑或</li>
<li><code>!</code>: 逻辑否</li>
<li><code>expr1?expr2:expr3</code>: 三元条件运算符。若表达式 <code>expr1</code> 的计算结果为非零值(算术真)，则执行表达式 <code>expr2</code>，否则执行表达式 <code>expr3</code>。</li>
</ul>
<p>如果逻辑表达式为真，返回 <code>1</code>，否则返回 <code>0</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三元运算符执行一个单独的逻辑测试。它用起来类似于 <code>if/then/else</code> 语句。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，第一个表达式为真时，返回第二个表达式的值，否则返回第三个表达式的值。</p>
<h2> 赋值运算</h2>
<p>算术表达式 <code>$((...))</code> 可以执行赋值运算。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>a=1</code> 对变量 <code>a</code> 进行赋值。这个式子本身也是一个表达式，返回值就是等号右边的值。</p>
<p><code>$((...))</code> 支持的赋值运算符，有以下这些。</p>
<ul>
<li><code>parameter = value</code>: 简单赋值。</li>
<li><code>parameter += value</code>: 等价于 <code>parameter = parameter + value</code>。</li>
<li><code>parameter -= value</code>: 等价于 <code>parameter = parameter – value</code>。</li>
<li><code>parameter *= value</code>: 等价于 <code>parameter = parameter * value</code>。</li>
<li><code>parameter /= value</code>: 等价于 <code>parameter = parameter / value</code>。</li>
<li><code>parameter %= value</code>: 等价于 <code>parameter = parameter % value</code>。</li>
<li><code>parameter &lt;&lt;= value</code>: 等价于 <code>parameter = parameter &lt;&lt; value</code>。</li>
<li><code>parameter &gt;&gt;= value</code>: 等价于 <code>parameter = parameter &gt;&gt; value</code>。</li>
<li><code>parameter &amp;= value</code>: 等价于 <code>parameter = parameter &amp; value</code>。</li>
<li><code>parameter |= value</code>: 等价于 <code>parameter = parameter | value</code>。</li>
<li><code>parameter ^= value</code>: 等价于 <code>parameter = parameter ^ value</code>。</li>
</ul>
<p>下面是一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果在表达式内部赋值，可以放在圆括号中，否则会报错。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 求值运算</h2>
<p>逗号 <code>,</code> 在 <code>$((...))</code> 内部是求值运算符，执行前后两个表达式，并返回后一个表达式的值。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，逗号前后两个表达式都会执行，然后返回后一个表达式的值 <code>12</code>。</p>
<h2> expr 命令</h2>
<p><code>expr</code> 命令支持算术运算，可以不使用 <code>((...))</code> 语法。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>expr</code> 命令支持变量替换。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>expr</code> 命令也不支持非整数参数。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，如果有非整数的运算，<code>expr</code> 命令就报错了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>数组</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/array.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/array.html</guid>
      <source url="https://leijue222.github.io/rss.xml">数组</source>
      <description>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>数组(array)是一个包含多个值的变量。成员的编号从 0 开始，数量没有上限，也没有要求成员被连续索引。</p>
<!-- more -->
<h2> 创建数组</h2>
<p>数组可以采用逐个赋值的方法创建。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面语法中，<code>ARRAY</code> 是数组的名字，可以是任意合法的变量名。<code>INDEX</code> 是一个大于或等于零的整数，也可以是算术表达式。注意数组第一个元素的下标是 0， 而不是 1。</p>
<p>下面创建一个三个成员的数组。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组也可以采用一次性赋值的方式创建。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>采用上面方式创建数组时，可以按照默认顺序赋值，也可以在每个值前面指定位置。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只为某些值指定位置，也是可以的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，<code>hatter</code> 是数组的 0 号位置，<code>duchess</code> 是 5 号位置，<code>alice</code> 是 6 号位置。</p>
<p>没有赋值的数组元素的默认值是空字符串。</p>
<p>定义数组的时候，可以使用通配符。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，将当前目录的所有 MP3 文件，放进一个数组。</p>
<p>先用 <code>declare -a</code> 命令声明一个数组，也是可以的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>read -a</code> 命令则是将用户的命令行输入，读入一个数组。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令将用户的命令行输入，读入数组 <code>dice</code>。</p>
<h2> 读取数组</h2>
<h3> 读取单个元素</h3>
<p>读取数组指定位置的成员，要使用下面的语法。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面语法里面的大括号是必不可少的，否则 Bash 会把索引部分 <code>[i]</code> 按照原样输出。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，数组的第一个元素是 <code>a</code>。如果不加大括号，Bash 会直接读取 <code>$array</code> 首成员的值，然后将 <code>[0]</code> 按照原样输出。</p>
<h3> 读取所有成员</h3>
<p><code>@</code> 和 <code>*</code> 是数组的特殊索引，表示返回数组的所有成员。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两个特殊索引配合 <code>for</code> 循环，就可以用来遍历数组。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>@</code> 和 <code>*</code> 放不放在双引号之中，是有差别的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子中，数组 <code>activities</code> 实际包含 5 个元素，但是 <code>for...in</code> 循环直接遍历 <code>${activities[@]}</code>，会导致返回 7 个结果。为了避免这种情况，一般把 <code>${activities[@]}</code> 放在双引号之中。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>${activities[@]}</code> 放在双引号之中，遍历就会返回正确的结果。</p>
<p><code>${activities[*]}</code> 不放在双引号之中，跟 <code>${activities[@]}</code> 不放在双引号之中是一样的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>${activities[*]}</code> 放在双引号之中，所有元素就会变成单个字符串返回。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，拷贝一个数组的最方便方法，就是写成下面这样。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，数组 <code>activities</code> 被拷贝给了另一个数组 <code>hobbies</code>。</p>
<p>这种写法也可以用来为新数组添加成员。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，新数组 <code>hobbies</code> 在数组 <code>activities</code> 的所有成员之后，又添加了一个成员。</p>
<h3> 默认位置</h3>
<p>如果读取数组成员时，没有读取指定哪一个位置的成员，默认使用 <code>0</code> 号位置。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>foo</code> 是一个数组，赋值的时候不指定位置，实际上是给 <code>foo[0]</code> 赋值。</p>
<p>引用一个不带下标的数组变量，则引用的是 <code>0</code> 号位置的数组元素。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，引用数组元素的时候，没有指定位置，结果返回的是 <code>0</code> 号位置。</p>
<h2> 数组的长度</h2>
<p>要想知道数组的长度(即一共包含多少成员)，可以使用下面两种语法。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，把字符串赋值给 <code>100</code> 位置的数组元素，这时的数组只有一个元素。</p>
<p>注意，如果用这种语法去读取具体的数组成员，就会返回该成员的字符串长度。这一点必须小心。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>${#a[100]}</code> 实际上是返回数组第 100 号成员 <code>a[100]</code> 的值(<code>foo</code>)的字符串长度。</p>
<h2> 提取数组序号</h2>
<p><code>${!array[@]}</code> 或 <code>${!array[*]}</code>，可以返回数组的成员序号，即哪些位置是有值的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，数组的 5、9、23 号位置有值。</p>
<p>利用这个语法，也可以通过 <code>for</code> 循环遍历数组。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 提取数组成员</h2>
<p><code>${array[@]:position:length}</code> 的语法可以提取数组成员。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>${food[@]:1:1}</code> 返回从数组 1 号位置开始的 1 个成员，<code>${food[@]:1:3}</code> 返回从 1 号位置开始的 3 个成员。</p>
<p>如果省略长度参数 <code>length</code>，则返回从指定位置开始的所有成员。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子返回从 4 号位置开始到结束的所有成员。</p>
<h2> 追加数组成员</h2>
<p>数组末尾追加成员，可以使用 <code>+=</code> 赋值运算符。它能够自动地把值追加到数组末尾。否则，就需要知道数组的最大序号，比较麻烦。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 删除数组</h2>
<p>删除一个数组成员，使用 <code>unset</code> 命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，删除了数组中的第三个元素，下标为 2。</p>
<p>删除成员也可以将这个成员设为空值。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，将数组的第二个成员设为空字符串，就删除了这个成员。</p>
<p>由于空值就是空字符串，所以下面这样写也可以，但是不建议这种写法。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的写法也相当于删除了数组的第二个成员。</p>
<p>直接将数组变量赋值为空字符串，相当于删除数组的第一个成员。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的写法相当于删除了数组的第一个成员。</p>
<p><code>unset ArrayName</code> 可以清空整个数组。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 关联数组</h2>
<p>Bash 的新版本支持关联数组。关联数组使用字符串而不是整数作为数组索引。</p>
<p><code>declare -A</code> 可以声明关联数组。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整数索引的数组，可以直接使用变量名创建数组，关联数组则必须用带有 <code>-A</code> 选项的 <code>declare</code> 命令声明创建。</p>
<p>访问关联数组成员的方式，几乎与整数索引数组相同。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>条件判断</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/condition.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/condition.html</guid>
      <source url="https://leijue222.github.io/rss.xml">条件判断</source>
      <description>本章介绍 Bash 脚本的条件判断语法。</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 脚本的条件判断语法。</p>
<!-- more -->
<h2> if 结构</h2>
<p><code>if</code> 是最常用的条件判断结构，只有符合给定条件时，才会执行指定的命令。它的语法如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个命令分成三个部分: <code>if</code>、<code>elif</code> 和 <code>else</code>。其中，后两个部分是可选的。</p>
<p><code>if</code> 关键字后面是主要的判断条件，<code>elif</code> 用来添加在主条件不成立时的其他判断条件，<code>else</code> 则是所有条件都不成立时要执行的部分。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子中，判断条件是环境变量 <code>$USER</code> 是否等于 <code>foo</code>，如果等于就输出 <code>Hello foo.</code>，否则输出其他内容。</p>
<p><code>if</code> 和 <code>then</code> 写在同一行时，需要分号分隔。分号是 Bash 的命令分隔符。它们也可以写成两行，这时不需要分号。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子中，<code>true</code> 和 <code>false</code> 是两个特殊命令，前者代表操作成功，后者代表操作失败。<code>if true</code> 意味着命令部分总是会执行，<code>if false</code> 意味着命令部分永远不会执行。</p>
<p>除了多行的写法，<code>if</code> 结构也可以写成单行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，<code>if</code> 关键字后面也可以是一条命令，该条命令执行成功(返回值 <code>0</code>)，就意味着判断条件成立。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，<code>if</code> 后面是一条命令 <code>echo 'hi'</code>。该命令会执行，如果返回值是 <code>0</code>，则执行 <code>then</code> 的部分。</p>
<p><code>if</code> 后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回 <code>0</code>，就会执行 <code>then</code> 的部分。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>if</code> 后面有两条命令 (<code>false;true;</code>)，第二条命令 (<code>true</code>) 决定了 <code>then</code> 的部分是否会执行。</p>
<p><code>elif</code> 部分可以有多个。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，如果用户输入 <code>3</code>，就会连续判断 3 次。</p>
<h2> test 命令</h2>
<p><code>if</code> 结构的判断条件，一般使用 <code>test</code> 命令，有三种形式。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面三种形式是等价的，但是第三种形式还支持正则判断，前两种不支持。</p>
<p>上面的 <code>expression</code> 是一个表达式。这个表达式为真，<code>test</code> 命令执行成功(返回值为 <code>0</code>)；表达式为伪，<code>test</code> 命令执行失败(返回值为 <code>1</code>)。注意，第二种和第三种写法，<code>[</code> 和 <code>]</code> 与内部的表达式之间必须有空格。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子中，<code>test</code> 命令采用两种写法，判断 <code>/etc/hosts</code> 文件是否存在，这两种写法是等价的。命令执行后，返回值为 <code>0</code>，表示该文件确实存在。</p>
<p>实际上，<code>[</code> 这个字符是 <code>test</code> 命令的一种简写形式，可以看作是一个独立的命令，这解释了为什么它后面必须有空格。</p>
<p>下面把 <code>test</code> 命令的三种形式，用在 <code>if</code> 结构中，判断一个文件是否存在。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 判断表达式</h2>
<p><code>if</code> 关键字后面，跟的是一个命令。这个命令可以是 <code>test</code> 命令，也可以是其他命令。命令的返回值为 <code>0</code> 表示判断成立，否则表示不成立。因为这些命令主要是为了得到返回值，所以可以视为表达式。</p>
<p>常用的判断表达式有下面这些。</p>
<h3> 文件判断</h3>
<p>以下表达式用来判断文件状态。</p>
<ul>
<li><code>[ -a file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -b file ]</code>: 如果 file 存在并且是一个块(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -c file ]</code>: 如果 file 存在并且是一个字符(设备)文件，则为 <code>true</code>。</li>
<li><code>[ -d file ]</code>: 如果 file 存在并且是一个目录，则为 <code>true</code>。</li>
<li><code>[ -e file ]</code>: 如果 file 存在，则为 <code>true</code>。</li>
<li><code>[ -f file ]</code>: 如果 file 存在并且是一个普通文件，则为 <code>true</code>。</li>
<li><code>[ -g file ]</code>: 如果 file 存在并且设置了组 ID，则为 <code>true</code>。</li>
<li><code>[ -G file ]</code>: 如果 file 存在并且属于有效的组 ID，则为 <code>true</code>。</li>
<li><code>[ -h file ]</code>: 如果 file 存在并且是符号链接，则为 <code>true</code>。</li>
<li><code>[ -k file ]</code>: 如果 file 存在并且设置了它的“sticky bit”，则为 <code>true</code>。</li>
<li><code>[ -L file ]</code>: 如果 file 存在并且是一个符号链接，则为 <code>true</code>。</li>
<li><code>[ -N file ]</code>: 如果 file 存在并且自上次读取后已被修改，则为 <code>true</code>。</li>
<li><code>[ -O file ]</code>: 如果 file 存在并且属于有效的用户 ID，则为 <code>true</code>。</li>
<li><code>[ -p file ]</code>: 如果 file 存在并且是一个命名管道，则为 <code>true</code>。</li>
<li><code>[ -r file ]</code>: 如果 file 存在并且可读(当前用户有可读权限)，则为 <code>true</code>。</li>
<li><code>[ -s file ]</code>: 如果 file 存在且其长度大于零，则为 <code>true</code>。</li>
<li><code>[ -S file ]</code>: 如果 file 存在且是一个网络 socket，则为 <code>true</code>。</li>
<li><code>[ -t fd ]</code>: 如果 fd 是一个文件描述符，并且重定向到终端，则为 <code>true</code>。这可以用来判断是否重定向了标准输入／输出错误。</li>
<li><code>[ -u file ]</code>: 如果 file 存在并且设置了 setuid 位，则为 <code>true</code>。</li>
<li><code>[ -w file ]</code>: 如果 file 存在并且可写(当前用户拥有可写权限)，则为 <code>true</code>。</li>
<li><code>[ -x file ]</code>: 如果 file 存在并且可执行(有效用户有执行／搜索权限)，则为 <code>true</code>。</li>
<li><code>[ file1 -nt file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间最近，或者 FILE1 存在而 FILE2 不存在，则为 <code>true</code>。</li>
<li><code>[ file1 -ot file2 ]</code>: 如果 FILE1 比 FILE2 的更新时间更旧，或者 FILE2 存在而 FILE1 不存在，则为 <code>true</code>。</li>
<li><code>[ FILE1 -ef FILE2 ]</code>: 如果 FILE1 和 FILE2 引用相同的设备和 inode 编号，则为 <code>true</code>。</li>
</ul>
<p>下面是一个示例。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>$FILE</code> 要放在双引号之中。这样可以防止 <code>$FILE</code> 为空，因为这时 <code>[ -e ]</code> 会判断为真。而放在双引号之中，返回的就总是一个空字符串，<code>[ -e "" ]</code> 会判断为伪。</p>
<h3> 字符串判断</h3>
<p>以下表达式用来判断字符串。</p>
<ul>
<li><code>[ string ]</code>: 如果 <code>string</code> 不为空(长度大于 0)，则判断为真。</li>
<li><code>[ -n string ]</code>: 如果字符串 <code>string</code> 的长度大于零，则判断为真。</li>
<li><code>[ -z string ]</code>: 如果字符串 <code>string</code> 的长度为零，则判断为真。</li>
<li><code>[ string1 = string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 相同，则判断为真。</li>
<li><code>[ string1 == string2 ]</code> 等同于 <code>[ string1 = string2 ]</code>。</li>
<li><code>[ string1 != string2 ]</code>: 如果 <code>string1</code> 和 <code>string2</code> 不相同，则判断为真。</li>
<li><code>[ string1 '&gt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之后，则判断为真。</li>
<li><code>[ string1 '&lt;' string2 ]</code>: 如果按照字典顺序 <code>string1</code> 排列在 <code>string2</code> 之前，则判断为真。</li>
</ul>
<p>注意，<code>test</code> 命令内部的 <code>&gt;</code> 和 <code>&lt;</code>，必须用引号引起来(或者是用反斜杠转义)。否则，它们会被 shell 解释为重定向操作符。</p>
<p>下面是一个示例。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，首先确定 <code>$ANSWER</code> 字符串是否为空。如果为空，就终止脚本，并把退出状态设为 <code>1</code>。注意，这里的 <code>echo</code> 命令把错误信息 <code>There is no answer.</code> 重定向到标准错误，这是处理错误信息的常用方法。如果 <code>$ANSWER</code> 字符串不为空，就判断它的值是否等于 <code>yes</code>、<code>no</code> 或者 <code>maybe</code>。</p>
<p>注意，字符串判断时，变量要放在双引号之中，比如 <code>[ -n "$COUNT" ]</code>，否则变量替换成字符串以后，<code>test</code> 命令可能会报错，提示参数过多。另外，如果不放在双引号之中，变量为空时，命令会变成 <code>[ -n ]</code>，这时会判断为真。如果放在双引号之中，<code>[ -n "" ]</code> 就判断为伪。</p>
<h3> 整数判断</h3>
<p>下面的表达式用于判断整数。</p>
<ul>
<li><code>[ integer1 -eq integer2 ]</code>: 如果 <code>integer1</code> 等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ne integer2 ]</code>: 如果 <code>integer1</code> 不等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -le integer2 ]</code>: 如果 <code>integer1</code> 小于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -lt integer2 ]</code>: 如果 <code>integer1</code> 小于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -ge integer2 ]</code>: 如果 <code>integer1</code> 大于或等于 <code>integer2</code>，则为 <code>true</code>。</li>
<li><code>[ integer1 -gt integer2 ]</code>: 如果 <code>integer1</code> 大于 <code>integer2</code>，则为 <code>true</code>。</li>
</ul>
<p>下面是一个用法的例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，先判断变量 <code>$INT</code> 是否为空，然后判断是否为 <code>0</code>，接着判断正负，最后通过求余数判断奇偶。</p>
<h3> 正则判断</h3>
<p><code>[[ expression ]]</code> 这种判断形式，支持正则表达式。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的语法中，<code>regex</code> 是一个正则表示式，<code>=~</code> 是正则比较运算符。</p>
<p>下面是一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，先判断变量 <code>INT</code> 的字符串形式，是否满足 <code>^-?[0-9]+$</code> 的正则模式，如果满足就表明它是一个整数。</p>
<h3> test 判断的逻辑运算</h3>
<p>通过逻辑运算，可以把多个 <code>test</code> 判断表达式结合起来，创造更复杂的判断。三种逻辑运算 <code>AND</code>，<code>OR</code>，和 <code>NOT</code>，都有自己的专用符号。</p>
<ul>
<li><code>AND</code> 运算: 符号 <code>&amp;&amp;</code>，也可使用参数 <code>-a</code>。</li>
<li><code>OR</code> 运算: 符号 <code>||</code>，也可使用参数 <code>-o</code>。</li>
<li><code>NOT</code> 运算: 符号 <code>!</code>。</li>
</ul>
<p>下面是一个 <code>AND</code> 的例子，判断整数是否在某个范围之内。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>&amp;&amp;</code> 用来连接两个判断条件: 大于等于 <code>$MIN_VAL</code>，并且小于等于 <code>$MAX_VAL</code>。</p>
<p>使用否定操作符 <code>!</code> 时，最好用圆括号确定转义的范围。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>test</code> 命令内部使用的圆括号，必须使用引号或者转义，否则会被 Bash 解释。</p>
<h3> 算术判断</h3>
<p>Bash 还提供了 <code>((...))</code> 作为算术条件，进行算术运算的判断。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码执行后，会打印出 <code>true</code>。</p>
<p>注意，算术判断不需要使用 <code>test</code> 命令，而是直接使用 <code>((...))</code> 结构。这个结构的返回值，决定了判断的真伪。</p>
<p>如果算术计算的结果是非零值，则表示判断成立。这一点跟命令的返回值正好相反，需要小心。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>((1))</code> 表示判断成立，<code>((0))</code> 表示判断不成立。</p>
<p>算术条件 <code>((...))</code> 也可以用于变量赋值。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>(( foo = 5 ))</code> 完成了两件事情。首先把 <code>5</code> 赋值给变量 <code>foo</code>，然后根据返回值 <code>5</code>，判断条件为真。</p>
<p>注意，赋值语句返回等号右边的值，如果返回的是 <code>0</code>，则判断为假。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是用算术条件改写的数值判断脚本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只要是算术表达式，都能用于 <code>((...))</code> 语法，详见 <a href="/tutorial/ops/linux/bash/arithmetic.html" target="blank">Bash 的算术运算</a> 一章。</p>
<h3> 普通命令的逻辑运算</h3>
<p>如果 <code>if</code> 结构使用的不是 <code>test</code> 命令，而是普通命令，比如上一节的 <code>((...))</code> 算术运算，或者 <code>test</code> 命令与普通命令混用，那么可以使用 Bash 的命令控制操作符 <code>&amp;&amp;</code>(AND)和 <code>||</code>(OR)，进行多个命令的逻辑运算。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于 <code>&amp;&amp;</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行成功后， 才会执行 <code>command2</code>。对于 <code>||</code> 操作符，先执行 <code>command1</code>，只有 <code>command1</code> 执行失败后， 才会执行 <code>command2</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的命令会创建一个名为 <code>temp</code> 的目录，执行成功后，才会执行第二个命令，进入这个目录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的命令会测试目录 <code>temp</code> 是否存在，如果不存在，就会执行第二个命令，创建这个目录。这种写法非常有助于在脚本中处理错误。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的命令中，如果 <code>temp</code> 子目录不存在，脚本会终止，并且返回值为 <code>1</code>。</p>
<p>下面就是 <code>if</code> 与 <code>&amp;&amp;</code> 结合使用的写法。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个示例。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子只有在指定文件里面，同时存在搜索词 <code>word1</code> 和 <code>word2</code>，就会执行 <code>if</code> 的命令部分。</p>
<p>下面的示例演示如何将一个 <code>&amp;&amp;</code> 判断表达式，改写成对应的 <code>if</code> 结构。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> case 结构</h2>
<p><code>case</code> 结构用于多值判断，可以为每个值指定对应的命令，跟包含多个 <code>elif</code> 的 <code>if</code> 结构等价，但是语义更好。它的语法如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>expression</code> 是一个表达式，<code>pattern</code> 是表达式的值或者一个模式，可以有多条，用来匹配多个值，每条以两个分号 (<code>;</code>) 结尾。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，最后一条匹配语句的模式是 <code>*</code>，这个通配符可以匹配其他字符和没有输入字符的情况，类似 <code>if</code> 的 <code>else</code> 部分。</p>
<p>下面是另一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子判断当前是什么操作系统。</p>
<p><code>case</code> 的匹配模式可以使用各种通配符，下面是一些例子。</p>
<ul>
<li><code>a)</code>: 匹配 <code>a</code>。</li>
<li><code>a|b)</code>: 匹配 <code>a</code> 或 <code>b</code>。</li>
<li><code>[[:alpha:]])</code>: 匹配单个字母。</li>
<li><code>???)</code>: 匹配 3 个字符的单词。</li>
<li><code>*.txt)</code>: 匹配 <code>.txt</code> 结尾。</li>
<li><code>*)</code>: 匹配任意输入，通过作为 <code>case</code> 结构的最后一个模式。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，使用通配符 <code>[[:lower:]] | [[:upper:]]</code> 匹配字母，<code>[0-9]</code> 匹配数字。</p>
<p>Bash 4.0 之前，<code>case</code> 结构只能匹配一个条件，然后就会退出 <code>case</code> 结构。Bash 4.0 之后，允许匹配多个条件，这时可以用 <code>;;&amp;</code> 终止每个条件块。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面的脚本，会得到下面的结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到条件语句结尾添加了 <code>;;&amp;</code> 以后，在匹配一个条件之后，并没有退出 <code>case</code> 结构，而是继续判断下一个条件。</p>
<h2> 参考链接</h2>
<ul>
<li><a href="http://linuxcommand.org/tlcl.php" target="_blank" rel="noopener noreferrer">The Linux command-line</a>, William Shotts</li>
<li><a href="https://www.pcwdld.com/linux-commands-cheat-sheet" target="_blank" rel="noopener noreferrer">Linux Commands Cheat Sheet</a> (一个很简短的 CheatSheet)</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>脚本除错</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/debug.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/debug.html</guid>
      <source url="https://leijue222.github.io/rss.xml">脚本除错</source>
      <description>本章介绍如何对 Shell 脚本除错。</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍如何对 Shell 脚本除错。</p>
<!-- more -->
<h2> 常见错误</h2>
<p>编写 Shell 脚本的时候，一定要考虑到命令失败的情况，否则很容易出错。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面脚本中，如果目录 <code>$dir_name</code> 不存在，<code>cd $dir_name</code> 命令就会执行失败。这时，就不会改变当前目录，脚本会继续执行下去，导致 <code>rm *</code> 命令删光当前目录的文件。</p>
<p>如果改成下面的样子，也会有问题。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面脚本中，只有 <code>cd $dir_name</code> 执行成功，才会执行 <code>rm *</code>。但是，如果变量 <code>$dir_name</code> 为空，<code>cd</code> 就会进入用户主目录，从而删光用户主目录的文件。</p>
<p>下面的写法才是正确的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码中，先判断目录 <code>$dir_name</code> 是否存在，然后才执行其他操作。</p>
<p>如果不放心删除什么文件，可以先打印出来看一下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令中，<code>echo rm *</code> 不会删除文件，只会打印出来要删除的文件。</p>
<h2> <code>bash</code> 的 <code>-x</code> 参数</h2>
<p><code>bash</code> 的 <code>-x</code> 参数可以在执行每一行命令之前，打印该命令。这样就不用自己输出执行的命令，一旦出错，比较容易追查。</p>
<p>下面是一个脚本 <code>script.sh</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>加上 <code>-x</code> 参数，执行每条命令之前，都会显示该命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，行首为 <code>+</code> 的行，显示该行是所要执行的命令，下一行才是该命令的执行结果。</p>
<p>下面再看一个 <code>-x</code> 写在脚本内部的例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的脚本执行之后，会输出每一行命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出的命令之前的 <code>+</code> 号，是由系统变量 <code>PS4</code> 决定，可以修改这个变量。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，<code>set</code> 命令也可以设置 Shell 的行为参数，有利于脚本除错，详见 <a href="/tutorial/ops/linux/bash/set.html" target="blank">set 命令</a> 一章。</p>
<h2> 环境变量</h2>
<p>有一些环境变量常用于除错。</p>
<h3> LINENO</h3>
<p>变量 <code>LINENO</code> 返回它在脚本里面的行号。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面的脚本 <code>test.sh</code>，<code>$LINENO</code> 会返回 <code>3</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> FUNCNAME</h3>
<p>变量 <code>FUNCNAME</code> 返回一个数组，内容是当前的函数调用堆栈。该数组的 0 号成员是当前调用的函数，1 号成员是调用当前函数的函数，以此类推。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面的脚本 <code>test.sh</code>，结果如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，执行 <code>func1</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func1</code>，1 号成员是调用 <code>func1</code> 的主脚本 <code>main</code>。执行 <code>func2</code> 时，变量 <code>FUNCNAME</code> 的 0 号成员是 <code>func2</code>，1 号成员是调用 <code>func2</code> 的 <code>func1</code>。</p>
<h3> BASH_SOURCE</h3>
<p>变量 <code>BASH_SOURCE</code> 返回一个数组，内容是当前的脚本调用堆栈。该数组的 0 号成员是当前执行的脚本，1 号成员是调用当前脚本的脚本，以此类推，跟变量 <code>FUNCNAME</code> 是一一对应关系。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，执行函数 <code>func1</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func1</code> 所在的脚本 <code>lib1.sh</code>，1 号成员是主脚本 <code>main.sh</code>；执行函数 <code>func2</code> 时，变量 <code>BASH_SOURCE</code> 的 0 号成员是 <code>func2</code> 所在的脚本 <code>lib2.sh</code>，1 号成员是调用 <code>func2</code> 的脚本 <code>lib1.sh</code>。</p>
<h3> BASH_LINENO</h3>
<p>变量 <code>BASH_LINENO</code> 返回一个数组，内容是每一轮调用对应的行号。<code>${BASH_LINENO[$i]}</code> 跟 <code>${FUNCNAME[$i]}</code> 是一一对应关系，表示 <code>${FUNCNAME[$i]}</code> 在调用它的脚本文件 <code>${BASH_SOURCE[$i+1]}</code> 里面的行号。</p>
<p>下面有两个子脚本 <code>lib1.sh</code> 和 <code>lib2.sh</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后，主脚本 <code>main.sh</code> 调用上面两个子脚本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行主脚本 <code>main.sh</code>，会得到下面的结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，函数 <code>func1</code> 是在 <code>main.sh</code> 的第 7 行调用，函数 <code>func2</code> 是在 <code>lib1.sh</code> 的第 8 行调用的。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的模式扩展</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/expansion.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/expansion.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Bash 的模式扩展</source>
      <description>简介 Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元(token)。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。 这种特殊字符的扩展，称为模式扩展(globbing)。其中有些用到通配符，又称为通配符扩展(wildcard expansion)。Bash 一共提供八种扩展。 波浪线扩展; ?...</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 简介</h2>
<p>Shell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元(token)。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。</p>
<p>这种特殊字符的扩展，称为模式扩展(globbing)。其中有些用到通配符，又称为通配符扩展(wildcard expansion)。Bash 一共提供八种扩展。</p>
<ul>
<li>波浪线扩展</li>
<li><code>?</code> 字符扩展</li>
<li><code>*</code> 字符扩展</li>
<li>方括号扩展</li>
<li>大括号扩展</li>
<li>变量扩展</li>
<li>子命令扩展</li>
<li>算术扩展</li>
</ul>
<p>本章介绍这八种扩展。</p>
<p>Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。</p>
<p><code>globbing</code> 这个词，来自于早期的 Unix 系统有一个 <code>/etc/glob</code> 文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。</p>
<p>模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。</p>
<p>Bash 允许用户关闭扩展。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面的命令可以重新打开扩展。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 波浪线扩展</h2>
<p>波浪线 <code>~</code> 会自动扩展成当前用户的主目录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>~/dir</code> 表示扩展成主目录的某个子目录，<code>dir</code> 是主目录里面的一个子目录名。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>~user</code> 表示扩展成用户 <code>user</code> 的主目录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。</p>
<p>如果 <code>~user</code> 的 <code>user</code> 是不存在的用户名，则波浪号扩展不起作用。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>~+</code> 会扩展成当前所在的目录，等同于 <code>pwd</code> 命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> <code>?</code> 字符扩展</h2>
<p><code>?</code> 字符代表文件路径里面的任意单个字符，不包括空字符。比如，<code>Data???</code> 匹配所有 <code>Data</code> 后面跟着三个字符的文件名。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，<code>?</code> 表示单个字符，所以会同时匹配 <code>a.txt</code> 和 <code>b.txt</code>。</p>
<p>如果匹配多个字符，就需要多个 <code>?</code> 连用。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，<code>??</code> 匹配了两个字符。</p>
<p><code>?</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，如果 <code>?.txt</code> 可以扩展成文件名，<code>echo</code> 命令会输出扩展后的结果；如果不能扩展成文件名，<code>echo</code> 就会原样输出 <code>?.txt</code>。</p>
<h2> <code>*</code> 字符扩展</h2>
<p><code>*</code> 字符代表文件路径里面的任意数量的任意字符，包括零个字符。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>*.txt</code> 代表后缀名为 <code>.txt</code> 的所有文件。</p>
<p>如果想输出当前目录的所有文件，直接用 <code>*</code> 即可。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>*</code> 可以匹配空字符，下面是一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，<code>*</code> 不会匹配隐藏文件(以 <code>.</code> 开头的文件)，即 <code>ls *</code> 不会输出隐藏文件。</p>
<p>如果要匹配隐藏文件，需要写成 <code>.*</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要匹配隐藏文件，同时要排除 <code>.</code> 和 <code>..</code> 这两个特殊的隐藏文件，可以与方括号扩展结合使用，写成 <code>.[!.]*</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意，<code>*</code> 字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，当前目录里面没有 <code>c</code> 开头的文件，导致 <code>c*.txt</code> 会原样输出。</p>
<p><code>*</code> 只匹配当前目录，不会匹配子目录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子，文本文件在子目录，<code>*.txt</code> 不会产生匹配，必须写成 <code>*/*.txt</code>。有几层子目录，就必须写几层星号。</p>
<p>Bash 4.0 引入了一个参数 <code>globstar</code>，当该参数打开时，允许 <code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面 <code>shopt</code> 命令的介绍。</p>
<h2> 方括号扩展</h2>
<p>方括号扩展的形式是 <code>[...]</code>，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，<code>[aeiou]</code> 可以匹配五个元音字母中的任意一个。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>[ab]</code> 可以匹配 <code>a</code> 或 <code>b</code>，前提是确实存在相应的文件。</p>
<p>方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，由于扩展后的文件不存在，<code>[ab].txt</code> 就原样输出了，导致 <code>ls</code> 命名报错。</p>
<p>方括号扩展还有两种变体: <code>[^...]</code> 和 <code>[!...]</code>。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，<code>[^abc]</code> 或 <code>[!abc]</code> 表示匹配除了 <code>a</code>、<code>b</code>、<code>c</code> 以外的字符。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，<code>[!a]</code> 表示文件名第二个字符不是 <code>a</code> 的文件名，所以返回了 <code>aba</code> 和 <code>bbb</code> 两个文件。</p>
<p>注意，如果需要匹配 <code>[</code> 字符，可以放在方括号内，比如 <code>[[aeiou]</code>。如果需要匹配连字号 <code>-</code>，只能放在方括号内部的开头或结尾，比如 <code>[-aeiou]</code> 或 <code>[aeiou-]</code>。</p>
<h2> [start-end] 扩展</h2>
<p>方括号扩展有一个简写形式 <code>[start-end]</code>，表示匹配一个连续的范围。比如，<code>[a-c]</code> 等同于 <code>[abc]</code>，<code>[0-9]</code> 匹配 <code>[0123456789]</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一些常用简写的例子。</p>
<ul>
<li><code>[a-z]</code>: 所有小写字母。</li>
<li><code>[a-zA-Z]</code>: 所有小写字母与大写字母。</li>
<li><code>[a-zA-Z0-9]</code>: 所有小写字母、大写字母与数字。</li>
<li><code>[abc]*</code>: 所有以 <code>a</code>、<code>b</code>、<code>c</code> 字符之一开头的文件名。</li>
<li><code>program.[co]</code>: 文件 <code>program.c</code> 与文件 <code>program.o</code>。</li>
<li><code>BACKUP.[0-9][0-9][0-9]</code>: 所有以 <code>BACKUP.</code> 开头，后面是三个数字的文件名。</li>
</ul>
<p>这种简写形式有一个否定形式 <code>[!start-end]</code>，表示匹配不属于这个范围的字符。比如，<code>[!a-zA-Z]</code> 表示匹配非英文字母的字符。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>[!1-3]</code> 表示排除 1、2 和 3。</p>
<h2> 大括号扩展</h2>
<p>大括号扩展 <code>{...}</code> 表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，<code>{1,2,3}</code> 扩展成 <code>1 2 3</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，即使不存在对应的文件，<code>{a,b,c}</code> 依然扩展成三个文件名，导致 <code>ls</code> 命令报了三个错误。</p>
<p>另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。</p>
<p>逗号前面可以没有值，表示扩展的第一项为空。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大括号可以嵌套。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，会先进行大括号扩展，然后进行 <code>*</code> 扩展。</p>
<p>大括号可以用于多字符的模式，方括号不行(只能匹配单字符)。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于大括号扩展 <code>{...}</code> 不是文件名扩展，所以它总是会扩展的。这与方括号扩展 <code>[...]</code> 完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，如果不存在 <code>a.txt</code> 和 <code>b.txt</code>，那么 <code>[ab].txt</code> 就会变成一个普通的文件名，而 <code>{a,b}.txt</code> 可以照样扩展。</p>
<h2> {start..end} 扩展</h2>
<p>大括号扩展有一个简写形式 <code>{start..end}</code>，表示扩展成一个连续序列。比如，<code>{a..z}</code> 可以扩展成 26 个小写英文字母。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种简写形式支持逆序。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种简写形式可以嵌套使用，形成复杂的扩展。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>大括号扩展的常见用途为新建一系列目录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令会新建 36 个子目录，每个子目录的名字都是”年份-月份“。</p>
<p>这个写法的另一个常见用途，是直接用于 <code>for</code> 循环。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子会循环 4 次。</p>
<p>如果整数前面有前导 <code>0</code>，扩展输出的每一项都有前导 <code>0</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种简写形式还可以使用第二个双点号(<code>start..end..step</code>)，用来指定扩展的步长。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码将 <code>0</code> 扩展到 <code>8</code>，每次递增的长度为 <code>2</code>，所以一共输出 5 个数字。</p>
<p>多个简写形式连用，会有循环处理的效果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 变量扩展</h2>
<p>Bash 将美元符号 <code>$</code> 开头的词元视为变量，将其扩展成变量值，详见<a href="/tutorial/ops/linux/bash/variable.html" target="blank">Bash 变量</a> 一章。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>变量名除了放在美元符号后面，也可以放在 <code>${}</code> 里面。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>${!string*}</code> 或 <code>${!string@}</code> 返回所有匹配给定字符串 <code>string</code> 的变量名。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>${!S*}</code> 扩展成所有以 <code>S</code> 开头的变量名。</p>
<h2> 子命令扩展</h2>
<p><code>$(...)</code> 可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>$(date)</code> 返回 <code>date</code> 命令的运行结果。</p>
<p>还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>$(...)</code> 可以嵌套，比如 <code>$(ls $(pwd))</code>。</p>
<h2> 算术扩展</h2>
<p><code>$((...))</code> 可以扩展成整数运算的结果，详见 <a href="/tutorial/ops/linux/bash/arithmetic.html" target="blank">Bash 的算术运算</a> 一章。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 字符类</h2>
<p><code>[[:class:]]</code> 表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。</p>
<ul>
<li><code>[[:alnum:]]</code>: 匹配任意英文字母与数字</li>
<li><code>[[:alpha:]]</code>: 匹配任意英文字母</li>
<li><code>[[:blank:]]</code>: 空格和 Tab 键。</li>
<li><code>[[:cntrl:]]</code>: ASCII 码 0-31 的不可打印字符。</li>
<li><code>[[:digit:]]</code>: 匹配任意数字 0-9。</li>
<li><code>[[:graph:]]</code>: A-Z、a-z、0-9 和标点符号。</li>
<li><code>[[:lower:]]</code>: 匹配任意小写字母 a-z。</li>
<li><code>[[:print:]]</code>: ASCII 码 32-127 的可打印字符。</li>
<li><code>[[:punct:]]</code>: 标点符号(除了 A-Z、a-z、0-9 的可打印字符)。</li>
<li><code>[[:space:]]</code>: 空格、Tab、LF(10)、VT(11)、FF(12)、CR(13)。</li>
<li><code>[[:upper:]]</code>: 匹配任意大写字母 A-Z。</li>
<li><code>[[:xdigit:]]</code>: 16 进制字符(A-F、a-f、0-9)。</li>
</ul>
<p>请看下面的例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令输出所有大写字母开头的文件名。</p>
<p>字符类的第一个方括号后面，可以加上感叹号 <code>!</code>，表示否定。比如，<code>[![:digit:]]</code> 匹配所有非数字。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令输出所有不以数字开头的文件名。</p>
<p>字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，由于没有可匹配的文件，字符类就原样输出了。</p>
<h2> 使用注意点</h2>
<p>通配符有一些使用注意点，不可不知。</p>
<p>(1)<strong>通配符是先解释，再执行。</strong></p>
<p>Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令的执行过程是，Bash 先将 <code>a*.txt</code> 扩展成 <code>ab.txt</code>，然后再执行 <code>ls ab.txt</code>。</p>
<p>(2)<strong>文件名扩展在不匹配时，会原样输出。</strong></p>
<p>文件名扩展在没有可匹配的文件时，会原样输出。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，由于不存在 <code>r</code> 开头的文件名，<code>r*</code> 会原样输出。</p>
<p>下面是另一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，前面已经说过，大括号扩展 <code>{...}</code> 不是文件名扩展。</p>
<p>(3)<strong>只适用于单层路径。</strong></p>
<p>所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，<code>?</code> 或 <code>*</code> 这样的通配符，不能匹配路径分隔符 (<code>/</code>)。</p>
<p>如果要匹配子目录里面的文件，可以写成下面这样。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Bash 4.0 新增了一个 <code>globstar</code> 参数，允许 <code>**</code> 匹配零个或多个子目录，详见后面 <code>shopt</code> 命令的介绍。</p>
<p>(4)<strong>文件名可以使用通配符。</strong></p>
<p>Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码创建了一个 <code>fo*</code> 文件，这时 <code>*</code> 就是文件名的一部分。</p>
<h2> 量词语法</h2>
<p>量词语法用来控制模式匹配的次数。它只有在 Bash 的 <code>extglob</code> 参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>量词语法有下面几个。</p>
<ul>
<li><code>?(pattern-list)</code>: 匹配零个或一个模式。</li>
<li><code>*(pattern-list)</code>: 匹配零个或多个模式。</li>
<li><code>+(pattern-list)</code>: 匹配一个或多个模式。</li>
<li><code>@(pattern-list)</code>: 只匹配一个模式。</li>
<li><code>!(pattern-list)</code>: 匹配零个或一个以上的模式，但不匹配单独一个的模式。</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>?(.)</code> 匹配零个或一个点。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>?(def)</code> 匹配零个或一个 <code>def</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>+(.txt|.php)</code> 匹配文件有一个 <code>.txt</code> 或 <code>.php</code> 后缀名。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>+(.txt)</code> 匹配文件有一个或多个 <code>.txt</code> 后缀名。</p>
<p>量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，由于没有可匹配的文件，<code>abc?(def)</code> 就原样输出，导致 <code>ls</code> 命令报错。</p>
<h2> shopt 命令</h2>
<p><code>shopt</code> 命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。</p>
<p><code>shopt</code> 命令的使用方法如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>
<p><strong>dotglob 参数</strong></p>
<p><code>dotglob</code> 参数可以让扩展结果包括隐藏文件(即点开头的文件)。</p>
<p>正常情况下，扩展结果不包括隐藏文件。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>打开 <code>dotglob</code>，就会包括隐藏文件。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>nullglob 参数</strong></p>
<p><code>nullglob</code> 参数可以让通配符不匹配任何文件名时，返回空字符。</p>
<p>默认情况下，通配符不匹配任何文件名时，会保持不变。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，由于当前目录不包括 <code>b</code> 开头的文件名，导致 <code>b*</code> 不会发生文件名扩展，保持原样不变，所以 <code>rm</code> 命令报错没有 <code>b*</code> 这个文件。</p>
<p>打开 <code>nullglob</code> 参数，就可以让不匹配的通配符返回空字符串。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，由于没有 <code>b*</code> 匹配的文件名，所以 <code>rm b*</code> 扩展成了 <code>rm</code>，导致报错变成了”缺少操作数“。</p>
</li>
<li>
<p><strong>failglob 参数</strong></p>
<p><code>failglob</code> 参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，打开 <code>failglob</code> 以后，由于 <code>b*</code> 不匹配任何文件名，Bash 直接报错了，不再让 <code>rm</code> 命令去处理。</p>
</li>
<li>
<p><strong>extglob 参数</strong></p>
<p><code>extglob</code> 参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p><strong>nocaseglob 参数</strong></p>
<p><code>nocaseglob</code> 参数可以让通配符扩展不区分大小写。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，打开 <code>nocaseglob</code> 以后，<code>program*</code> 就不区分大小写了，可以匹配 <code>ProgramData</code> 等。</p>
</li>
<li>
<p><strong>globstar 参数</strong></p>
<p><code>globstar</code> 参数可以使得 <code>**</code> 匹配零个或多个子目录。该参数默认是关闭的。</p>
<p>假设有下面的文件结构。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的文件结构中，顶层目录、第一级子目录 <code>sub1</code>、第二级子目录 <code>sub1\sub2</code> 里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来?</p>
<p>默认情况下，只能写成下面这样。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这是因为 <code>*</code> 只匹配当前目录，如果要匹配子目录，只能一层层写出来。</p>
<p>打开 <code>globstar</code> 参数以后，<code>**</code> 匹配零个或多个子目录。因此，<code>**/*.txt</code> 就可以得到想要的结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<h2> 参考链接</h2>
<ul>
<li><a href="https://medium.com/@leedowthwaite/why-most-people-only-think-they-understand-wildcards-63bb9c2024ab" target="_blank" rel="noopener noreferrer">Think You Understand Wildcards? Think Again</a></li>
<li><a href="https://appcodelabs.com/advanced-wildcard-patterns-most-people-dont-know" target="_blank" rel="noopener noreferrer">Advanced Wildcard Patterns Most People Don’t Know</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 函数</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/function.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/function.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Bash 函数</source>
      <description>本章介绍 Bash 函数的用法。</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 函数的用法。</p>
<!-- more -->
<h2> 简介</h2>
<p>函数(function)是可以重复使用的代码片段，有利于代码的复用。它与别名(alias)的区别是，别名只适合封装简单的单个命令，函数则可以封装复杂的多行命令。</p>
<p>函数总是在当前 Shell 执行，这是跟脚本的一个重大区别，Bash 会新建一个子 Shell 执行脚本。如果函数与脚本同名，函数会优先执行。但是，函数的优先级不如别名，即如果函数与别名同名，那么别名优先执行。</p>
<p>Bash 函数定义的语法有两种。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>fn</code> 是自定义的函数名，函数代码就写在大括号之中。这两种写法是等价的。</p>
<p>下面是一个简单函数的例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，函数体里面的 <code>$1</code> 表示函数调用时的第一个参数。</p>
<p>调用时，就直接写函数名，参数跟在函数名后面。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个多行函数的例子，显示当前日期时间。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>删除一个函数，可以使用 <code>unset</code> 命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看当前 Shell 已经定义的所有函数，可以使用 <code>declare</code> 命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面的 <code>declare</code> 命令不仅会输出函数名，还会输出所有定义。输出顺序是按照函数名的字母表顺序。由于会输出很多内容，最好通过管道命令配合 <code>more</code> 或 <code>less</code> 使用。</p>
<p><code>declare</code> 命令还支持查看单个函数的定义。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>declare -F</code> 可以输出所有已经定义的函数名，不含函数体。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 参数变量</h2>
<p>函数体内可以使用参数变量，获取函数参数。函数的参数变量，与脚本参数变量是一致的。</p>
<ul>
<li><code>$1</code> ~ <code>$9</code>: 函数的第一个到第 9 个的参数。</li>
<li><code>$0</code>: 函数所在的脚本名。</li>
<li><code>$#</code>: 函数的参数总数。</li>
<li><code>$@</code>: 函数的全部参数，参数之间使用空格分隔。</li>
<li><code>$*</code>: 函数的全部参数，参数之间使用变量 <code>$IFS</code> 值的第一个字符分隔，默认为空格，但是可以自定义。</li>
</ul>
<p>如果函数的参数多于 9 个，那么第 10 个参数可以用 <code>${10}</code> 的形式引用，以此类推。</p>
<p>下面是一个示例脚本 <code>test.sh</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行该脚本，结果如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，由于函数 <code>alice</code> 只有第一个和第二个参数，所以第三个和第四个参数为空。</p>
<p>下面是一个日志函数的例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用方法如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> return 命令</h2>
<p><code>return</code> 命令用于从函数返回一个值。函数执行到这条命令，就不再往下执行了，直接返回了。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>函数将返回值返回给调用者。如果命令行直接执行函数，下一个命令可以用 <code>$?</code> 拿到返回值。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>return</code> 后面不跟参数，只用于返回也是可以的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 全局变量和局部变量，local 命令</h2>
<p>Bash 函数体内直接声明的变量，属于全局变量，整个脚本都可以读取。这一点需要特别小心。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面脚本的运行结果如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，变量 <code>$foo</code> 是在函数 <code>fn</code> 内部声明的，函数体外也可以读取。</p>
<p>函数体内不仅可以声明全局变量，还可以修改全局变量。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码执行后，输出的变量 <code>$foo</code> 值为 2。</p>
<p>函数里面可以用 <code>local</code> 命令声明局部变量。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面脚本的运行结果如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>local</code> 命令声明的 <code>$foo</code> 变量，只在函数体内有效，函数体外没有定义。</p>
<h2> 参考链接</h2>
<ul>
<li><a href="https://www.linuxtechi.com/define-use-functions-linux-shell-script/" target="_blank" rel="noopener noreferrer">How to define and use functions in Linux Shell Script</a>, by Pradeep Kumar</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 的基本语法</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/grammar.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/grammar.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Bash 的基本语法</source>
      <description>本章介绍 Bash 的最基本语法。</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>本章介绍 Bash 的最基本语法。</p>
<!-- more -->
<h2> echo 命令</h2>
<p>由于后面的例子会大量用到 <code>echo</code> 命令，这里先介绍这个命令。</p>
<p><code>echo</code> 命令的作用是在屏幕输出一行文本，可以将该命令的参数原样输出。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>echo</code> 的参数是 <code>hello world</code>，可以原样输出。</p>
<p>如果想要输出的是多行文本，即包括换行符。这时需要把多行文本放在引号里面。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>echo</code> 可以原样输出多行文本。</p>
<h3> <code>-n</code> 参数</h3>
<p>默认情况下，<code>echo</code> 输出的文本末尾会有一个回车符。<code>-n</code> 参数可以取消末尾的回车符，使得下一个提示符紧跟在输出内容的后面。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>world</code> 后面直接就是下一行的提示符 <code>$</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>-n</code> 参数可以让两个 <code>echo</code> 命令的输出连在一起，出现在同一行。</p>
<h3> <code>-e</code> 参数</h3>
<p><code>-e</code> 参数会解释引号(双引号和单引号)里面的特殊字符(比如换行符 <code>\n</code>)。如果不使用 <code>-e</code> 参数，即默认情况下，引号会让特殊字符变成普通字符，<code>echo</code> 不解释它们，原样输出。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>-e</code> 参数使得 <code>\n</code> 解释为换行符，导致输出内容里面出现换行。</p>
<h2> 命令格式</h2>
<p>命令行环境中，主要通过使用 Shell 命令，进行各种操作。Shell 命令基本都是下面的格式。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码中，<code>command</code> 是具体的命令或者一个可执行文件，<code>arg1 ... argN</code> 是传递给命令的参数，它们是可选的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面这个命令中，<code>ls</code> 是命令，<code>-l</code> 是参数。</p>
<p>有些参数是命令的配置项，这些配置项一般都以一个连词线开头，比如上面的 <code>-l</code>。同一个配置项往往有长和短两种形式，比如 <code>-l</code> 是短形式，<code>--list</code> 是长形式，它们的作用完全相同。短形式便于手动输入，长形式一般用在脚本之中，可读性更好，利于解释自身的含义。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，<code>-r</code> 是短形式，<code>--reverse</code> 是长形式，作用完全一样。前者便于输入，后者便于理解。</p>
<p>Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 空格</h2>
<p>Bash 使用空格(或 Tab 键)区分不同的参数。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令中，<code>foo</code> 和 <code>bar</code> 之间有一个空格，所以 Bash 认为它们是两个参数。</p>
<p>如果参数之间有多个空格，Bash 会自动忽略多余的空格。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，<code>a</code> 和 <code>test</code> 之间有多个空格，Bash 会忽略多余的空格。</p>
<h2> 分号</h2>
<p>分号(<code>;</code>)是命令的结束符，使得一行可以放置多个命令，上一个命令执行结束后，再执行第二个命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，Bash 先执行 <code>clear</code> 命令，执行完成后，再执行 <code>ls</code> 命令。</p>
<p>注意，使用分号时，第二个命令总是接着第一个命令执行，不管第一个命令执行成功或失败。</p>
<h2> 命令的组合符 <code>&amp;&amp;</code> 和 <code>||</code></h2>
<p>除了分号，Bash 还提供两个命令组合符 <code>&amp;&amp;</code> 和 <code>||</code>，允许更好地控制多个命令之间的继发关系。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行成功，则继续运行 <code>Command2</code> 命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令的意思是，如果 <code>Command1</code> 命令运行失败，则继续运行 <code>Command2</code> 命令。</p>
<p>下面是一些例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，只要 <code>cat</code> 命令执行结束，不管成功或失败，都会继续执行 <code>ls</code> 命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，只有 <code>cat</code> 命令执行成功，才会继续执行 <code>ls</code> 命令。如果 <code>cat</code> 执行失败(比如不存在文件 <code>flielist.txt</code>)，那么 <code>ls</code> 命令就不会执行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，只有 <code>mkdir foo</code> 命令执行失败(比如 <code>foo</code> 目录已经存在)，才会继续执行 <code>mkdir bar</code> 命令。如果 <code>mkdir foo</code> 命令执行成功，就不会创建 <code>bar</code> 目录了。</p>
<h2> type 命令</h2>
<p>Bash 本身内置了很多命令，同时也可以执行外部程序。怎么知道一个命令是内置命令，还是外部程序呢?</p>
<p><code>type</code> 命令用来判断命令的来源。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>type</code> 命令告诉我们，<code>echo</code> 是内部命令，<code>ls</code> 是外部程序 (<code>/bin/ls</code>)。</p>
<p><code>type</code> 命令本身也是内置命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果要查看一个命令的所有定义，可以使用 <code>type</code> 命令的 <code>-a</code> 参数。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码表示，<code>echo</code> 命令即是内置命令，也有对应的外部程序。</p>
<p><code>type</code> 命令的 <code>-t</code> 参数，可以返回一个命令的类型: 别名(alias)，关键词(keyword)，函数(function)，内置命令(builtin)和文件(file)。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>bash</code> 是文件，<code>if</code> 是关键词。</p>
<h2> 快捷键</h2>
<p>Bash 提供很多快捷键，可以大大方便操作。下面是一些最常用的快捷键，完整的介绍参见 <a href="/tutorial/ops/linux/bash/readline.html" target="blank">行操作</a> 一章。</p>
<ul>
<li><code>Ctrl + L</code>: 清除屏幕并将当前行移到页面顶部。</li>
<li><code>Ctrl + C</code>: 中止当前正在执行的命令。</li>
<li><code>Shift + PageUp</code>: 向上滚动。</li>
<li><code>Shift + PageDown</code>: 向下滚动。</li>
<li><code>Ctrl + U</code>: 从光标位置删除到行首。</li>
<li><code>Ctrl + K</code>: 从光标位置删除到行尾。</li>
<li><code>Ctrl + D</code>: 关闭 Shell 会话。</li>
<li><code>↑</code>，<code>↓</code>: 浏览已执行命令的历史记录。</li>
</ul>
<p>除了上面的快捷键，Bash 还具有自动补全功能。命令输入到一半的时候，可以按下 Tab 键，Bash 会自动完成剩下的部分。比如，输入 <code>pw</code>，然后按一下 Tab 键，Bash 会自动补上 <code>d</code>。</p>
<p>除了命令的自动补全，Bash 还支持路径的自动补全。有时，需要输入很长的路径，这时只需要输入前面的部分，然后按下 Tab 键，就会自动补全后面的部分。如果有多个可能的选择，按两次 Tab 键，Bash 会显示所有选项，让您选择。</p>
]]></content:encoded>
    </item>
    <item>
      <title>Bash 简介</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/intro.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/intro.html</guid>
      <source url="https://leijue222.github.io/rss.xml">Bash 简介</source>
      <description>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 是 Unix 系统和 Linux 系统的一种 Shell(命令行环境)，是目前绝大多数 Linux 发行版的默认 Shell。</p>
<!-- more -->
<h2> Shell 的含义</h2>
<p>学习 Bash，首先需要理解 Shell 是什么。Shell 这个单词的原意是“外壳”，跟 kernel(内核)相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。</p>
<p>具体来说，Shell 这个词有多种含义。</p>
<p>首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境(commandline，简写为 CLI)。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。本书中，除非特别指明，Shell 指的就是命令行环境。</p>
<p>其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本(script)。这些脚本都通过 Shell 的解释执行，而不通过编译。</p>
<p>最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。</p>
<h2> Shell 的种类</h2>
<p>Shell 有很多种，只要能给用户提供命令行环境的程序，都可以看作是 Shell。</p>
<p>历史上，主要的 Shell 有下面这些。</p>
<ul>
<li>Bourne Shell(sh)</li>
<li>Bourne Again shell(bash)</li>
<li>C Shell(csh)</li>
<li>TENEX C Shell(tcsh)</li>
<li>Korn shell(ksh)</li>
<li>Z Shell(zsh)</li>
<li>Friendly Interactive Shell(fish)</li>
</ul>
<p>Bash 是目前最常用的 Shell，除非特别指明，下文的 Shell 和 Bash 当作同义词使用，可以互换。</p>
<p>下面的命令可以查看当前运行的 Shell。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>下面的命令可以查看当前的 Linux 系统安装的所有 Shell。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面两个命令中，<code>$</code> 是命令行环境的提示符，用户只需要输入提示符后面的内容。</p>
<p>Linux 允许每个用户使用不同的 Shell，用户的默认 Shell 一般都是 Bash，或者与 Bash 兼容。</p>
<h2> 命令行环境</h2>
<h3> 终端模拟器</h3>
<p>如果是不带有图形环境的 Linux 系统(比如专用于服务器的系统)，启动后就直接是命令行环境。</p>
<p>不过，现在大部分的 Linux 发行版，尤其是针对普通用户的发行版，都是图形环境。用户登录系统后，自动进入图形环境，需要自己启动终端模拟器，才能进入命令行环境。</p>
<p>所谓“终端模拟器”(terminal emulator)就是一个模拟命令行窗口的程序，让用户在一个窗口中使用命令行环境，并且提供各种附加功能，比如调整颜色、字体大小、行距等等。</p>
<p>不同 Linux 发行版(准确地说是不同的桌面环境)带有的终端程序是不一样的，比如 KDE 桌面环境的终端程序是 konsole，Gnome 桌面环境的终端程序是 gnome-terminal，用户也可以安装第三方的终端程序。所有终端程序，尽管名字不同，基本功能都是一样的，就是让用户可以进入命令行环境，使用 Shell。</p>
<h3> 命令行提示符</h3>
<p>进入命令行环境以后，用户会看到 Shell 的提示符。提示符往往是一串前缀，最后以一个美元符号 <code>$</code> 结尾，用户可以在这个符号后面输入各种命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，完整的提示符是 <code>[user@hostname] $</code>，其中前缀是用户名(<code>user</code>)加上 <code>@</code>，再加主机名(<code>hostname</code>)。比如，用户名是 <code>bill</code>，主机名是 <code>home-machine</code>，前缀就是 <code>bill@home-machine</code>。</p>
<p>注意，根用户(root)的提示符，不以美元符号 (<code>$</code>) 结尾，而以井号 (<code>#</code>) 结尾，用来提醒用户，现在具有根权限，可以执行各种操作，务必小心，不要出现误操作。这个符号是可以自己定义的，详见《命令提示符》一章。</p>
<p>为了简洁，后文的命令行提示符都只使用 <code>$</code> 表示。</p>
<h3> 进入和退出方法</h3>
<p>进入命令行环境以后，一般就已经打开 Bash 了。如果您的 Shell 不是 Bash，可以输入 <code>bash</code> 命令启动 Bash。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>退出 Bash 环境，可以使用 <code>exit</code> 命令，也可以同时按下 <code>Ctrl + d</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Bash 的基本用法就是在命令行输入各种命令，非常直观。作为练习，可以试着输入 <code>pwd</code> 命令。按下回车键，就会显示当前所在的目录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不小心输入了 <code>pwe</code>，会返回一个提示，表示输入出错，没有对应的可执行程序。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> Shell 和 Bash 的历史</h2>
<p>Shell 伴随着 Unix 系统的诞生而诞生。</p>
<p>1969 年，Ken Thompson 和 Dennis Ritchie 开发了第一版的 Unix。</p>
<p>1971 年，Ken Thompson 编写了最初的 Shell，称为 Thompson shell，程序名是 <code>sh</code>，方便用户使用 Unix。</p>
<p>1973 年至 1975 年间，John R. Mashey 扩展了最初的 Thompson shell，添加了编程功能，使得 Shell 成为一种编程语言。这个版本的 Shell 称为 Mashey shell。</p>
<p>1976 年，Stephen Bourne 结合 Mashey shell 的功能，重写一个新的 Shell，称为 Bourne shell。</p>
<p>1978 年，加州大学伯克利分校的 Bill Joy 开发了 C shell，为 Shell 提供 C 语言的语法，程序名是 <code>csh</code>。它是第一个真正替代 <code>sh</code> 的 UNIX shell，被合并到 Berkeley UNIX 的 2BSD 版本中。</p>
<p>1979 年，UNIX 第七版发布，内置了 Bourne Shell，导致它成为 Unix 的默认 Shell。注意，Thompson shell、Mashey shell 和 Bourne shell 都是贝尔实验室的产品，程序名都是 <code>sh</code>。对于用户来说，它们是同一个东西，只是底层代码不同而已。</p>
<p>1983 年，David Korn 开发了 Korn shell，程序名是 <code>ksh</code>。</p>
<p>1985 年，Richard Stallman 成立了自由软件基金会(FSF)，由于 Shell 的版权属于贝尔公司，所以他决定写一个自由版权的、使用 GNU 许可证的 Shell 程序，避免 Unix 的版权争议。</p>
<p>1988 年，自由软件基金会的第一个付薪程序员 Brian Fox 写了一个 Shell，功能基本上是 Bourne shell 的克隆，叫做 Bourne-Again SHell，简称 Bash，程序名为 <code>bash</code>，任何人都可以免费使用。后来，它逐渐成为 Linux 系统的标准 Shell。</p>
<p>1989 年，Bash 发布 1.0 版。</p>
<p>1996 年，Bash 发布 2.0 版。</p>
<p>2004 年，Bash 发布 3.0 版。</p>
<p>2009 年，Bash 发布 4.0 版。</p>
<p>2019 年，Bash 发布 5.0 版。</p>
<p>用户可以通过 <code>bash</code> 命令的 <code>--version</code> 参数或者环境变量 <code>$BASH_VERSION</code>，查看本机的 Bash 版本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>循环</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/loop.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/loop.html</guid>
      <source url="https://leijue222.github.io/rss.xml">循环</source>
      <description>Bash 提供三种循环语法 for、while 和 until。</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 提供三种循环语法 <code>for</code>、<code>while</code> 和 <code>until</code>。</p>
<!-- more -->
<h2> while 循环</h2>
<p><code>while</code> 循环有一个判断条件，只要符合条件，就不断循环执行指定的语句。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，只要满足条件 <code>condition</code>，就会执行命令 <code>commands</code>。然后，再次判断是否满足条件 <code>condition</code>，只要满足，就会一直执行下去。只有不满足条件，才会退出循环。</p>
<p>循环条件 <code>condition</code> 可以使用 <code>test</code> 命令，跟 <code>if</code> 结构的判断条件写法一致。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，只要变量 <code>$number</code> 小于 10，就会不断加 1，直到 <code>$number</code> 等于 10，然后退出循环。</p>
<p>关键字 <code>do</code> 可以跟 <code>while</code> 不在同一行，这时两者之间不需要使用分号分隔。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的例子会无限循环，可以按下 <code>Ctrl + c</code> 停止。</p>
<p><code>while</code> 循环写成一行，也是可以的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>while</code> 的条件部分也可以是执行一个命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面例子中，判断条件是 <code>echo 'ECHO'</code>。由于这个命令总是执行成功，所以上面命令会产生无限循环。</p>
<p><code>while</code> 的条件部分可以执行任意数量的命令，但是执行结果的真伪只看最后一个命令的执行结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码运行后，不会有任何输出，因为 <code>while</code> 的最后一个命令是 <code>false</code>。</p>
<h2> until 循环</h2>
<p><code>until</code> 循环与 <code>while</code> 循环恰好相反，只要不符合判断条件(判断条件失败)，就不断循环执行指定的语句。一旦符合判断条件，就退出循环。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关键字 <code>do</code> 可以与 <code>until</code> 不写在同一行，这时两者之间不需要分号分隔。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>until</code> 的部分一直为 <code>false</code>，导致命令无限运行，必须按下 <code>Ctrl + c</code> 终止。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，只要变量 <code>number</code> 小于 10，就会不断加 1，直到 <code>number</code> 大于等于 10，就退出循环。</p>
<p><code>until</code> 的条件部分也可以是一个命令，表示在这个命令执行成功之前，不断重复尝试。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子表示，只要 <code>cp $1 $2</code> 这个命令执行不成功，就 5 秒钟后再尝试一次，直到成功为止。</p>
<p><code>until</code> 循环都可以转为 <code>while</code> 循环，只要把条件设为否定即可。上面这个例子可以改写如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来说，<code>until</code> 用得比较少，完全可以统一都使用 <code>while</code>。</p>
<h2> <code>for...in</code> 循环</h2>
<p><code>for...in</code> 循环用于遍历列表的每一项。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面语法中，<code>for</code> 循环会依次从 <code>list</code> 列表中取出一项，作为变量 <code>variable</code>，然后在循环体中进行处理。</p>
<p>关键词 <code>do</code> 可以跟 <code>for</code> 写在同一行，两者使用分号分隔。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>word1 word2 word3</code> 是一个包含三个单词的列表，变量 <code>i</code> 依次等于 <code>word1</code>、<code>word2</code>、<code>word3</code>，命令 <code>echo $i</code> 则会相应地执行三次。</p>
<p>列表可以由通配符产生。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>*.png</code> 会替换成当前目录中所有 PNG 图片文件，变量 <code>i</code> 会依次等于每一个文件。</p>
<p>列表也可以通过子命令产生。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>cat ~/.bash_profile</code> 命令会输出 <code>~/.bash_profile</code> 文件的内容，然后通过遍历每一个词，计算该文件一共包含多少个词，以及每个词有多少个字符。</p>
<p><code>in list</code> 的部分可以省略，这时 <code>list</code> 默认等于脚本的所有参数 <code>$@</code>。但是，为了可读性，最好还是不要省略，参考下面的例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在函数体中也是一样的，<code>for...in</code> 循环省略 <code>in list</code> 的部分，则 <code>list</code> 默认等于函数的所有参数。</p>
<h2> for 循环</h2>
<p><code>for</code> 循环还支持 C 语言的循环语法。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，<code>expression1</code> 用来初始化循环条件，<code>expression2</code> 用来决定循环结束的条件，<code>expression3</code> 在每次循环迭代的末尾执行，用于更新值。</p>
<p>注意，循环条件放在双重圆括号之中。另外，圆括号之中使用变量，不必加上美元符号 <code>$</code>。</p>
<p>它等同于下面的 <code>while</code> 循环。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，初始化变量 <code>i</code> 的值为 0，循环执行的条件是 <code>i</code> 小于 5。每次循环迭代结束时，<code>i</code> 的值加 1。</p>
<p><code>for</code> 条件部分的三个语句，都可以省略。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面脚本会反复读取命令行输入，直到用户输入了一个点(<code>.</code>)位为止，才会跳出循环。</p>
<h2> break，continue</h2>
<p>Bash 提供了两个内部命令 <code>break</code> 和 <code>continue</code>，用来在循环内部跳出循环。</p>
<p><code>break</code> 命令立即终止循环，程序继续执行循环块之后的语句，即不再执行剩下的循环。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子只会打印 3 行结果。一旦变量 <code>$number</code> 等于 3，就会跳出循环，不再继续执行。</p>
<p><code>continue</code> 命令立即终止本轮循环，开始执行下一轮循环。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，只要用户输入的文件不存在，<code>continue</code> 命令就会生效，直接进入下一轮循环(让用户重新输入文件名)，不再执行后面的打印语句。</p>
<h2> select 结构</h2>
<p><code>select</code> 结构主要用来生成简单的菜单。它的语法与 <code>for...in</code> 循环基本一致。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Bash 会对 <code>select</code> 依次进行下面的处理。</p>
<ol>
<li><code>select</code> 生成一个菜单，内容是列表 <code>list</code> 的每一项，并且每一项前面还有一个数字编号。</li>
<li>Bash 提示用户选择一项，输入它的编号。</li>
<li>用户输入以后，Bash 会将该项的内容存在变量 <code>name</code>，该项的编号存入环境变量 <code>REPLY</code>。如果用户没有输入，就按回车键，Bash 会重新输出菜单，让用户选择。</li>
<li>执行命令体 <code>commands</code>。</li>
<li>执行结束后，回到第一步，重复这个过程。</li>
</ol>
<p>下面是一个例子。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行上面的脚本，Bash 会输出一个品牌的列表，让用户选择。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果用户没有输入编号，直接按回车键。Bash 就会重新输出一遍这个菜单，直到用户按下 <code>Ctrl + c</code>，退出执行。</p>
<p><code>select</code> 可以与 <code>case</code> 结合，针对不同项，执行不同的命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，<code>case</code> 针对用户选择的不同项，执行不同的命令。</p>
<h2> 参考链接</h2>
<ul>
<li><a href="https://linuxhint.com/bash_select_command/" target="_blank" rel="noopener noreferrer">Bash Select Command</a>, Fahmida Yesmin</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>mktemp 命令，trap 命令</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/mktemp.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/mktemp.html</guid>
      <source url="https://leijue222.github.io/rss.xml">mktemp 命令，trap 命令</source>
      <description>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 /tmp 目录里面创建文件或目录，这样做有很多弊端，使用 mktemp 命令是最安全的做法。</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>Bash 脚本有时需要创建临时文件或临时目录。常见的做法是，在 <code>/tmp</code> 目录里面创建文件或目录，这样做有很多弊端，使用 <code>mktemp</code> 命令是最安全的做法。</p>
<!-- more -->
<h2> 临时文件的安全问题</h2>
<p>直接创建临时文件，尤其在 <code>/tmp</code> 目录里面，往往会导致安全问题。</p>
<p>首先，<code>/tmp</code> 目录是所有人可读写的，任何用户都可以往该目录里面写文件。创建的临时文件也是所有人可读的。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令在 <code>/tmp</code> 目录直接创建文件，该文件默认是所有人可读的。</p>
<p>其次，如果攻击者知道临时文件的文件名，他可以创建符号链接，链接到临时文件，可能导致系统运行异常。攻击者也可能向脚本提供一些恶意数据。因此，临时文件最好使用不可预测、每次都不一样的文件名，防止被利用。</p>
<p>最后，临时文件使用完毕，应该删除。但是，脚本意外退出时，往往会忽略清理临时文件。</p>
<p>生成临时文件应该遵循下面的规则。</p>
<blockquote>
<ul>
<li>创建前检查文件是否已经存在。</li>
<li>确保临时文件已成功创建。</li>
<li>临时文件必须有权限的限制。</li>
<li>临时文件要使用不可预测的文件名。</li>
<li>脚本退出时，要删除临时文件(使用 <code>trap</code> 命令)。</li>
</ul>
</blockquote>
<h2> mktemp 命令的用法</h2>
<p><code>mktemp</code> 命令就是为安全创建临时文件而设计的。虽然在创建临时文件之前，它不会检查临时文件是否存在，但是它支持唯一文件名和清除机制，因此可以减轻安全攻击的风险。</p>
<p>直接运行 <code>mktemp</code> 命令，就能生成一个临时文件。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，<code>mktemp</code> 命令生成的临时文件名是随机的，而且权限是只有用户本人可读写。</p>
<p>Bash 脚本使用 <code>mktemp</code> 命令的用法如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了确保临时文件创建成功，<code>mktemp</code> 命令后面最好使用 OR 运算符 (<code>||</code>)，保证创建失败时退出脚本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了保证脚本退出时临时文件被删除，可以使用 <code>trap</code> 命令指定退出时的清除操作。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> mktemp 命令的参数</h2>
<p><code>-d</code> 参数可以创建一个临时目录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>-p</code> 参数可以指定临时文件所在的目录。默认是使用 <code>$TMPDIR</code> 环境变量指定的目录，如果这个变量没设置，那么使用 <code>/tmp</code> 目录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>-t</code> 参数可以指定临时文件的文件名模板，模板的末尾必须至少包含三个连续的 <code>X</code> 字符，表示随机字符，建议至少使用六个 <code>X</code>。默认的文件名模板是 <code>tmp.</code> 后接十个随机字符。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> trap 命令</h2>
<p><code>trap</code> 命令用来在 Bash 脚本中响应系统信号。</p>
<p>最常见的系统信号就是 SIGINT(中断)，即按 <code>Ctrl + C</code> 所产生的信号。<code>trap</code> 命令的 <code>-l</code> 参数，可以列出所有的系统信号。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>trap</code> 的命令格式如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面代码中，“动作”是一个 Bash 命令，“信号”常用的有以下几个。</p>
<blockquote>
<ul>
<li>HUP: 编号 1，脚本与所在的终端脱离联系。</li>
<li>INT: 编号 2，用户按下 Ctrl + C，意图让脚本中止运行。</li>
<li>QUIT: 编号 3，用户按下 Ctrl + 斜杠，意图退出脚本。</li>
<li>KILL: 编号 9，该信号用于杀死进程。</li>
<li>TERM: 编号 15，这是 <code>kill</code> 命令发出的默认信号。</li>
<li>EXIT: 编号 0，这不是系统信号，而是 Bash 脚本特有的信号，不管什么情况，只要退出脚本就会产生。</li>
</ul>
</blockquote>
<p><code>trap</code> 命令响应 <code>EXIT</code> 信号的写法如下。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面命令中，脚本遇到 <code>EXIT</code> 信号时，就会执行 <code>rm -f "$TMPFILE"</code>。</p>
<p>trap 命令的常见使用场景，就是在 Bash 脚本中指定退出时执行的清理命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面代码中，不管是脚本正常执行结束，还是用户按 <code>Ctrl + C</code> 终止，都会产生 <code>EXIT</code> 信号，从而触发删除临时文件。</p>
<p>注意，<code>trap</code> 命令必须放在脚本的开头。否则，它上方的任何命令导致脚本退出，都不会被它捕获。</p>
<p>如果 <code>trap</code> 需要触发多条命令，可以封装一个 Bash 函数。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 参考链接</h2>
<ul>
<li><a href="https://www.putorius.net/working-with-temporary-files.html" target="_blank" rel="noopener noreferrer">Working with Temporary Files and Directories in Shell Scripts</a>, Steven Vona</li>
<li><a href="https://www.putorius.net/using-trap-to-exit-bash-scripts-cleanly.html" target="_blank" rel="noopener noreferrer">Using Trap to Exit Bash Scripts Cleanly</a></li>
<li><a href="https://mywiki.wooledge.org/SignalTrap" target="_blank" rel="noopener noreferrer">Sending and Trapping Signals</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>命令提示符</title>
      <link>https://leijue222.github.io/tutorial/ops/linux/bash/prompt.html</link>
      <guid>https://leijue222.github.io/tutorial/ops/linux/bash/prompt.html</guid>
      <source url="https://leijue222.github.io/rss.xml">命令提示符</source>
      <description>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</description>
      <category>Linux</category>
      <pubDate>Tue, 11 Apr 2023 02:47:21 GMT</pubDate>
      <content:encoded><![CDATA[<p>用户进入 Bash 以后，Bash 会显示一个命令提示符，用来提示用户在该位置后面输入命令。</p>
<!-- more -->
<h2> 环境变量 PS1</h2>
<p>命令提示符通常是美元符号 <code>$</code>，对于根用户则是井号 <code>#</code>。这个符号是环境变量 <code>PS1</code> 决定的，执行下面的命令，可以看到当前命令提示符的定义。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Bash 允许用户自定义命令提示符，只要改写这个变量即可。改写后 的 <code>PS1</code>，可以放在用户的 Bash 配置文件 <code>.bashrc</code> 里面，以后新建 Bash 对话时，新的提示符就会生效。要在当前窗口看到修改后的提示符，可以执行下面的命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令提示符的定义，可以包含特殊的转义字符，表示特定内容。</p>
<ul>
<li><code>\a</code>: 响铃，计算机发出一记声音。</li>
<li><code>\d</code>: 以星期、月、日格式表示当前日期，例如“Mon May 26”。</li>
<li><code>\h</code>: 本机的主机名。</li>
<li><code>\H</code>: 完整的主机名。</li>
<li><code>\j</code>: 运行在当前 Shell 会话的工作数。</li>
<li><code>\l</code>: 当前终端设备名。</li>
<li><code>\n</code>: 一个换行符。</li>
<li><code>\r</code>: 一个回车符。</li>
<li><code>\s</code>: Shell 的名称。</li>
<li><code>\t</code>: 24 小时制的 <code>hours:minutes:seconds</code> 格式表示当前时间。</li>
<li><code>\T</code>: 12 小时制的当前时间。</li>
<li><code>\@</code>: 12 小时制的 <code>AM/PM</code> 格式表示当前时间。</li>
<li><code>\A</code>: 24 小时制的 <code>hours:minutes</code> 表示当前时间。</li>
<li><code>\u</code>: 当前用户名。</li>
<li><code>\v</code>: Shell 的版本号。</li>
<li><code>\V</code>: Shell 的版本号和发布号。</li>
<li><code>\w</code>: 当前的工作路径。</li>
<li><code>\W</code>: 当前目录名。</li>
<li><code>\!</code>: 当前命令在命令历史中的编号。</li>
<li><code>\#</code>: 当前 shell 会话中的命令数。</li>
<li><code>\$</code>: 普通用户显示为 <code>$</code> 字符，根用户显示为 <code>#</code> 字符。</li>
<li><code>\[</code>: 非打印字符序列的开始标志。</li>
<li><code>\]</code>: 非打印字符序列的结束标志。</li>
</ul>
<p>举例来说，<code>[\u@\h \W]\$</code> 这个提示符定义，显示出来就是 <code>[user@host ~]$</code> (具体的显示内容取决于您的系统)。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>改写 <code>PS1</code> 变量，就可以改变这个命令提示符。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>注意，<code>$</code> 后面最好跟一个空格，这样的话，用户的输入与提示符就不会连在一起。</p>
<h2> 颜色</h2>
<p>默认情况下，命令提示符是显示终端预定义的颜色。Bash 允许自定义提示符颜色。</p>
<p>使用下面的代码，可以设定其后文本的颜色。</p>
<ul>
<li><code>\033[0;30m</code>: 黑色</li>
<li><code>\033[1;30m</code>: 深灰色</li>
<li><code>\033[0;31m</code>: 红色</li>
<li><code>\033[1;31m</code>: 浅红色</li>
<li><code>\033[0;32m</code>: 绿色</li>
<li><code>\033[1;32m</code>: 浅绿色</li>
<li><code>\033[0;33m</code>: 棕色</li>
<li><code>\033[1;33m</code>: 黄色</li>
<li><code>\033[0;34m</code>: 蓝色</li>
<li><code>\033[1;34m</code>: 浅蓝色</li>
<li><code>\033[0;35m</code>: 粉红</li>
<li><code>\033[1;35m</code>: 浅粉色</li>
<li><code>\033[0;36m</code>: 青色</li>
<li><code>\033[1;36m</code>: 浅青色</li>
<li><code>\033[0;37m</code>: 浅灰色</li>
<li><code>\033[1;37m</code>: 白色</li>
</ul>
<p>举例来说，如果要将提示符设为红色，可以将 <code>PS1</code> 设成下面的代码。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是，上面这样设置以后，用户在提示符后面输入的文本也是红色的。为了解决这个问题， 可以在结尾添加另一个特殊代码 <code>\[\033[00m\]</code>，表示将其后的文本恢复到默认颜色。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>除了设置前景颜色，Bash 还允许设置背景颜色。</p>
<ul>
<li><code>\033[0;40m</code>: 蓝色</li>
<li><code>\033[1;44m</code>: 黑色</li>
<li><code>\033[0;41m</code>: 红色</li>
<li><code>\033[1;45m</code>: 粉红</li>
<li><code>\033[0;42m</code>: 绿色</li>
<li><code>\033[1;46m</code>: 青色</li>
<li><code>\033[0;43m</code>: 棕色</li>
<li><code>\033[1;47m</code>: 浅灰色</li>
</ul>
<p>下面是一个带有红色背景的提示符。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 环境变量 PS2，PS3，PS4</h2>
<p>除了 <code>PS1</code>，Bash 还提供了提示符相关的另外三个环境变量。</p>
<p>环境变量 <code>PS2</code> 是命令行折行输入时系统的提示符，默认为 <code>&gt;</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面命令中，输入 <code>hello</code> 以后按下回车键，系统会提示继续输入。这时，第二行显示的提示符就是 <code>PS2</code> 定义的 <code>&gt;</code>。</p>
<p>环境变量 <code>PS3</code> 是使用 <code>select</code> 命令时，系统输入菜单的提示符。</p>
<p>环境变量 <code>PS4</code> 默认为 <code>+</code>。它是使用 Bash 的 <code>-x</code> 参数执行脚本时，每一行命令在执行前都会先打印出来，并且在行首出现的那个提示符。</p>
<p>比如下面是脚本 <code>test.sh</code>。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <code>-x</code> 参数执行这个脚本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面例子中，输出的第一行前面有一个 <code>+</code>，这就是变量 <code>PS4</code> 定义的。</p>
]]></content:encoded>
    </item>
  </channel>
</rss>